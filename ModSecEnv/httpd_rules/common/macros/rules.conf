# :: Macros: Rules
# Range: 2000005-2000023
# ---------------------------------------------------------------

#:: Set ModSecurity engine for a URL
<Macro SecRuleEngineUrl $action $url>
 Use NotInsideLocation
 <IfDefine !noSecurityRules>
  Use SecRule TX:url  "$url"  "phase:1,~{nosecaction},t:none,ctl:ruleEngine=$action,tag:Engine"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$action $url"
 </IfDefine>
</Macro>

#:: Set ModSecurity engine for a vhost
<Macro SecRuleEngineVhost $action $host>
 Use NotInsideLocation
 <IfDefine !noSecurityRules>
  Use SecRule REQUEST_HEADERS:Host "$host" "phase:1,~{nosecaction},t:none,ctl:ruleEngine=$action,tag:Engine"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$action $host"
 </IfDefine>
</Macro>

#:: Set ModSecurity engine for a client IP address
<Macro SecRuleEngineIp $action $ip>
 Use NotInsideLocation
 <IfDefine !IpMatch>
  Use SecRuleIp "^(?:$ip)$" "phase:1,~{nosecaction},t:none,ctl:ruleEngine=$action,tag:Engine"
 </IfDefine>
 <IfDefine IpMatch>
  Use SecRuleIp "@IpMatch $ip" "phase:1,~{nosecaction},t:none,ctl:ruleEngine=$action,tag:Engine"
 </IfDefine>
</Macro>

#:: Set ModSecurity engine for a vhost and a URL
<Macro SecRuleEngineVhostUrl $action $host $url>
 Use NotInsideLocation
 <IfDefine !noSecurityRules>
  Use SecRule REQUEST_HEADERS:Host $host "phase:1,~{nosecaction},t:none,chain,tag:Engine"
   Use SecRule TX:url $url "t:none,ctl:ruleEngine=$action"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$action $host $url"
 </IfDefine>
</Macro>

#:: Set ModSecurity engine for a vhost, a URL and an IP
<Macro SecRuleEngineVhostUrlIp $action $host $url $ip>
 Use NotInsideLocation
 <IfDefine !noSecurityRules>
  <IfDefine !IpMatch>
   Use SecRuleIp  "^(?:$ip)$"  "phase:1,~{nosecaction},t:none,chain,tag:Engine"
  </IfDefine>
  <IfDefine IpMatch>
   Use SecRuleIp  "@IpMatch $ip"  "phase:1,~{nosecaction},t:none,chain,tag:Engine"
  </IfDefine>
   Use SecRule REQUEST_HEADERS:Host  "$host"  "phase:1,~{nosecaction},t:none,chain,ctl:ruleEngine=$action,tag:Engine"
    Use SecRule TX:url "$url" "t:none,ctl:ruleEngine=$action"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$action $host $url $ip"
 </IfDefine>
</Macro>

#:: Set ModSecurity engine for a URL and an IP
<Macro SecRuleEngineUrlIp $action $url $ip>
 Use NotInsideLocation
 <IfDefine !noSecurityRules>
  <IfDefine !IpMatch>
   Use SecRuleIp  "^(?:$ip)$"  "phase:1,~{nosecaction},t:none,chain,tag:Engine"
  </IfDefine>
  <IfDefine IpMatch>
   Use SecRuleIp  "@IpMatch $ip"  "phase:1,~{nosecaction},t:none,chain,tag:Engine"
  </IfDefine>
   Use SecRule TX:url  "$url"  "t:none,ctl:ruleEngine=$action"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$action $url $ip"
 </IfDefine>
</Macro>

#:: Enable ModSecurity parsing for a URL (regex)
<Macro AllowAndParseXML @url>
 <IfDefine !XMLParsing>
  Error You must activate XML Parsing globally with "Define XMLParsing 1" in params.conf (impact on performances) 
 </IfDefine>
 Use NotInsideLocation
 <IfDefine !noSecurityRules>
  # Parse XML requests as XML => check syntax & maps XML input to ARGS (too late if incorrect MIME-Type)
  Use SecRule TX:url @url "phase:1,chain,~{nosecaction},t:none,id:2000007"
   Use SecRule ENV:req_xml "@gt 0" "t:none,ctl:requestBodyProcessor=XML"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam @url
 </IfDefine>
 <LocationMatch @url>
  Use AllowXML
 </LocationMatch>
</Macro>

# Skip rules in case other succeed
<Macro SkipAfterOnSuccess_ $phase $id $marker>
 Use SecAction "phase:$phase,id:$id,~{skipAfter}:$marker"
</Macro>
<Macro SkipAfterOnSuccess  @id @marker>
 Use SkipAfterOnSuccess_ 2 @id @marker
</Macro>
# Skip if both id1 & id2 where executed
<Macro SkipAfterOnSuccess2 $id1 $id2 $tags @marker>
 Use SecAction "phase:2,~{skip}:1$tags,id:$id1"
 Use SecAction "phase:2,~{skip}:1$tags,id:$id2"
 Use SkipAfterOnSuccess $id2$tags @marker
</Macro>

<Macro SecRuleSubsetOf $idSuperSet $idToDisable>
 Use SecAction "phase:2,id:$idSuperSet,~{nosecaction},ctl:ruleRemoveById=$idToDisable"
</Macro>

# Detect, deny and increase counters
<Macro SecRuleDeny $target $pattern $action>
  Use SecRule "$target" "$pattern" "~{defaultDenyAction},tag:Macro,capture,$action"
</Macro>
<Macro SecActionDeny $action>
  Use SecAction "~{defaultDenyAction},tag:Macro,$action"
</Macro>

<Macro SecRuleGT  $target       $max               $id                                                                                       $action>
 Use SecRuleDeny "$target" "@gt $max"  "phase:2,id:$id,t:none,~{status}:413,msg:'Target too large',logdata:'$target: %{TX.targetlen} > $max',$action"
</Macro>

# Int comparison only supports up to 2147483647 => only compare lower than that
# Default tfn is "none"
# $target must not be empty
# $id must contain a leading ,
# $tfn must contain a leading ,
# result in TX.intcmp: lt, eq, gt
#   not sure: empty
<Macro SecRuleIntComp_ $target $value $id $tfn>
 # Compare string length
 Use SecRule "$target" @unconditionalMatch      "phase:2$id,t:none$tfn,~{nosecaction},setvar:TX.intval=$value,setvar:TX.target=%{MATCHED_VAR},setvar:TX.cmpval=%{MATCHED_VAR}"
 Use SecRule TX:target @unconditionalMatch      "phase:2$id,t:none,t:length,~{nosecaction},setvar:TX.targetlen=%{MATCHED_VAR}"
 Use SecRule TX:intval @unconditionalMatch      "phase:2$id,t:none,t:length,~{nosecaction},setvar:TX.intvallen=%{MATCHED_VAR}"
 Use SecRule TX:targetlen "@lt %{TX.intvallen}" "phase:2$id,t:none,~{skipAfter}:AfterIntComp,setvar:TX.intcmp=lt"
 Use SecRule TX:targetlen "@gt %{TX.intvallen}" "phase:2$id,t:none,~{skipAfter}:AfterIntComp,setvar:TX.intcmp=gt"
 # If length = same, compare 9 first digits
 Use SecRule TX:intvallen "@le 9"               "phase:2$id,t:none,~{skipAfter}:NormalIntComp"
  Use SecRule TX:intval "(.{0,9})"              "phase:2$id,t:none,~{nosecaction},capture,setvar:TX.intval=%{TX.1}"
  Use SecRule TX:target "(.{0,9})"              "phase:2$id,t:none,~{nosecaction},capture,setvar:TX.target=%{TX.1}"
  Use SecRule TX:target "@lt %{TX.intval}"      "phase:2$id,t:none,~{skipAfter}:AfterIntComp,setvar:TX.intcmp=lt"
  Use SecRule TX:target "@gt %{TX.intval}"      "phase:2$id,t:none,~{skipAfter}:AfterIntComp,setvar:TX.intcmp=gt"
  # We don't know, difference is after 9th digit
  Use SecAction                                 "phase:2$id,t:none,~{skipAfter}:AfterIntComp,setvar:!TX.intcmp"

 # Compare int value
 Use SecMarker NormalIntComp
  Use SecRule TX:target "@lt $value"             "phase:2$id,t:none,~{skipAfter}:AfterIntComp,setvar:TX.intcmp=lt"
  Use SecRule TX:target "@gt $value"             "phase:2$id,t:none,~{skipAfter}:AfterIntComp,setvar:TX.intcmp=gt"
  Use SecAction                                  "phase:2$id,t:none,~{skipAfter}:AfterIntComp,setvar:TX.intcmp=eq"
 Use SecMarker AfterIntComp
</Macro>
# Block if > $max
<Macro SecRuleGTBig_ $target $max $id $action>
  Use SecRule "$target"  "^0?$"   "phase:2$id,t:none,~{skipAfter}:AfterRuleGT"
  Use SecRule "&$target" "@eq 0"  "phase:2$id,t:none,~{skipAfter}:AfterRuleGT"
   Use SecRuleIntComp_ "$target" $max "$id,tag:security" ""
   Use SecRuleDeny TX:intcmp "^gt"  "phase:2$id,t:none,~{status}:413,msg:'Target too large',logdata:'$target: %{TX.targetlen} > $max',$action"
 Use SecMarker AfterRuleGT,tag:security   
</Macro>
<Macro SecRuleGTBig_noid @target $max    @action>
 Use SecRuleGTBig_       @target $max "" @action
</Macro>
<Macro SecRuleGTBig  @target $max $id            @action>
 Use SecRuleGTBig_   @target $max ",id:$id" @action
</Macro>

# Limit arguments name syntax
<Macro SecArgNameAllowAllCharacters>
 Use SecRuleRemoveByID 2000021,2000022,2000024
</Macro>

DefineStr cd_fname "(?i:\bname\s*+=\s*+(['\x22])?(?(1)([^'\x22]*)\1|([^;\s]*)))"
<Macro SecRuleArgNameChars__ @target $pattern $actions>
 Use SecRuleDeny @target "!(?i)^[$pattern]*$" "tag:Protocol,~{status}:400,$actions"
# \x... gives a syntax error in some MS versions !?!
# ,logdata:'Name: %{MATCHED_VAR} (allowed chars: $pattern)'
</Macro>
<Macro SecRuleArgNameChars_ @pattern $exc>
 Use SecArgNameAllowAllCharacters
 Use SecRuleArgNameChars__ "ARGS_NAMES|!ARGS_NAMES:'$exc'" @pattern "t:~{encodedParam},id:2000021,msg:'Invalid syntax in arg name (Use SecArgNameAllowCharacter)'"
 # For Content-Disposition: "name" field for files
 Use SecAction                                                 "phase:2,id:2000022,tag:Protocol,tag:security,~{nosecaction},setvar:!tx.n_"
 Use SecRule REQUEST_HEADERS:Content-Disposition "~{cd_fname}" "phase:2,id:2000022,tag:Protocol,tag:security,t:none,capture,setvar:tx.n_=%{tx.2}%{tx.3},~{nosecaction}"
 Use SecRuleArgNameChars__ TX:n_ @pattern                              "id:2000022,t:none,msg:'Invalid name in Content-Disposition <name> parameter (Use SecArgNameAllowCharacter)'"
 # For multipart: "name" field => concatenate all names
 <IfDefine MODSEC_AnalyseMultipartHeaders>
  Use SecAction                                                                     "phase:2,id:2000024,tag:Protocol,tag:security,~{nosecaction},setvar:!tx.n_"
  Use SecRule MULTIPART_PART_HEADERS "(?i)Content-Disposition:.*~{cd_fname}"        "phase:2,id:2000024,tag:Protocol,tag:security,t:none,capture,setvar:tx.n_=%{tx.n_}%{tx.2}%{tx.3},~{nosecaction}"
  Use SecRuleArgNameChars__ TX:n_ @pattern                                                  "id:2000024,t:none,msg:'Invalid syntax in multipart ARG name (Use SecArgNameAllowCharacter), logging concatenated names'"
 </IfDefine>
</Macro>

<Macro SecRuleArgNameCharsStrict @pattern>
 Use SecRuleArgNameChars_        @pattern "###"
</Macro>

<Macro SecRuleArgNameChars @pattern>
 Use SecRuleArgNameChars_  @pattern "/(?:~{IgnoredArgNames_})|(?:~{IgnoredArgNames})|(?:~{EmergencyIgnoredArgNames})/"
</Macro>

<Macro SecArgNameAllowCharacter $char>
 Use SecRuleArgNameChars       "$char~{CharMin}"
</Macro>

# Whitelist ARGS ---------------------------------------------------------------
<Macro WhiteListTemplate_ $phase $coll $arg $pattern $action>
 <IfDefine !noSecurityRules>
  Use SecRuleDeny "$coll:'$arg'" "!$pattern"               "phase:$phase,tag:wl-$arg,tag:WhiteList,t:none,msg:'Invalid input',$action"
  Use SecRuleDeny "$coll:'$arg'" "(?<![.][.])[.]/"         "phase:$phase,tag:wl-$arg,tag:WhiteList,t:none,id:2000012,multiMatch,$action,~{testRule},rev:20240220,tag:Dot,tag:Slash,tag:PATH,msg:'./ in $coll:$arg'"
  Use SkipAfterOnSuccess_ $phase 2000012,tag:wl-$arg,tag:security AfterWLDotDotSlash
  Use SecRuleDeny "$coll:'$arg'" "(?<![.])[.][.]/"         "phase:$phase,tag:wl-$arg,tag:WhiteList,t:none,id:2000011,multiMatch,$action,~{testRule},rev:20240220,tag:Dot,tag:Slash,tag:PATH,msg:'../ in $coll:$arg'"
  Use SecMarker AfterWLDotDotSlash,tag:wl-$arg,tag:security,tag:Dot,tag:Slash,tag:PATH
  Use SecRuleDeny "$coll:'$arg'" "/[.](?!(?i:net)|[.][.])" "phase:$phase,tag:wl-$arg,tag:WhiteList,t:none,id:2000013,multiMatch,$action,~{testRule},rev:20240220,tag:Dot,tag:Slash,tag:PATH,msg:'/. in $coll:$arg'"
  Use SecRule     "$coll:'$arg'" @unconditionalMatch       "phase:$phase,tag:wl-$arg,tag:WhiteList,t:none,~{nosecaction},setvar:'TX.allowedArgs=%{TX.allowedArgs}|%{MATCHED_VAR_NAME}|'"
  Use SecAction                                            "phase:$phase,tag:wl-$arg,tag:WhiteList,tag:security,~{nosecaction},setvar:'TX.WL_Access_control=$arg'"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use EmptyMacro
 </IfDefine>
</Macro>
<Macro WhiteListUsername $phase $coll $arg $regex>
 Use WhiteListTemplate_  $phase $coll $arg "^(?:(?:$regex) *|)$" "~{badUseridMsg},tag:Auth"
 Use RegisterUsername_   "$coll:'$arg'"
</Macro>
<Macro WhiteListColl_    $phase $coll @arg @pattern>
 Use WhiteListTemplate_  $phase $coll @arg @pattern "msg:'Arg: invalid syntax'"
</Macro>
<Macro WhiteListCollExt_ $phase $coll $arg @pattern $min $max>
 <IfDefine !noSecurityRules>
  Use SecRuleDeny "&$coll:'$arg'" "@lt $min" "phase:$phase,tag:wl-$arg,tag:WhiteList,~{status}:400,msg:'Missing Arg <$arg>'"
  Use SecRuleDeny "&$coll:'$arg'" "@gt $max" "phase:$phase,tag:wl-$arg,tag:WhiteList,~{status}:400,msg:'Too many Args <$arg>'"
  Use WhiteListColl_ "$phase" "$coll" "$arg" @pattern
 </IfDefine>
 <IfDefine noSecurityRules>
  Use EmptyMacro
 </IfDefine>
</Macro>
<Macro ArgWhiteListExt $arg @pattern @min @max>
 Use SecRuleRemoveByFullTag wl-$arg
 Use WhiteListCollExt_ 2 ARGS $arg @pattern @min @max
</Macro>
<Macro ArgWhiteList $arg @pattern>
 Use SecRuleRemoveByFullTag wl-$arg
 Use SecRuleDeny &ARGS:$arg "@gt 1" "phase:2,tag:wl-$arg,tag:WhiteList,~{status}:400,msg:'Too many Args <$arg>'"
 Use WhiteListColl_ 2 ARGS $arg @pattern
</Macro>
<Macro ArgGetWhiteListExt @arg @pattern @min @max>
 Use WhiteListCollExt_ 2 ARGS_GET @arg @pattern @min @max
</Macro>
<Macro ArgGetWhiteListExtP1 @arg @pattern @min @max>
 Use WhiteListCollExt_ 1 ARGS_GET @arg @pattern @min @max
</Macro>
<Macro ArgGetWhiteList $arg @pattern>
 Use SecRuleRemoveByFullTag wl-$arg
 Use SecRule "&ARGS:'$arg'" "@gt 1" "phase:2,tag:wl-$arg,tag:WhiteList,~{increaseBlockCounter},~{status}:400,msg:'Too many Args <$arg>'"
 Use WhiteListColl_ 2 ARGS_GET $arg @pattern
</Macro>
<Macro ArgGetWhiteListP1 $arg @pattern>
 Use SecRuleRemoveByFullTag wl-$arg
 Use NotInsideLocation
 Use SecRuleDeny "&ARGS:'$arg'" "@gt 1"   "phase:1,tag:wl-$arg,tag:WhiteList,~{status}:400,msg:'Too many Args <$arg>'"
 Use WhiteListColl_ 1 ARGS_GET $arg @pattern
</Macro>
<Macro ArgPostWhiteListExt @arg @pattern @min @max>
 Use WhiteListCollExt_ 2 ARGS_POST @arg @pattern @min @max
</Macro>
<Macro ArgPostWhiteList $arg @pattern>
 Use SecRuleRemoveByFullTag wl-$arg
 Use SecRuleDeny "&ARGS:'$arg'" "@gt 1" "phase:2,tag:wl-$arg,tag:WhiteList,~{status}:400,msg:'Too many Args <$arg>'"
 Use WhiteListColl_ 2 ARGS_POST "$arg" @pattern
</Macro>
<Macro CheckWhiteListArgs_ $phase $id $action>
 Use SecRuleDeny ARGS_NAMES "!@within |%{TX.allowedArgs}|" "phase:$phase,id:$id,tag:WhiteList,t:none,~{status}:400,msg:'Unregistered Arg',logdata:%{MATCHED_VAR}"
 Use SecAction                                             "phase:$phase,id:$id,tag:WhiteList,tag:security,~{nosecaction},setvar:!TX.WL_Access_control$action"
</Macro>
<Macro CheckWhiteListArgs>
 Use SecRuleRemoveByFullTag ARGS
 Use SecRuleRemoveByID 2000009
 # <If> parsed after other directives
 <If "'1' = '1'">
  Use CheckWhiteListArgs_ 2 2000009 ""
 </If>
</Macro>
<Macro CheckWhiteListArgsP1_ @action>
 Use NotInsideLocation
 Use SecRuleRemoveByID 2000010
 Use CheckWhiteListArgs_ 1 2000010 @action
</Macro>
<Macro CheckWhiteListArgsP1>
 Use CheckWhiteListArgsP1_ ",ctl:ruleRemoveByTag=ARGS"
</Macro>
<Macro CheckWhiteListArgsP1WithArgChecks>
 Use CheckWhiteListArgsP1_ ""
</Macro>

# Anti-replay & state tokens ---------------------------------------------------
# Store token (vhost level)
<Macro TokenIncreaseUsage @token>
 <IfDefine TokenTest>
  Use HashIfNeeded @token 5
  Use SecRule TX:t_ @unconditionalMatch "phase:5,t:none,~{nosecaction},initcol:RESOURCE=app_%{TX.hash_app},setvar:RESOURCE.tok_%{TX.t_}=+1,expirevar:RESOURCE.tok_%{TX.t_}=600"
 </IfDefine>
</Macro>

# Check nb of times token was used (cf. replay attacks)
<Macro TokenCheckNb @token $min_nb $max_nb>
 <IfDefine TokenTest>
 # %{%{TX.token_}} doesn't work
 # RESOURCE:%{MATCHED_VAR_NAME}.%{MATCHED_VAR} doesn't work
 # possibility: store all tokens in same var & @within => huge content
 Use SecAction "phase:2,~{nosecaction},setvar:!TX.token_"
 Use HashIfNeeded @token 2
 Use SecRule RESOURCE:/^tok_/ @unconditionalMatch   "phase:2,t:none,chain,~{nosecaction}"
  Use SecRule MATCHED_VARS_NAMES "@streq %{TX.t_}"   "t:none,setvar:TX.token_=%{MATCHED_VAR}"
 Use SecRuleDeny TX:token_ "@lt $min_nb" "t:none,~{status}:403,msg:'No token found'"
 Use SecRuleDeny TX:token_ "@gt $max_nb" "t:none,~{status}:403,msg:'Too many tokens found: %{TX.token_}'"
 Use TokenIncreaseUsage @token
 </IfDefine>
</Macro>
<Macro TokenCheckExist @token $var>
 <IfDefine TokenTest>
 Use SecAction "phase:2,~{nosecaction},setvar:!TX.$var"
 Use HashIfNeeded @token 2
 Use SecRule RESOURCE:/^tok_/ @unconditionalMatch   "phase:2,t:none,chain,~{nosecaction}"
  Use SecRule MATCHED_VARS_NAMES "@streq %{TX.t_}"   "t:none,setvar:TX.$var"
 Use TokenIncreaseUsage @token
 </IfDefine>
</Macro>
# ------------------------------------------------------------------------------

<Macro SecBlockHostName @host>
 Use NotInsideLocation
 <IfDefine !noSecurityRules>
  Use SecRule REQUEST_HEADERS:Host @host "phase:1,t:none,~{DisableAllRequestsStatus},msg:'Host forbidden'"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam @host
 </IfDefine>
</Macro>

<Macro SanitizeBytes_ @h @regex $bytes>
 # Operator must support capture => @rx
 Use SecRule @h @regex "phase:5,capture,t:none,sanitiseMatchedBytes:$bytes,~{skipAfter}:AfterSanitize"
</Macro>
<Macro Sanitize_ $h @regex>
 <IfDefine EXTENDEDSTATUS>
  Use SecRule $h @unconditionalMatch "phase:1,t:none,~{nosecaction},setenv:LOG_SANITIZED"
  Use SecRule $h @unconditionalMatch "phase:3,t:none,~{nosecaction},setenv:LOG_SANITIZED"
 </IfDefine>
 Use SecRule &$h "@eq 0" "phase:5,t:none,~{skipAfter}:AfterSanitize"
  # Operator must support capture => @rx
  Use SanitizeBytes_ $h "^(.{61,})$"  "12/12"
  Use SanitizeBytes_ $h "^(.{41,60})$" "8/8"
  Use SanitizeBytes_ $h "^(.{21,40})$" "5/5"
  Use SecRule $h @regex "phase:5,capture,t:none,~{nosecaction},sanitiseMatched"
 Use SecMarker AfterSanitize
</Macro>
<Macro SanitizeHeaderExt        $h  @regex>
 Use Sanitize_ REQUEST_HEADERS:'$h' @regex
</Macro>
<Macro SanitizeHeader  @h>
 Use SanitizeHeaderExt @h @unconditionalMatch
</Macro>
<Macro SanitizeResponseHeaderExt $h  @regex>
 Use Sanitize_ RESPONSE_HEADERS:'$h' @regex
</Macro>
<Macro SanitizeResponseHeader    $h>
 Use Sanitize_ RESPONSE_HEADERS:'$h' @unconditionalMatch
</Macro>

<Macro SanitizeCookieHeader @h $cookie>
 # Sanitise $cookie (keep first X characters, including name)
 <IfDefine EXTENDEDSTATUS>
  Use SecRule @h "\b(?i:$cookie=)[^; ]+"  "phase:2,~{nosecaction},t:none,setenv:LOG_SANITIZED"
 </IfDefine>
 Use  SecRule @h "\b(?i:$cookie=)[^; ]+"  "phase:5,~{nosecaction},t:none,capture,sanitiseMatchedBytes:8/3"
</Macro>
<Macro SanitizeCookie @cookie>
 Use SanitizeCookieHeader REQUEST_HEADERS:Cookie      @cookie
 Use SanitizeCookieHeader RESPONSE_HEADERS:Set-Cookie @cookie
</Macro>

<Macro SanitizeArg $arg>
 <IfDefine EXTENDEDSTATUS>
  # set env early to notify test client
  Use SecRule "ARGS:'$arg'"   .     "phase:2,t:none,~{nosecaction},setenv:LOG_SANITIZED"
 </IfDefine>
 Use  SecRule "ARGS:'$arg'"   .     "phase:5,t:none,~{nosecaction},sanitiseMatched"
</Macro>

<Macro SecRuleXMLArg $arg $pattern $action>
 <IfDefine !noSecurityRules>
  <IfDefine XMLParsing>
   Use SecRule "XML:'/$arg'|XML:'//*/$arg'|XML:'/*/$arg'" "$pattern" "$action,tag:Macro"
  </IfDefine>
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$arg $pattern $action"
 </IfDefine>
</Macro>

<Macro SanitizeXML $arg>
 <IfDefine XMLParsing>
   # Doesn't work for regex
  #Use SecRuleXMLArg "$arg" . "phase:5,~{nosecaction},sanitiseMatched,setvar:TX.SanLogC"
  # Works for regex, but not enclosed in slashes as with ARGS
  Use SecAction "phase:2,t:none,~{nosecaction},setvar:'TX.XmlSanArgs=%{TX.XmlSanArgs}|$arg'"
 </IfDefine>
</Macro>

# Block 1 Arg
<Macro SecRuleArg $arg $pattern $action>
 <IfDefine !noSecurityRules>
  Use SecRule "ARGS:'$arg'"    "$pattern"  "phase:2,~{increaseBlockCounter},~{deny},t:~{jsDecode},tag:ARGS,tag:Macro,msg:'Invalid ARGS <$arg>',$action"
  Use SecRuleXMLArg "$arg"     "$pattern"  "phase:2,~{increaseBlockCounter},~{deny},t:~{jsDecode},tag:ARGS,tag:Macro,msg:'Invalid XML ARGS <$arg>',$action"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$arg $pattern $action"
 </IfDefine>
</Macro>

<Macro SecRuleArgRegex   $arg     @target @tfn_action>
 # --Optional spaces before variable name is needed, as PHP ignores them
 Use SecRuleArg "/^ *(?i:$arg)$/" @target @tfn_action
</Macro>

# Block Args
<Macro SecRuleExcludeArgsNoAction_ @pattern $id $tfn_action $excl>
 # ARGS always needed for begin/end of string
 # url_arg: ARG extracted from URL
 # SpecificArg: Specific ARG set by an application (ex: base64-decoded)
 Use SecRule "~{args}|!ARGS:'/^(?i:$excl)$/'|TX:url_arg|TX:SpecificArg"  @pattern  "phase:2,t:~{jsDecode},capture,id:$id,msg:'Invalid ARG',$tfn_action,tag:ARGS,tag:SecRuleArgs"
 <IfDefine XMLParsing>
  # All XML parameters values concatenated
  Use SecRule "XML:/*"                                     @pattern  "phase:2,t:~{jsDecode},msg:'Invalid input',id:$id,$tfn_action,tag:ARGS,tag:XML"
  # XML parameters values individually parsed (warning about perf)
  #Use SecRule "XML://*"                                    @pattern  "phase:2,t:~{jsDecode},msg:'Invalid XML ARG',capture,id:$id,$tfn_action,tag:XML,tag:SecRuleArgs"
 </IfDefine>
</Macro>
<Macro SecRuleExcludeArgs_         $pattern   $id $tfn_action $excl>
 <IfDefine !noSecurityRules>
  Use SecRuleExcludeArgsNoAction_ "$pattern" "$id,tag:Macro" "~{defaultDenyAction},$tfn_action,logdata:%{MATCHED_VAR_NAME}" "$excl"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$pattern $id $tfn_action $excl"
 </IfDefine>
</Macro>
<Macro SecRuleExcludeArgs @pattern @id @tfn_action @excl>
 Use SecRuleExcludeArgs_  @pattern @id @tfn_action @excl
</Macro>
<Macro SecRuleArgs       @pattern  $id              @tfn_action>
 Use SecRuleExcludeArgs  @pattern "$id,tag:Develop" @tfn_action "###"
</Macro>
# No encoding
<Macro SecRuleArgsAscii @pattern $id $tfn_action>
 Use SecRuleExcludeArgs  @pattern  "$id"  "t:~{ascii},$tfn_action"  "###"
 Use SecRuleExcludeArgs  @pattern  "$id"             "$tfn_action"  "###"
</Macro>

<Macro SecRuleReqBody_ $pattern $id_tags $tfn_action>
 <IfDefine !noSecurityRules>
  # Parse body only if no uploaded files
  Use SecRule FILES_COMBINED_SIZE "@gt 0"             "phase:2,id:$id_tags,t:none,~{skipAfter}:AfterReqBodyCheck"
   Use SecRule STREAM_INPUT_BODY "$pattern"           "phase:2,id:$id_tags,capture,t:~{jsDecode},$tfn_action"
   # In case STREAM_INPUT_BODY is not populated, use REQUEST_BODY
   Use SecRule STREAM_INPUT_BODY  @unconditionalMatch "phase:2,id:$id_tags,t:none,~{skipAfter}:AfterReqBodyCheck"
    Use SecRule REQUEST_BODY     "$pattern"           "phase:2,id:$id_tags,capture,t:~{jsDecode},$tfn_action"
  Use SecMarker AfterReqBodyCheck
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$pattern $tfn_action"
 </IfDefine>
</Macro>

<Macro SecRuleRequestXML_ $pattern $id_tags $tfn_action>
 <IfDefine !noSecurityRules>
  <IfDefine !noXML>
   # Parse XML body only
   Use SecRule &ENV:req_xml "@eq 0" "phase:2,id:$id_tags,t:none,~{skipAfter}:AfterXMLBodyCheck,tag:security"
    # Parse body only if not already parsed in XML collection
    <IfDefine XMLParsing>
     Use SecRule &XML "!@eq 0"       "phase:2,id:$id_tags,t:none,~{skipAfter}:AfterXMLBodyCheck,tag:security"
    </IfDefine>
      Use SecRuleReqBody_ "$pattern" "$id_tags" "$tfn_action"
   Use SecMarker AfterXMLBodyCheck,tag:security
  </IfDefine>
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$pattern $id_tags $tfn_action"
 </IfDefine>
</Macro>

# Block body (only used for XML)
<Macro SecRuleRequestBody $pattern $id_tags $tfn_action>
 <IfDefine !noSecurityRules>
  # Parse XML body only
  Use SecRuleRequestXML_ "$pattern" "$id_tags" "~{defaultDenyAction},msg:'Invalid body content',$tfn_action,tag:Body"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$pattern $id_tags $tfn_action"
 </IfDefine>
</Macro>

# Block Cookies
<Macro SecRuleCookiesNoAction_ $reqCookies @pattern $id $tfn_action>
 Use SecRule "$reqCookies" @pattern "phase:2,t:~{jsDecode},capture,$tfn_action,id:$id,tag:COOKIE,tag:SecRuleCookies"
</Macro>
<Macro SecRuleCookies_         $reqCookies   $pattern    $id $tfn_action>
 <IfDefine !noSecurityRules>
  Use SecRuleCookiesNoAction_ "$reqCookies" "$pattern"  "$id" "~{increaseBlockCounter},~{deny},msg:'Invalid cookie content',$tfn_action,logdata:%{MATCHED_VAR_NAME}"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$reqCookies $pattern $id $tfn_action"
 </IfDefine>
</Macro>
<Macro SecRuleCookie                   $cookie   @pattern @id @tfn_action>
 Use SecRuleCookies_ "REQUEST_COOKIES:'$cookie'" @pattern @id @tfn_action
</Macro>
<Macro SecRuleCookiesExclude @pattern @id @tfn_action $excl>
 Use SecRule ENV:ignoreAllCookies @unconditionalMatch "phase:2,tag:security,tag:COOKIE,tag:SecRuleCookies,~{skipAfter}:AfterSecRuleCookies"
  Use SecRuleCookies_ "~{cookies}|!REQUEST_COOKIES:'$excl'"  @pattern  @id  @tfn_action
 Use SecMarker AfterSecRuleCookies,tag:security
</Macro>
<Macro SecRuleCookies      @pattern @id @tfn_action>
 Use SecRuleCookiesExclude @pattern @id @tfn_action "###" 
</Macro>
<Macro SecRuleCookiesAscii          @pattern   $id               $tfn_action>
 Use SecRule ENV:ignoreAllCookies @unconditionalMatch "phase:2,tag:security,tag:COOKIE,tag:SecRuleCookies,~{skipAfter}:AfterSecRuleCookies"
  Use SecRuleCookies_ "~{cookies}"  @pattern  "$id"  "t:~{ascii},$tfn_action"
  Use SecRuleCookies_ "~{cookies}"  @pattern  "$id"             "$tfn_action"
 Use SecMarker AfterSecRuleCookies,tag:security
</Macro>

# Block Args & Cookies
<Macro SecRuleExcludeArgsAndCookies @pattern @id @tfn_action @excl>
 Use SecRuleExcludeArgs             @pattern @id @tfn_action @excl
 Use SecRuleCookiesExclude          @pattern @id @tfn_action @excl
</Macro>
<Macro SecRuleArgsCookies          @pattern @id @tfn_action>
 Use SecRuleExcludeArgsAndCookies  @pattern @id @tfn_action "###"
</Macro>
<Macro SecRuleArgsCookiesNoAction         @pattern @id $tfn_action>
 Use SecRuleExcludeArgsNoAction_          @pattern @id "~{nosecaction},$tfn_action,~{fixBlockCounter}" "###"
 Use SecRuleCookiesNoAction_ "~{cookies}" @pattern @id "~{nosecaction},$tfn_action,~{fixBlockCounter}"
</Macro>
<Macro SecRuleArgsCookiesAscii @pattern @id @tfn_action>
 Use SecRuleCookiesAscii       @pattern @id @tfn_action
 Use SecRuleArgsAscii          @pattern @id @tfn_action
</Macro>

# Block body, args & cookies
# SecRuleInput is more generic: use "SecRuleBodyArgsCookies" only when the pattern shouldn't checked against URL
<Macro SecRuleBodyArgsCookies @pattern @id @tfn_action>
 Use SecRuleCookies           @pattern @id @tfn_action
 Use SecRuleArgs              @pattern @id @tfn_action
 Use SecRuleRequestBody       @pattern @id @tfn_action
</Macro>

# Block all inputs (but headers)
<Macro SecRuleInput         @pattern @id @tfn_action>
 Use SecRuleBodyArgsCookies @pattern @id @tfn_action
 Use SecRuleUrl             @pattern @id @tfn_action
</Macro>
# Block all inputs but headers
<Macro SecRuleInputBody @pattern @id @tfn_action>
 Use SecRuleInput       @pattern @id @tfn_action
 Use Warning "SecRuleInputBody is obsolete, use SecRuleInput"
</Macro>

# Block headers
<Macro SecRuleHeaders $pattern $id $tfn_action>
 <IfDefine !OptimGlobalRegex>
  # t:~{jsDecode}?
  Use SecRuleDeny "~{ReqHeaders}" "$pattern" "t:~{encodedParam},tag:SecRuleHeaders,id:$id,$tfn_action,msg:'Invalid content in header <%{MATCHED_VAR_NAME}>'"
  # |!REQUEST_HEADERS:/Cookies2?/
 </IfDefine>
 <IfDefine OptimGlobalRegex>
  Use SecAction "phase:2,tag:SecRuleHeaders,id:$id,~{nosecaction},~{denyUnSetEnv},setvar:'TX.GlRegexH=%{TX.GlRegexH}|$pattern'"
  Use SecRuleDeny "~{ReqHeaders}" "$pattern" "phase:5,t:~{encodedParam},multiMatch,tag:SecRuleHeaders,id:$id,~{log},~{denyUnSetEnv},msg:'Invalid content in header <%{MATCHED_VAR_NAME}>'"
 </IfDefine>
</Macro>

# Block all inputs including headers
<Macro SecRuleInputHeaders @pattern $idi $idh $tags  $tfn_action>
 Use SecRuleInput          @pattern "$idi,$tags"    "$tfn_action"
 Use SecRuleHeaders        @pattern "$idh,$tags"    "$tfn_action"
</Macro>
<Macro SecRuleInputHeaders1 @pattern @id     @tags @tfn_action>
 Use SecRuleInputHeaders    @pattern @id @id @tags @tfn_action
</Macro>

<Macro SecRulePathEverywhere @pattern $id          @tfn_action>
 #Use SecRuleBodyArgsCookies  @pattern $id,tag:PATH @tfn_action
 #Use SecRuleHeaders          @pattern $id,tag:PATH @tfn_action
 Use SecRuleArgsCookies      @pattern $id,tag:PATH @tfn_action
 Use SecRuleUrl              @pattern $id          @tfn_action
</Macro>

# Is this needed?
<Macro SecRuleBlockClientPath @pattern  $id           @tfn_action>
 Use SecRulePathEverywhere    @pattern "$id"          @tfn_action
 Use SecRuleUpFile_           @pattern "$id,tag:PATH" @tfn_action
</Macro>

# Block headers, args, cookies & url
<Macro SecRuleArgsFileUrlHeadersCookies @pattern @id @tfn_action>
 Use SecRuleInputHeaders                @pattern @id @tfn_action
 Use Warning "SecRuleArgsFileUrlHeadersCookies is obsolete, use 'SecRuleInputHeaders' (with adapted syntax)"
</Macro>

<Macro SecRuleInputHeadersSQL @pattern $idi $idh  $tags $tfn_action>
 Use SecRuleInputHeaders      @pattern $idi $idh "$tags,tag:SQL" "t:~{sqlNormalize},$tfn_action"
 # 2002101 forbids comments /* in body
 Use SkipAfterOnSuccess 2002101,tag:SQL,tag:Slash,tag:Star,tag:security SqlCmtB
  Use SecRuleInput            @pattern "$idi,$tags,tag:SQL,tag:Slash,tag:Star" "t:~{sqlNormalizeNoComment},$tfn_action"
 Use SecMarker SqlCmtB,tag:security
 # 2002102 forbids comments /* in headers
 Use SkipAfterOnSuccess 2002102,tag:SQL,tag:Slash,tag:Star,tag:security SqlCmtH
  Use SecRuleHeaders          @pattern "$idh,$tags,tag:SQL,tag:Slash,tag:Star" "t:~{sqlNormalizeNoComment},$tfn_action"
 Use SecMarker SqlCmtH,tag:security
</Macro>

<Macro SecRuleSQLMacro_ @macro @pattern $id $tags $tfn_action>
 Use @macro  @pattern "$id,$tags,tag:SQL" "t:~{sqlNormalize},$tfn_action"
 # 2002101 forbids comments /* in body
 Use SkipAfterOnSuccess        2002101,tag:SQL,tag:Slash,tag:Star,tag:security SqlCmtA
  Use @macro @pattern "$id,$tags,tag:SQL,tag:Slash,tag:Star" "t:~{sqlNormalizeNoComment},$tfn_action"
 Use SecMarker                 SqlCmtA,tag:SQL,tag:Slash,tag:Star,tag:security
</Macro>
<Macro SecRuleArgsSQL             @pattern @id @tags @tfn_action>
 Use SecRuleSQLMacro_ SecRuleArgs @pattern @id @tags @tfn_action
</Macro>
<Macro SecRuleCookiesSQL             @pattern @id @tags @tfn_action>
 Use SecRuleSQLMacro_ SecRuleCookies @pattern @id @tags @tfn_action
</Macro>
<Macro SecRuleArgsCookiesSQL             @pattern @id @tags @tfn_action>
 Use SecRuleSQLMacro_ SecRuleArgsCookies @pattern @id @tags @tfn_action
</Macro>

# Block basename
<Macro SecRuleBasename @pattern $id $tfn_action>
 Use SecRuleDeny TX:BASENAME  @pattern  "~{status404},t:none,id:$id,msg:'Blocked path basename',$tfn_action,tag:URL"
</Macro>

# Block (bare) URL
<Macro SecRuleUrlPhase_ $coll $pattern $id $tfn_action $phase>
 <IfDefine !noSecurityRules>
  Use SecRule ENV:PathToIgnore @unconditionalMatch "phase:$phase,id:$id,tag:AccessControl,tag:security,t:none,~{skipAfter}:AfterUrlPhase"
   Use SecRuleDeny "$coll" "$pattern"              "phase:$phase,id:$id,tag:AccessControl,t:none,~{status404},msg:'Blocked path',$tfn_action"
   # Next rule is never executed with ModSecurity < 20240220
  #Use SecRuleDeny "$coll" "$pattern"              "phase:$phase,id:$id,tag:AccessControl,t:none,~{status404},msg:'Blocked path',$tfn_action,multiMatch"
  Use SecMarker AfterUrlPhase,tag:AccessControl,tag:security
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$coll $pattern $id $tfn_action $phase"
 </IfDefine>
</Macro>

# Block (bare) URL
<Macro SecRuleUrlPhase       @pattern @id @tfn_action @phase>
 Use SecRuleUrlPhase_ TX:url @pattern @id @tfn_action @phase
</Macro>
<Macro SecRuleUrl @pattern    @id @tfn_action>
 Use SecRuleUrlPhase @pattern @id @tfn_action 2
</Macro>
<Macro SecRuleUrlPhase1 @pattern @id @tfn_action>
 Use NotInsideLocation
 Use SecRuleUrlPhase    @pattern @id @tfn_action 1
</Macro>
<Macro SecRuleFile @pattern @id @tfn_action>
 Use SecRuleUrl    @pattern @id @tfn_action
 Use Warning "SecRuleFile is obsolete, use SecRuleUrl"
</Macro>
<Macro SecRuleFilePhase1 @pattern @id @tfn_action>
 Use SecRuleUrlPhase1    @pattern @id @tfn_action
 Use Warning "SecRuleFilePhase1 is obsolete, use SecRuleUrlPhase1"
</Macro>
<Macro SecBlockCurrentPath>
 Use SecAction  "phase:2,~{increaseBlockCounter},~{status404},msg:'Blocked path',tag:PATH"
</Macro>
<Macro SecBlockPath   @pattern>
 Use SecRuleUrlPhase1 @pattern 2000006,tag:noreport2 "msg:'Blocked path'"
</Macro>

<Macro SecRestrictArgSyntax $arg $syntax $length>
 # Too long argument (more than X chars)
 Use SecRuleGT "ARGS:$arg" $length 2000014 "msg:'ARG too long'"
 # Allow only restricted syntax
 Use SecRuleArgRegex "$arg" "!^(?:$syntax|)$"  "t:none,msg:'Invalid ARG content'"
</Macro>

# Enforce syntax of an arg
<Macro SecArgSyntax $arg $pattern>
 Use SecRuleDeny ARGS:$arg  "!(?:$pattern)$"  "t:~{encodedParam}"
</Macro>

<Macro SecRuleHeader $header @pattern $tfn_action>
 Use SecRuleDeny "REQUEST_HEADERS:'$header'" @pattern "~{status}:400,msg:'Invalid header content',$tfn_action"
</Macro>

# Block user agent (in phase 2, to be able to disable some robots)
<Macro SecRuleUseragent @pattern $id $tfn_action>
 Use SecRuleHeader User-Agent @pattern "t:none,~{status404},tag:bot,msg:'Invalid user-agent',id:$id,$tfn_action"
</Macro>
<Macro HeaderDetect_ $header @pattern $tfn_action>
 Use NotInsideLocation
 Use SecRule REQUEST_HEADERS:$header @pattern "phase:1,t:none,~{nosecaction},$tfn_action"
</Macro>
<Macro UseragentDetect_       @pattern @tfn_action>
 Use HeaderDetect_ User-Agent @pattern @tfn_action
</Macro>
<Macro UseragentDetect @pattern            $var>
 Use UseragentDetect_  @pattern "setvar:TX.$var"
</Macro>

# Enforce header (only 1 instance allowed - normally useless as Apache concatenate them with a space & comma => bad syntax)
<Macro SecEnforceHeader $header $id>
 Use SecRuleDeny &REQUEST_HEADERS:$header  "!@eq 1"  "t:none,~{status}:400,id:$id,msg:'Header missing <$header>'"
 Use SecRuleDeny  REQUEST_HEADERS:$header  "^$"      "t:none,~{status}:400,id:$id,msg:'Header empty <$header>'"
</Macro>

# Block body
<Macro SecRuleResponseWarningExt $pattern $id_tags $tfn_action $phase>
 <IfDefine !noSecurityRules>
  Use SecRule TX:noResponseBodyAccess @unconditionalMatch "phase:$phase,tag:security,t:none,~{skipAfter}:EndResponseWarningExt,id:$id_tags,tag:Output"
   Use SecRule RESPONSE_BODY "((?i:$pattern).{0,30})"     "phase:$phase,tag:security,t:none,~{warn},capture,setvar:TX.responseBody=%{MATCHED_VAR},$tfn_action,msg:'Invalid page content: %{TX.1}',id:$id_tags,tag:Output"
  Use SecMarker EndResponseWarningExt,tag:security,tag:Output
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$pattern $id_tags $tfn_action $phase"
 </IfDefine>
</Macro>
<Macro SecRuleResponseWarningOnce $pattern $id $tags $tfn_action>
 <IfDefine !noSecurityRules>
  Use SecRule TX:noResponseBodyAccess @unconditionalMatch "phase:5,tag:security,t:none,~{skipAfter}:EndResponseWarningOnce,id:$id,tag:Output,$tags"
   Use RuleLogOnce RESPONSE_BODY "(?i)($pattern)" t:none "capture,~{warn},setvar:TX.responseBody=%{MATCHED_VAR},$tfn_action" "Invalid page content: %{TX.1}" "$id" "$tags,tag:Output,tag:security"
  Use SecMarker EndResponseWarningOnce,tag:security,tag:Output
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$pattern $id $tags $tfn_action"
 </IfDefine>
</Macro>
<Macro SecRuleResponseWarning  @pattern @id>
 Use SecRuleResponseWarningExt @pattern @id "~{warn}" 5
</Macro>
<Macro SecRuleResponse $pattern $id>
 # actions in $id will be overwritten by ~{warn}... in SecRuleArgs
 Use SecRuleResponseWarningExt "$pattern" "$id" "~{increaseBlockCounter},~{statusResp}:400" 4
</Macro>
<Macro SecRuleResponseArgs $pattern $id>
 Use SecRuleArgs "(?i)($pattern)" "$id,tag:ARGS_Resp" "phase:5,t:none,~{warn},logdata:'Warning: pattern will be blocked in response page <%{TX.1}>'"
 Use SecRuleResponse  "$pattern"  "$id"
</Macro>
<Macro SecRuleBodyWarning   @pattern @id>
 Use Warning "SecRuleBody/SecRuleBodyWarning is obsolete, use SecRuleResponse/SecRuleResponseWarning"
 Use SecRuleResponseWarning @pattern @id
</Macro>
<Macro SecRuleBody    @pattern @id>
 Use SecRuleResponse  @pattern @id
</Macro>

<Macro UTF8Encoding @path>
 Use NotInsideLocation
 Use SecRule TX:url @path  "phase:1,~{nosecaction},id:2000005,t:none,setvar:tx.UTF8_ENCODING_USED"
</Macro>

<Macro MixedEncoding>
 Use SecRuleRemoveByID 2000005,2002912
</Macro>

<Macro SecHeuristicCheck_ @macro @pattern $id $transform $msg $add>
 Use @macro  @pattern  "$id,tag:HEUR,$transform"  "~{warn},~{decreaseBlockCounter},capture,setvar:'tx.heur=%{MATCHED_VAR_NAME}=%{MATCHED_VAR} (%{tx.1})',msg:'$msg (heuristic)',setenv:!errorMsg,setenv:!errorPage"
 # if matched, remove additional checks (with further encoding)
 # $transform may contain tags => always present (overwritten)
 Use SecRule &TX:heur "@eq 1" "phase:2,$transform,t:none,id:$id,tag:security,tag:HEUR,setvar:tx.heuristic=+$add,setvar:!tx.heur,setvar:tx.heur$id,~{skipAfter}:EndHeurCheck"
</Macro>

# Heuristic check (generic)
<Macro SecRuleHeuristic_ @macro  @pattern   $id  @add $transform @msg>
 # Always "increment" the transformation level
 # $transform may contain tags => always present (overwritten)
 #Use SecHeuristicCheck_ @macro  @pattern  "$id"  "t:$transform,t:none"             @msg @add
 Use SecHeuristicCheck_  @macro  @pattern  "$id"  "t:$transform,t:none,t:~{ascii}"  @msg @add
 Use SecHeuristicCheck_  @macro  @pattern  "$id"  "t:$transform"                    @msg @add
 Use SecMarker EndHeurCheck,tag:security,tag:HEUR
</Macro>

# Heuristic check for URL
<Macro SecRuleHeuristicUrl        @pattern @id @add @transfom @msg>
 Use SecRuleHeuristic_ SecRuleUrl @pattern @id @add @transfom @msg
</Macro>

# Heuristic check for Args
<Macro SecRuleHeuristicArgs        @pattern @id @add @transfom @msg>
 Use SecRuleHeuristic_ SecRuleArgs @pattern @id @add @transfom @msg
</Macro>

# Heuristic check for Args & cookies
<Macro SecRuleHeuristicArgsCookies        @pattern @id @add @transfom @msg>
 Use SecRuleHeuristic_ SecRuleArgsCookies @pattern @id @add @transfom @msg
</Macro>

# Heuristic check for Args, cookies & headers
<Macro SecRuleHeuristicArgsCookiesHeaders @pattern @id @add @transfom @msg>
 Use SecRuleHeuristic_ SecRuleArgsCookies @pattern @id @add @transfom @msg
 Use SecRuleHeuristic_ SecRuleHeaders     @pattern @id @add @transfom @msg
</Macro>

# SQL injection heuristic check
<Macro SecRuleSQLHeuristic              @pattern @id @add>
 Use SecRuleHeuristicArgsCookiesHeaders @pattern @id @add  "~{sqlNormalize},tag:SQLHeur"  "Possible SQL Injection Attack"
</Macro>
<Macro SecRuleSQLHeuristicArgs          @pattern @id @add>
 Use SecRuleHeuristicArgs               @pattern @id @add  "~{sqlNormalize},tag:SQLHeur"  "Possible SQL Injection Attack"
</Macro>

# XSS injection heuristic check
<Macro SecRuleXSSHeuristic              @pattern @id @add>
 #Use SecRuleHeuristicArgsCookies  @pattern @id @add  "~{jsDecode},tag:XSS,tag:XSSHEUR"  "Possible XSS Injection Attack"
 Use SecRuleHeuristicArgsCookiesHeaders @pattern @id @add  "~{jsDecode},tag:XSS,tag:XSSHEUR,~{htmlMsg}"  "Possible XSS Injection Attack"
</Macro>

<Macro DetectBackendInBody @pattern>
 Use SecRule TX:noResponseBodyAccess @unconditionalMatch "phase:4,t:none,~{skipAfter}:AfterBackendInBody"
  Use SecRule RESPONSE_BODY @pattern                     "phase:4,t:none,~{nosecaction},capture,setvar:TX.backend=%{TX.1}"
 Use SecMarker AfterBackendInBody
</Macro>

# Several arguments with same name (also blocks "SELECT multiple")
<Macro AllowMultipleParams>
 Use SecRuleRemoveByID 2000020
</Macro>
<Macro BlockMultipleParams $max>
 Use AllowMultipleParams
 Use SecRule ENV:req_json|ENV:req_xml @unconditionalMatch "phase:2,id:2000020,t:none,tag:Parano,tag:security,~{skipAfter}:AfterMultipleParams"
  Use SecRule ARGS_NAMES @unconditionalMatch              "phase:2,id:2000020,t:none,tag:Parano,tag:security,~{nosecaction},setvar:'TX.%{MATCHED_VAR_NAME}=+1'"
  Use SecRuleDeny TX:/^ARGS_NAMES:.*/ "@gt $max"          "phase:2,id:2000020,t:none,tag:Parano,msg:'Multiple Parameters with same name'"
 Use SecMarker AfterMultipleParams,tag:Parano,tag:security
</Macro>

# Disable a rule in phase 1 (in disable.conf)
<Macro DisableRuleId $id @host @url>
 Use NotInsideLocation
 Use SecRuleRemoveById $id
 Use SecRule REQUEST_HEADERS:Host @host "phase:1,~{nosecaction},chain"
  Use SecRule TX:url @url          "ctl:ruleRemoveById=$id"
</Macro>

<Macro NoSecurityRules>
 Use AcceptAllCookies
 Use SecRuleRemoveByFullTag security
 Use AllowSearchEngines
 Use SecRequestBodyNoLimit
 Use SecStreamInBodyInspection  Off
 Use SecResponseBodyAccess      Off
 Use SecStreamOutBodyInspection Off
</Macro>

<Macro SkipFrameworkPhase_ $phase $f>
 Use SecRule TX:Framework$f$phase @unconditionalMatch "phase:$phase,t:none,~{skipAfter}:AfterFramework$f"
 Use SecAction "phase:$phase,t:none,~{nosecaction},setvar:TX.Framework$f$phase"
</Macro>
<Macro SkipFramework_ $f>
 Use SkipFrameworkPhase_ 1 $f
 Use SkipFrameworkPhase_ 2 $f
 Use SkipFrameworkPhase_ 3 $f
 Use SkipFrameworkPhase_ 4 $f
 Use SkipFrameworkPhase_ 5 $f
</Macro>
