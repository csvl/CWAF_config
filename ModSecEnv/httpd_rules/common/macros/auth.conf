# :: Macros: Authentication
# Range: 2001750-2001769

<Macro CustomAuthHeader $pattern>
 Use SecRuleRemoveByID 2001751
 Use SecRule REQUEST_HEADERS:Authorization "^\s*+undefined\s*+$" "phase:2,t:none,tag:Auth,tag:EXPLOIT,id:2001751,tag:security,~{skipAfter}:AfterCustomAuthHeader,setenv:unsetAuthHeader"
 Use SecRule TX:AuthHeader  "@unconditionalMatch"            "phase:2,t:none,tag:Auth,tag:EXPLOIT,id:2001751,tag:security,~{skipAfter}:AfterCustomAuthHeader"
  Use SecRule REQUEST_HEADERS:Authorization  "!$pattern"     "phase:2,t:none,tag:Auth,tag:EXPLOIT,id:2001751,~{status}:403,~{increaseAuthCounter},msg:'Bad Authorization format'"
  Use SecRule REQUEST_HEADERS:Authorization   "$pattern"     "phase:2,t:none,tag:Auth,tag:EXPLOIT,id:2001751,tag:security,~{nosecaction},setvar:TX.AuthHeader"
 Use SecMarker AfterCustomAuthHeader,tag:security
</Macro>

# Set userid into session
<Macro RegisterUsername__ @target @pattern $phase>
 Use SecRule @target @pattern  "phase:$phase,id:25,~{nosecaction},t:none,setuid:%{MATCHED_VAR},setvar:SESSION.user=%{MATCHED_VAR},setenv:WAF_USER=%{MATCHED_VAR}"
</Macro>
<Macro RegisterUsername_ @target>
 Use RegisterUsername__ @target "." 1
 Use RegisterUsername__ @target "." 2
</Macro>
<Macro RegisterUsername $name>
 Use RegisterUsername_ "REQUEST_HEADERS:'$name'"
 Use RegisterUsername_ "REQUEST_COOKIES:'$name'"
 Use RegisterUsername__ "RESPONSE_HEADERS:Set-Cookie" "^(?i)$name=([^;]+)" 3
 Use RegisterUsername_ "ARGS:'$name'"
</Macro>

<Macro SecRestrictUsernameExt $arg $syntax>
 <IfDefine !noSecurityRules>
  # Allow only restricted syntax userid
  Use SecRuleArg "$arg" "!^(?:(?:$syntax) *|)$"    "phase:2,~{status}:401,t:none,tag:Auth,~{badUseridMsg},id:25"
  # Too long username (more than X chars)
  Use SecRuleArg "$arg" "@gt ~{UserNameLengthMax}" "phase:2,~{status}:401,t:none,tag:Auth,t:length,~{badUseridMsg},msg:'Userid too long'"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$syntax"
 </IfDefine>
 
 # Set userid into session
 Use RegisterUsername "$arg"
</Macro>

<Macro SecRestrictUsername @arg>
 Use SecRestrictUsernameExt @arg "~{UserNameSyntax}"
</Macro>

<Macro SecRestrictAuth $id $user $uLen $passLen>
 <IfDefine !noSecurityRules>
  Use SecRule ENV:WAF_USER  "@gt $uLen"            "phase:2,tag:security,t:none,t:length,~{skipAfter}:AfterRestrictAuth,~{warn},msg:'Userid too long (Use SecRestrictBasicAuth)',~{increaseAuthCounter},setenv:AUTH_FAILURE=%{REQUEST_HEADERS.Authorization},setuid:invalid,setenv:WAF_USER=,id:$id,tag:Auth,logdata:'userid length=%{MATCHED_VAR}'"
  Use SecRule ENV:WAF_USER  "!^(?:(?:$user) *|)$"  "phase:2,tag:security,t:none,~{skipAfter}:AfterRestrictAuth,~{warn},msg:'Invalid userid syntax',~{increaseAuthCounter},setenv:AUTH_FAILURE=%{REQUEST_HEADERS.Authorization},setuid:invalid,setenv:WAF_USER=,id:$id,tag:Auth,logdata:'userid=%{MATCHED_VAR}'"
   Use SecRule ENV:AUTH_PWD "@gt $passLen"         "phase:2,t:none,t:length,~{warn},msg:'Password too long (Use SecRestrictBasicAuth)',~{increaseAuthCounter},setenv:AUTH_FAILURE=%{REQUEST_HEADERS.Authorization},id:$id,tag:Auth,logdata:'password length=%{MATCHED_VAR}'"
  Use SecMarker AfterRestrictAuth,tag:security
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$id $user $uLen $passLen"
 </IfDefine>
</Macro>
<Macro SecNoRestrictBasicAuth>
 Use SecRuleRemoveByID 2001752
</Macro>
<Macro SecRestrictBasicAuth @user @uLen @passLen>
 Use SecNoRestrictBasicAuth
 <IfDefine !noSecurityRules>
  Use SecRule &REQUEST_HEADERS:Authorization  "@eq 0"  "phase:2,tag:security,t:none,id:2001752,~{nosecaction},ctl:ruleRemoveById=2001752"
  Use SecRestrictAuth "2001752,msg:'Invalid userid syntax (Use SecRestrictBasicAuth), replacing Basic Authentication data'" @user @uLen @passLen
  # "Safe" fake userid: ****:****
  RequestHeader set Authorization             "Basic KioqKjoqKioq"  env=AUTH_FAILURE
  <IfDefine EXTENDEDSTATUS>
   RequestHeader set X-WAF-Invalid-AuthHeader  %{AUTH_FAILURE}e      env=AUTH_FAILURE
  </IfDefine>
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam @user
  Use UnusedParam @uLen
  Use UnusedParam @passLen
 </IfDefine>
</Macro>

<Macro ForceBasicAuthDomain $domain>
 Use SecRule ENV:WAF_USER  "([^\x5c]*)$"  "phase:2,~{nosecaction},t:none,capture,setenv:WAF_USER=%{TX.1},setenv:NEW_BASIC_AUTH=$domain\%{TX.1}:%{ENV.AUTH_PWD}"
 Use SecRule ENV:NEW_BASIC_AUTH  @unconditionalMatch   "phase:2,~{nosecaction},t:none,t:base64Encode,setenv:NEW_BASIC_AUTH=%{MATCHED_VAR}"
 #Use SecAction "phase:2,~{log},msg:'%{ENV.NEW_BASIC_AUTH}'"
 RequestHeader set Authorization  "Basic %{NEW_BASIC_AUTH}e"
</Macro>

<Macro SetBasicAuthBanner $banner>
 Use HeaderUnset WWW-Authenticate
 Header set      WWW-Authenticate "Basic realm=@QUOTE@$banner@QUOTE@"
</Macro>

<Macro ChangeBasicAuthBanner $banner>
 Header edit WWW-Authenticate "( realm=\x22)[^\x22]*" "$1$banner"
</Macro>

# Disable userid syntax check in Basic Authentication
<Macro SecDisableUsernameSyntax @url>
 Use NotInsideLocation
 Use SecRule TX:url @url  "phase:1,tag:security,~{nosecaction},t:none,ctl:ruleRemoveById=2001752,ctl:ruleRemoveById=25"
</Macro>

# Cookie containing base64(user:password), like some RememberMe cookies
<Macro SecNoRestrictCookieAuth>
 Use SecRuleRemoveByID 2001753
</Macro>
<Macro SecInitCookieAuth $cookie $phase>
 Use SecRule REQUEST_COOKIES:$cookie  "^([^:]+):(.*)$"  "phase:$phase,t:none,tag:security,id:2001753,~{nosecaction},t:base64Decode,capture,setuid:%{TX.1},setenv:WAF_USER=%{TX.1},setenv:AUTH_PWD=%{TX.2}"
</Macro>
<Macro SecRestrictCookieAuth $cookie @user @uLen @passLen>
 Use SecNoRestrictCookieAuth
 # Add $cookie Authentication userid to logs
 Use  SecInitCookieAuth $cookie 1
 Use SecRule &REQUEST_COOKIES:$cookie "@eq 0" "phase:2,t:none,tag:security,id:2001753,~{skipAfter}:AfterRestrictCookieAuth"
  Use SecRule USERID .                        "phase:2,t:none,tag:security,id:2001753,~{skipAfter}:AfterInitCookieAuth"
   Use SecInitCookieAuth $cookie 2
  Use SecMarker AfterInitCookieAuth,tag:security
  Use SecRestrictAuth "2001753,msg:'Invalid userid syntax (Use SecRestrictCookieAuth)'" @user @uLen @passLen
 Use SecMarker AfterRestrictCookieAuth,tag:security
 Use AcceptCookie $cookie
 # Sanitise $cookie (but first characters)
 Use SanitizeCookie "$cookie"
</Macro>

# Treat variable as password (allow regex)
<Macro SecPasswordExt $arg $len>
 Use SanitizeArg     "$arg"
 <IfDefine !noSecurityRules>
  # Too long password (more than X chars)
  Use SecRuleArgRegex "$arg" "@gt $len" "phase:2,~{status}:401,t:none,t:length,msg:'Password too long (%{MATCHED_VAR})',~{increaseAuthCounter},tag:Auth"
  
  # Not working because in phase 2 after the rules
  #<IfDefine !noOptimExceptions>
  # Use IgnoreTargets ARGS "$arg" SecRuleArgs
  #</IfDefine>
  Use SecDisableRuleArgByFullTag "$arg" "HEUR|SHORT|SecRuleArgs"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$len"
 </IfDefine>
</Macro>

<Macro SecPassword  @arg>
 Use SecPasswordExt @arg ~{PasswordLengthMax}
</Macro>

# Block bad authentication
<Macro SecBadAuth @pattern>
 <IfDefine !noSecurityRules>
  Use SecRule &ENV:allowed4 "@eq 0"                        "phase:5,t:none,tag:Auth,tag:security,~{skipAfter}:AfterBadAuth"
  Use SecRule TX:noResponseBodyAccess @unconditionalMatch "phase:5,t:none,tag:Auth,tag:security,~{skipAfter}:AfterBadAuth"
   Use SecRuleDeny RESPONSE_BODY @pattern                 "phase:5,t:none,tag:Auth,~{warn},~{increaseAuthCounter},msg:'Bad authentication (%{IP.BadAuth})'"
  Use SecMarker AfterBadAuth,tag:Auth,tag:security
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam @pattern
 </IfDefine>
</Macro>
<Macro SecBadAuthArg $arg @pattern>
 <IfDefine !noSecurityRules>
  Use SecRule ARGS:$arg @pattern "phase:5,~{log},t:none,tag:Auth,~{increaseAuthCounter},msg:'Bad authentication (%{IP.BadAuth})'"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam @pattern
 </IfDefine>
</Macro>
<Macro SecBadAuthRedirect @url>
 <IfDefine !noSecurityRules>
  Use SecRule RESPONSE_HEADERS:Location  @url  "phase:5,~{log},tag:Auth,t:none,~{increaseAuthCounter},msg:'Bad authentication (%{IP.BadAuth})'"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam @url
 </IfDefine>
</Macro>
<Macro SecAcegiAuth @url>
 Use SecBadAuthRedirect @url
 Use AcceptCookie ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE
</Macro>
 
<Macro LoginPage $url>
 <LocationMatch ^(?i:$url)/?$>
  Use SecAction   "phase:2,tag:security,~{nosecaction},setvar:TX.LoginPage=1"
 </LocationMatch>
</Macro>

# Count as an authentication attempt
<Macro SecBadAuthPage $url>
 Use NotInsideLocation
 Use SecRule TX:url "!^$url(?:[?]|$)"                                    "phase:1,tag:Auth,t:none,tag:security,~{skipAfter}:AfterBadAuthPage"
  Use SecRule REQUEST_HEADERS:Referer "https?://[^/]*(?i:$url)(?:[?]|$)" "phase:1,tag:Auth,t:none,~{warn},~{increaseAuthCounter},msg:'Bad authentication'"
 Use SecMarker AfterBadAuthPage,tag:security
</Macro>

# ::=============== X.509 client authentication ====================================

### RewriteRule are never called inside location because ProxyPass takes precedence

# -------------------------------------------------------------------------------------

# :: User authentication based on certificate Common Name
# :: Warning: these have to be inside a location protected by "Use SecDisallowUsers"
# :: ----------------------------------------------------
 
# Allow one specific certificate, based on a SSL field
<Macro SecAllowX509AuthExt_ $field1 @cond1 $field2 @cond2>
 Use SetenvSec X509_Access_control 1
 <IfDefine !NOSSL>
  RewriteOptions InheritBefore
  RewriteCond %{ENV:X509_USER_ALLOWED}   "^$"
   RewriteCond %{SSL:$field1}   @cond1
    RewriteCond %{SSL:$field2}   @cond2
     RewriteRule ^ - [E=X509_USER_ALLOWED:%{SSL:$field1},E=REMOTE_USER:%{SSL:$field1},E=!X509_USER_NOT_ALLOWED,NE,DPI]
 </IfDefine>
 # Check certificate access
 Use SecRuleRemoveById 2001754
 Use SecRule ENV:X509_Access_control "@unconditionalMatch" "phase:2,id:2001754,~{status}:403,~{increaseAuthCounter},tag:Auth,msg:'Forgot to include SecDisallowUsers directive'"
</Macro>
<Macro SecAllowX509AuthExt @field1 @cond1 @field2 @cond2>
 Use SecAllowX509AuthExt_  @field1 @cond1 @field2 @cond2
 <IfDefine !NOSSL>
  SSLUserName @field1
 </IfDefine>
</Macro>
<Macro SecAllowX509Auth @field @cond>
 Use SecAllowX509AuthExt @field @cond @field @cond
</Macro>
<Macro SecAllowX509AuthArray $(field) @cond>
 Use SecAllowX509AuthExt_ "$(field)_0" @cond "$(field)_0" @cond
 Use SecAllowX509AuthExt_ "$(field)_1" @cond "$(field)_1" @cond
 Use SecAllowX509AuthExt_ "$(field)_2" @cond "$(field)_2" @cond
 Use SecAllowX509AuthExt_ "$(field)_3" @cond "$(field)_3" @cond
 Use SecAllowX509AuthExt_ "$(field)_4" @cond "$(field)_4" @cond
 Use SecAllowX509AuthExt_ "$(field)_5" @cond "$(field)_5" @cond
 Use SecAllowX509AuthExt_ "$(field)_6" @cond "$(field)_6" @cond
 Use SecAllowX509AuthExt_ "$(field)_7" @cond "$(field)_7" @cond
 Use SecAllowX509AuthExt_ "$(field)_8" @cond "$(field)_8" @cond
 Use SecAllowX509AuthExt_ "$(field)_9" @cond "$(field)_9" @cond
</Macro>

# Allow one specific user, based on his certificate Common Name
<Macro SecAllowCertUser $name>
 Use SecAllowX509Auth SSL_CLIENT_S_DN_CN "=$name"
</Macro>

# Allow one specific user, based on his certificate national number
<Macro SecAllowCertUserNN $nn>
# Use SecAllowX509Auth SSL_CLIENT_S_DN_serialNumber "=$nn"
 Use SecAllowX509Auth SSL_CLIENT_S_DN "$nn"
</Macro>

# Allow all users issued by a CA
<Macro SecAllowCertIssuer $name>
 Use SecAllowX509Auth SSL_CLIENT_I_DN_CN "=$name"
</Macro>

# Allow all certificates
<Macro SecAllowInvalidCert>
 <IfModule ssl_module>
  SSLVerifyClient none
  Use SetEnvRew X509_USER_ALLOWED -
  Use UnsetEnvSec X509_Access_control
  Use UnsetEnvRew X509_USER_NOT_ALLOWED
 </IfModule>
</Macro>

# Block all users but authorised ones
<Macro SecDisallowUsers>
 #Use NotInsideLocation
 <IfModule ssl_module>
  SSLVerifyClient optional
  SSLOptions +StdEnvVars +ExportCertData
  RewriteOptions InheritBefore
  RewriteCond %{SSL:SSL_CLIENT_VERIFY}   "!=SUCCESS"
   RewriteRule ^  -  [E=X509_USER_NOT_ALLOWED:%{SSL:SSL_CLIENT_S_DN}/%{SSL:SSL_CLIENT_V_END}/%{SSL:SSL_CLIENT_VERIFY},L,F,NE,DPI]
  RewriteCond %{REMOTE_ADDR} "^~{IpLocalHostRegex}$"
   RewriteRule ^  -  [E=X509_USER_ALLOWED:-]
  RewriteCond %{ENV:X509_USER_ALLOWED}   "^$"
   RewriteRule ^  -  [E=X509_USER_NOT_ALLOWED:%{SSL:SSL_CLIENT_S_DN}/%{SSL:SSL_CLIENT_V_END}/Unauthorised,L,F,NE,DPI]
  Use RegisterUsername_ ENV:X509_USER_ALLOWED
  Use SecRuleRemoveById 2001754
  Use UnsetEnvSec X509_Access_control
 </IfModule>
 <IfModule !ssl_module>
  Warning TLS disabled but X.509 authentication requested
 </IfModule>
</Macro>

<Macro IDP $frontPath $server>
 Use TrustHost $server
 <Location $frontPath/>
  Use CSPAddDirective manifest-src "https://$server"
  Use CSPAllow3rdPartyScript       "https://$server"
  Use CSPAllow3rdPartyStyle        "https://$server"
  Use CSPAllowFrameFrom3rdParty    "https://$server"
 </Location>
</Macro>
<Macro IDP_Domain @frontPath $domain>
 Use IDP @frontPath "(?:~{HostChars}+[.])?$domain"
</Macro>

<Macro IDP_Auth0 @frontPath>
 Use IDP_Domain  @frontPath "(?:eu|us)[.]auth0[.]com"
</Macro>

<Macro IDP_Okta @frontPath>
 Use IDP_Domain @frontPath "okta(-emea|preview)?[.]com"
</Macro>

<Macro AppendCertChain_ $n>
 RequestHeader append Client-Cert-Chain "%{SSL_CLIENT_CERT_CHAIN_$n}s" "expr= -n %{SSL:SSL_CLIENT_CERT_CHAIN_$n}"
</Macro>

<Macro RFC_client-cert-field>
 # RFC xxx - https://datatracker.ietf.org/doc/draft-ietf-httpbis-client-cert-field/
 # replace ---(BEGIN|END) CERTIFICATE--- with : and remove line breaks
 Use SetSSLHeaderEnv Client-Cert       SSL_CLIENT_CERT
 Use AppendCertChain_ 0
 Use AppendCertChain_ 1
 Use AppendCertChain_ 2
 Use AppendCertChain_ 3
 Use AppendCertChain_ 4
 Use AppendCertChain_ 5
 UndefMacro AppendCertChain_
 RequestHeader edit* Client-Cert       "\s*+-----(?:BEGIN|END) CERTIFICATE-----\s*+" ":"
 RequestHeader edit* Client-Cert       "\s+" ""
 RequestHeader edit* Client-Cert-Chain "\s*+-----(?:BEGIN|END) CERTIFICATE-----\s*+" ":"
 RequestHeader edit* Client-Cert-Chain "\s+" ""
 # Default (8192) is too low when sending certificate chains to Tomcat AJP
 # Also need in Tomcat server.xml, on the ajp connector: packetSize="65536"
 #LimitRequestFieldSize 65536
 #ProxyIOBufferSize     65536
</Macro> 
