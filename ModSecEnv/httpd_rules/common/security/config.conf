# ModSecurity general config file
# ---------------------------------------------------------------
# Range: 1000100-1000139

# Turn ModSecurity "On", monitoring only "DetectionOnly", or "Off"
SecRuleEngine  ~{SecRuleEngine}
SecRuleInheritance On
SecXmlExternalEntity Off

SecComponentSignature "Approach WAF AI (~{WAF_CONF_COMMON})"
SecSensorId  "~{ServerId} (~{WAF_CONF_COMMON})"

# This seems to be still buggy sometimes (big number of arguments)
SecCacheTransformations Off
<IfDefine SecCacheTransformations>
 SecCacheTransformations on "incremental=on,maxitems=0,minlen=0,maxlen=20000"
</IfDefine>

# PCRE limits
SecPcreMatchLimit          1000000
SecPcreMatchLimitRecursion     100 

# Inspecting request body
SecRequestBodyAccess      On
SecStreamInBodyInspection Off
# Inspecting response body
SecResponseBodyAccess     ~{SecResponseBodyAccess}
# Only for error messages in JSON/XML
# Why is STREAM_OUTPUT_BODY not populated?
#SecStreamOutBodyInspection On
<IfDefine noSecurityRules>
 SecRequestBodyAccess       Off
 SecStreamInBodyInspection  Off
 SecResponseBodyAccess      Off
 SecStreamOutBodyInspection Off
</IfDefine>

# Requests max. size
Use SecRequestBodyLimit ~{ReqBodySizeMax}

# Not really used but must be initialised
SecHashKey rand KeyOnly

# Default collections timeout to 10 min.
SecCollectionTimeout 600

<IfDirective SecRequestBodyJsonDepthLimit>
 SecRequestBodyJsonDepthLimit 512
</IfDirective>

# Unicode character mapping: 20127 (US-ASCII) to protect non-Unicode apps
# 99999 = US-ASCII with extended (proprietary) mapping
<IfDefine !DUMP_CONFIG>
 SecUnicodeMapFile ../unicode.mapping 99999
</IfDefine>

# Allow knowing which phases begins (in case of blocking)
<IfDefine Debug----------->
 <Macro Phase $p>
  SecAction "phase:$p,~{nosecaction},setvar:TX.phase_$p"
 </Macro>
 Use Phase 1
 Use Phase 2
 Use Phase 3
 Use Phase 4
 Use Phase 5
</IfDefine>

# Check browser
BrowserMatch "\bAndroid [0-9].* Version/([0-9]+[.][0-9]+)" browser_android=$1   nosamesite
BrowserMatch "\bChrome/([0-9]+[.][0-9]+)"                  browser_chrome=$1
BrowserMatch "\bEdge/([0-9]+[.][0-9]+)"                    browser_edge=$1      nosamesite
BrowserMatch "\bEdg(?:A|iOS)?/([0-9]+[.][0-9]+)"           browser_edge2=$1
BrowserMatch "\bFirefox/([0-9]+[.][0-9]+)"                 browser_firefox=$1
BrowserMatch "\b(?:MSIE|Trident)/([0-9]+[.][0-9]+)"        browser_ie=$1        nosamesite
BrowserMatch "\bOPR/([0-9]+[.][0-9]+)"                     browser_opera=$1
BrowserMatch "\bSafari/([0-9]+[.][0-9]+)"                  browser_safari=$1
BrowserMatch "\bUCBrowser/([0-9]+[.][0-9]+)"               browser_uc=$1        nosamesite
BrowserMatch "\bAppleWebKit/([0-9]+[.][0-9]+)"             browser_webkit=$1
# Chrome contains "Safari", Edge contains "Chrome", etc.
SetenvIf browser_chrome . !browser_safari !browser_android
SetenvIf browser_edge   . !browser_chrome
SetenvIf browser_edge2  . !browser_chrome
SetenvIf browser_opera  . !browser_chrome

# Check OS
BrowserMatch "Windows NT ([0-9]+[.][0-9]+)"                      os_win=$1
BrowserMatch "; Android ([0-9]+[.][0-9]+)"                       os_android=$1
# Apache replaces underscore by space in headers => accept both
BrowserMatch "Mac OS X ([0-9]+)[_ ]([0-9]+)"                     os_mac=$1.$2
BrowserMatch "[(]iP[a-z]+; CPU iP[a-z]+ OS ([0-9]+)[_ ]([0-9]+)" os_ios=$1.$2

# samesite support
SetEnvIfExpr "reqenv('browser_chrome') != '' && reqenv('browser_chrome') < 51" nosamesite
SetEnvIfExpr "reqenv('browser_opera')  != '' && reqenv('browser_opera')  < 39" nosamesite
SetEnvIfExpr "reqenv('browser_safari') != '' && ((reqenv('os_mac') != '' && reqenv('os_mac') < 10.15) || (reqenv('os_ios') != '' && reqenv('os_ios') < 13))" nosamesite

# Initialisation ----------------------------------------------------
SecRule REMOTE_ADDR "@ipMatch ~{IpLocalhost}" "phase:1,t:none,~{nosecaction},setenv:loopback"

# Init URL (@patternfly used by a ReactJS component)
SecRule REQUEST_URI_RAW "^([^?#]*)(?:/@patternfly)?([^?#]*)" "phase:1,~{nosecaction},t:none,capture,setvar:TX.url=%{TX.1}%{TX.2},setvar:TX.PATHNAME=/"
SecRule TX:url          @unconditionalMatch                  "phase:1,~{nosecaction},t:~{url},setvar:TX.url=%{MATCHED_VAR}"
Use SetBasename_

<IfDefine Debug>
 SecRule REQUEST_HEADERS @unconditionalMatch "phase:1,~{log},msg:'Headers debugging',logdata:'%{MATCHED_VAR_NAME}=%{MATCHED_VAR}'"
 <IfDefine !DebugLocalhost>
  # Don't debug internal requests
  SecRule REMOTE_ADDR      "@ipMatch ~{IpLocalhost}"     "phase:1,t:none,~{nosecaction},ctl:debugLogLevel=0"
  #SecRule TX:url "~{PathToIgnore}|^/[a-z]+IP=" "phase:1,t:none,~{nosecaction},ctl:debugLogLevel=0"
  # Control debugging with headers
  Use XWafDebugPhase_ 1
 </IfDefine>
</IfDefine>
<IfDefine EXTENDEDSTATUS>
 # Control debugging with headers
 Use XWafDebugPhase_ 1
</IfDefine>

# Store timestamp (for unique id)
#Does not work!?! SecAction "phase:1,~{nosecaction},setenv:timestamp=%{TIME_YEAR}%{TIME_MON}%{TIME_DAY}%{TIME_HOUR}%{TIME_MIN}%{TIME_SEC}"

# To log some things globally
DefineStr OptimGlobalRegexInit ",msg:''"
<IfDefine OptimGlobalRegex>
 DefineStr OptimGlobalRegexInit ",setvar:'TX.GlRegexH=$^'"
</IfDefine>
SecAction "phase:1,~{nosecaction},initcol:GLOBAL=global,setvar:GLOBAL.TIMEOUT=360000,setvar:TX.TrustedHosts=$^,setvar:tx.allowedUrlProtos=$^~{OptimGlobalRegexInit}"

# Determines client IP address in case of a trusted (reverse) proxy
SecAction "phase:1,~{nosecaction},setvar:TX.remote_addr=%{REMOTE_ADDR},setenv:CLIENT-IP=%{REMOTE_ADDR},setenv:CLIENT-PORT=%{REMOTE_PORT},setenv:VHOST-PORT=%{SERVER_PORT},setenv:BlockedMax=~{BlockedMax},setenv:BadAuthMax=~{BadAuthMax},setvar:TX.XmlSanArgs=@@@@,setvar:TX.hash_app=server"
SecRule  ENV:loopback @unconditionalMatch "phase:1,t:none,~{skipAfter}:AfterRemoteAddr,setvar:tx.notProxyFE,setenv:notProxyFE,setenv:no-log"
 SecRule REMOTE_ADDR "!~{RP_IP_Check}"    "phase:1,t:none,~{skipAfter}:AfterRemoteAddr,setvar:tx.notProxyFE,setenv:notProxyFE"
 # X-Forwarded-For: client, proxy1, proxy2
 SecRule REQUEST_HEADERS:~{IPAddressHeader}  "(~{syntax_ip}) *$"          "phase:1,capture,setvar:TX.remote_addr=%{TX.1},setenv:CLIENT-IP=%{TX.1},~{skipAfter}:AfterRemoteAddr"
 # Forwarded: for=client; proto=http; by=proxy1; for=proxy1; by=proxy2
 SecRule REQUEST_HEADERS:~{IPAddressHeader}  ".*\bfor=(~{syntax_ip})"     "phase:1,capture,setvar:TX.remote_addr=%{TX.1},setenv:CLIENT-IP=%{TX.1},~{skipAfter}:AfterRemoteAddr,~{caseSensitive}"
 SecAction "phase:1,~{nosecaction},setenv:remote_addr=%{TX.remote_addr}"
 <IfDefine EXTENDEDSTATUS>
  Use SecAction "phase:1,~{nosecaction},setenv:PrevMsg=%{GLOBAL.LastMsg},setvar:!GLOBAL.LastMsg"
  Use SetHeaderEnv X-WAF-PreviousMsg   PrevMsg       
 </IfDefine>
SecMarker AfterRemoteAddr

# mod_remoteip correctly populates the internal structure used by mod_maxminddb
<IfModule !remoteip_module>
 <IfModule maxminddb_module>
  SecAction "phase:1,~{nosecaction},setenv:MMDB_ADDR=%{TX.remote_addr}"
 </IfModule>
</IfModule>

DefineStr  manageReqAction "~{requestWarn},~{stopSecurity},severity:WARNING,tag:Management,ctl:auditLogParts=-CEGI,setenv:AllowDefaultHost"
<IfDefine DebugLocalhost>
 DefineStr manageReqAction "~{requestWarn},severity:WARNING,tag:Management"
</IfDefine>
<IfDefine NoIPMgtLog>
 DefineStr manageReqAction "~{nosecaction},~{stopSecurity},tag:Management"
</IfDefine>

<IfDefine !noSecurityRules>
 # Special URL to manipulate an IP address counter
 # Must be used before initialising the IP collection
 <Macro ManageIPCounter $url $msg $landPage $action>
  SecRule REQUEST_LINE "^GET /(?i:$url)=([0-9.:]+) HTTP"  "phase:1,t:none,capture,setenv:ManagedIP=%{TX.1},initcol:IP=%{TX.1},$action,setenv:EnforceLocalURL=$landPage?ip=%{TX.1},setenv:ManagedIPBlocked=%{IP.blocked},setenv:ManagedIPBadAuth=%{IP.BadAuth},setenv:ManagedIPDoS=%{IP.dos},setenv:ManagedIPCreate=%{IP.LAST_UPDATE_TIME},setenv:ManagedIPBlockedTimeout=%{IP.TIMEOUT},~{manageReqAction},msg:'$msg IP address <%{TX.1}>'"
 </Macro>
 # Same for Resource collection
 DefineStr ManageResCounterSetenv "setenv:ManagedResCounter=%{RESOURCE.counter},setenv:ManagedResCreate=%{RESOURCE.LAST_UPDATE_TIME},setenv:ManagedResTimeout=%{RESOURCE.TIMEOUT},setvar:RESOURCE.counter=+0,setenv:max_nb_ARGS=%{RESOURCE.max_nb_ARGS},setenv:max_nb_FILES=%{RESOURCE.max_nb_FILES},setenv:max_nb_REQUEST_COOKIES=%{RESOURCE.max_nb_REQUEST_COOKIES},setenv:max_len_ARGS=%{RESOURCE.max_len_ARGS},setenv:max_FILES_SIZES=%{RESOURCE.max_FILES_SIZES},setenv:max_len_REQUEST_COOKIES=%{RESOURCE.max_len_REQUEST_COOKIES},setenv:max_len_ARGS_NAMES=%{RESOURCE.max_len_ARGS_NAMES},setenv:max_len_FILES_NAMES=%{RESOURCE.max_len_FILES_NAMES},setenv:max_len_REQUEST_COOKIES_NAMES=%{RESOURCE.max_len_REQUEST_COOKIES_NAMES},setenv:max_FILES_COMBINED_SIZE=%{RESOURCE.max_FILES_COMBINED_SIZE},setenv:max_FULL_REQUEST_LENGTH=%{RESOURCE.max_FULL_REQUEST_LENGTH},setenv:max_REQUEST_BODY_LENGTH=%{RESOURCE.max_REQUEST_BODY_LENGTH},setenv:max_RESPONSE_CONTENT_LENGTH=%{RESOURCE.max_RESPONSE_CONTENT_LENGTH},setenv:max_ARGS_COMBINED_SIZE=%{RESOURCE.max_ARGS_COMBINED_SIZE}"
 <Macro ManageResCounter $url $msg $landPage $action>
  # Resources are always in lowercase
  SecRule REQUEST_LINE  "^GET /(?i:$url)=([^ ]+) HTTP"  "phase:1,t:none,chain,capture,~{manageReqAction},msg:'$msg RESOURCE address <%{TX.1}>'"
   SecRule TX:1  @unconditionalMatch  "t:none,~{hash},setenv:ManagedRes=%{MATCHED_VAR},initcol:RESOURCE=%{MATCHED_VAR},~{ManageResCounterSetenv},$action,setenv:EnforceLocalURL=$landPage?res=%{ENV.ManagedRes}"
  #SecRule REQUEST_LINE   "^GET $landPage?res=([0-9.:]+) HTTP"  "phase:1,t:none,capture,~{responseWarn},allow,msg:'$msg RESOURCE address <%{TX.1}>',setenv:ManagedRes=%{TX.1},initcol:RESOURCE=%{ENV.ManagedRes},$action,ctl:auditLogParts=-CEGI,setenv:ManagedResCounter=%{RESOURCE.counter},setenv:ManagedResCreate=%{RESOURCE.LAST_UPDATE_TIME},setenv:ManagedResTimeout=%{RESOURCE.TIMEOUT},setvar:RESOURCE.counter=+0"
 </Macro>
 # Same for User collection
 <Macro ManageUserCounter $url $msg $landPage $action>
  SecRule REQUEST_LINE "^GET /(?i:$url)=([^ ]+) HTTP"  "phase:1,t:none,capture,setenv:ManagedUser=%{TX.1},initcol:USER=%{TX.1},$action,setenv:EnforceLocalURL=$landPage?user=%{TX.1},setenv:ManagedUserCounter=%{USER.ReqNb},setenv:ManagedUserCreate=%{USER.LAST_UPDATE_TIME},setenv:ManagedUserTimeout=%{USER.TIMEOUT},setvar:USER.ReqNb=+0,setenv:UserReqNb=%{USER.ReqNb},~{manageReqAction},msg:'$msg user <%{TX.1}>'"
 </Macro>
 <Macro EraseGlobalColl $url $landPage>
  SecRule REQUEST_LINE  "^GET /(?i:_restricted/$url) HTTP"  "phase:1,t:none,setvar:GLOBAL.TIMEOUT=0,setvar:!GLOBAL.key,setvar:!GLOBAL.__key,~{manageReqAction},msg:'Erase all Global collection',setenv:EnforceLocalURL=$landPage,setenv:ManagedKey=%{GLOBAL.key}"
 </Macro>
  
 SecRule TX:remote_addr  "!~{IpAdmin}"  "phase:1,t:none,~{skipAfter}:EndOfIPMgt"
  Use ManageIPCounter  "unblockIP"   "Unblocking" "/_restricted/ip_unblock.html"  "setvar:IP.TIMEOUT=0,setvar:!IP.dos,setvar:!IP.blocked,setvar:!IP.BadAuth,setvar:!IP.counter,setvar:!IP.ReqNb,setvar:!IP.VulnScan"
  Use ManageIPCounter  "blockIP"     "Blocking"   "/_restricted/ip_block.html"    "~{increaseBlockCounterMax},setvar:IP.TIMEOUT=~{block_timeout}"
  Use ManageIPCounter  "queryIP"     "Querying"   "/_restricted/ip_query.html"    "ctl:auditEngine=off"
  Use ManageResCounter "unblockRes"  "Unblocking" "/_restricted/res_unblock.html" "setvar:RESOURCE.TIMEOUT=0,setvar:!RESOURCE.counter,setvar:!RESOURCE.invalidheader,setvar:!RESOURCE.noContentType,setvar:!RESOURCE.CSP_Logged,setvar:!RESOURCE.charsetDiscrepancy,setvar:!RESOURCE.reflectedXSS"
  Use ManageResCounter "queryRes"    "Querying"   "/_restricted/res_query.html"   "ctl:auditEngine=off"
  Use EraseGlobalColl  "eraseGlobal"              "/_restricted/global_erase.html"
  Use ManageIPCounter  "unblockUser" "Unblocking" "/_restricted/user_unblock.html"  "setvar:USER.TIMEOUT=0,setvar:!,setvar:!USER.ReqNb"
  Use ManageIPCounter  "blockUser"   "Blocking"   "/_restricted/user_block.html"    "~{increaseBlockCounterMax},setvar:USER.TIMEOUT=~{block_timeout}"
  Use ManageIPCounter  "queryUser"   "Querying"   "/_restricted/user_query.html"    "ctl:auditEngine=off"
  SecRule REQUEST_LINE "^GET /_restricted/counters HTTP"                                      "phase:1,t:none,~{manageReqAction},setenv:EnforceLocalURL=/_restricted/counters.html"
  SecRule REQUEST_LINE "^GET /_restricted/server-status(?:[?](?:auto|refresh=[0-9]+))? HTTP"  "phase:1,t:none,~{manageReqAction}"
  SecRule REQUEST_LINE "^GET /_restricted/balancer-manager HTTP"                              "phase:1,t:none,~{manageReqAction}"
 SecMarker EndOfIPMgt
 
 <IfDefine Publish>
  SecRule TX:remote_addr  "~{IpPublish_}"      "phase:1,t:none,tag:security,~{skip}:1"
   SecRule REQUEST_URI_RAW "~{PublishUrlLog}"  "phase:1,t:none,~{DisableAllRequestsStatus},msg:'URL reserved to Publishers',initcol:IP=%{TX.remote_addr},setenv:AdminDenied"
  # Allow request in case it wasn't blocked above
  SecRule REQUEST_URI_RAW "~{PublishUrlLog}"   "phase:1,t:none,~{stopSecurity}"
 </IfDefine>

 # Explicit error message for Management URL
 SecRule REQUEST_URI_RAW  "(?i)^/_?_restricted/" "phase:1,t:none,t:urlDecode,~{DisableAllRequestsStatus},msg:'URL reserved to administrators',initcol:IP=%{TX.remote_addr},setenv:AdminDenied"
 
 # When in detection mode
 RewriteCond %{ENV:AdminDenied} .
  RewriteRule ^ - [F]
</IfDefine>

# Prepare some hashes to initialise RESOURCE collection
# Recalculate in phase 2 if it was overwritten
Use HashRes 1 app %{WEBAPPID}
Use HashRes 1 url %{WEBAPPID}%{TX.url}
Use HashRes 1 ua  %{REQUEST_HEADERS.User-Agent}%{REQUEST_HEADERS.Accept-Charset}%{REQUEST_HEADERS.Accept-Encoding}%{REQUEST_HEADERS.Accept-Language}%{REQUEST_HEADERS.Via}%{REQUEST_HEADERS.X-Forwarded-For}%{REQUEST_HEADERS.Forwarded}
Use HashRes 1 host-ua-url %{REQUEST_HEADERS.Host}%{TX.hash_ua}%{TX.hash_url}
Use HashRes 2 app %{WEBAPPID}
Use HashRes 2 url %{WEBAPPID}%{TX.url}

# Initiates a collection for tracking hacking and authentication attempts & store current values
SecAction  "phase:1,~{nosecaction},initcol:IP=%{TX.remote_addr},setvar:TX.real_ip=%{TX.remote_addr},setvar:TX.logged=0"
SecAction  "phase:1,~{nosecaction},setvar:TX.oldBlocked=%{IP.blocked},setvar:TX.oldBadAuth=%{IP.BadAuth},setenv:ManagedIPBlocked=%{IP.blocked},setenv:ManagedIPBadAuth=%{IP.BadAuth},setenv:ManagedIPDoS=%{IP.dos}"
SecRule IP:TIMEOUT "!^~{ip_timeout}$" "phase:1,chain,~{nosecaction}"
 SecRule IP:UPDATE_COUNTER "@eq 0" "setvar:IP.TIMEOUT=~{ip_timeout}"

SecRule REMOTE_ADDR "@ipMatch ~{IpInternal_}"  "phase:1,t:none,~{nosecaction},setenv:internalIP"

# Detect monitoring bots
Use MonitoringIP "@ipMatchF ~{ConfPath}/common/security/monitoring_ip.data"

# Used for tracing of requests in internal test pages
<IfDefine EXTENDEDSTATUS>
 Use SecRule REQUEST_URI_RAW "!^/(?:SecError|_?_restricted)/" "phase:1,t:none,~{skipAfter}:ExtendedStatus"
  Use SecRule REQUEST_HEADERS @unconditionalMatch "phase:1,~{nosecaction},setenv:'ReceivedHeaders=%{ENV.ReceivedHeaders}|%{MATCHED_VAR_NAME}=%{MATCHED_VAR}|'"
 Use SecMarker ExtendedStatus
</IfDefine>

# Store Host name in environment
SecRule REQUEST_HEADERS:Host "(?:[^.]+[.])?([^.]+[.][^.]+)$" "phase:1,~{nosecaction},capture,setvar:TX.domain=%{TX.1},setenv:HOST=%{MATCHED_VAR},~{skip}:1"
SecAction                                                    "phase:1,~{nosecaction},setenv:HOST=%{SERVER_NAME}"

# Store request length
SecAction                   "phase:1,~{nosecaction},setvar:TX.req_size=0,setvar:TX.req_size=+%{REQUEST_HEADERS.Content-Length}"
SecRule TX:req_size "@eq 0" "phase:2,~{nosecaction},setvar:TX.req_size=+%{REQUEST_BODY_LENGTH}"
SecRule TX:req_size "@eq 0" "phase:5,~{nosecaction},setvar:TX.req_size=+%{REQUEST_BODY_LENGTH}"

# Store response length
<Macro StoreResponseLengthPhase__ @source $phase>
 SecRule TX:resp_size "@eq 0" "phase:$phase,~{nosecaction},chain"
  SecRule @source "@gt 0"  "setvar:TX.resp_size=%{MATCHED_VAR}"
</Macro>
<Macro StoreResponseLengthPhase_ $phase>
 Use StoreResponseLengthPhase__ RESPONSE_CONTENT_LENGTH         $phase
 Use StoreResponseLengthPhase__ RESPONSE_HEADERS:Content-Length $phase
</Macro>
SecAction  "phase:1,~{nosecaction},setvar:TX.resp_size=0"
Use StoreResponseLengthPhase_ 3
Use StoreResponseLengthPhase_ 4
Use StoreResponseLengthPhase_ 5
<IfDefine EXTENDEDSTATUS>
 SecRule TX:resp_size "@eq 0" "phase:4,~{nosecaction},chain"
  SecRule RESPONSE_BODY "@gt 0"  "t:length,setvar:TX.resp_size=%{MATCHED_VAR}"
</IfDefine>
   
# Enables SecStreamInBodyInspection which leads to a segmentation fault with chunked-encoding: https://github.com/SpiderLabs/ModSecurity/issues/2628
<IfDefine !noReqContentAutodetect>
 Use ReqContentAutodetect
</IfDefine>

# XML, JSON & AJAX requests
SecRule REQUEST_HEADERS:X-Requested-With "(?i)xmlhttprequest"                 "phase:1,~{nosecaction},t:none,setenv:req_ajax"
SecRule REQUEST_METHOD                   "!^(?:GET|HEAD|POST)$"               "phase:1,~{nosecaction},t:none,setenv:req_ajax"
SecRule REQUEST_HEADERS:Accept           "!html|[*]/[*]"                      "phase:1,~{nosecaction},t:none,setenv:req_ajax"
SecRule REQUEST_HEADERS:Sec-Fetch-Dest   "(?:^empty|^report|work(?:er|let))$" "phase:1,~{nosecaction},t:none,setenv:req_ajax"
#SecRule REQUEST_HEADERS:Sec-Fetch-Dest   "!document|navigate"                 "phase:1,~{nosecaction},t:none,setenv:req_ajax"
<IfDefine !noXML>
 SecRule REQUEST_HEADERS:Content-Type     "^~{MimeXML}"                        "phase:1,~{nosecaction},t:none,setenv:req_xml"
</IfDefine>
SecRule REQUEST_HEADERS:Content-Type     "^~{MimeJSONSeq}"                    "phase:1,~{skip}:1,t:none"
SecRule REQUEST_HEADERS:Content-Type     "^~{MimeJSON}"                       "phase:1,~{nosecaction},t:none,setenv:req_json,ctl:requestBodyProcessor=JSON"
SecRule TX:EXT                           "(?i)^json$"                         "phase:1,~{nosecaction},t:none,setenv:resp_json"
SecRule REQUEST_HEADERS:Accept           "~{MimeJSON}"                        "phase:1,~{nosecaction},t:none,setenv:resp_json"
SecRule ARGS:jsonp                       @unconditionalMatch                  "phase:1,~{nosecaction},t:none,setenv:req_jsonp"
SecRule TX:url                           "/jsonp\b"                           "phase:1,~{nosecaction},t:none,setenv:req_jsonp"
SecRule ENV:req_jsonp                    @unconditionalMatch                  "phase:1,~{nosecaction},t:none,setenv:resp_js"
SecRule REQUEST_HEADERS:User-Agent       "~{MSWebDavClient}"                  "phase:1,~{nosecaction},t:none,setenv:mso_client"
Use SecRule REQUEST_HEADERS:/^X-Office-/ @unconditionalMatch                  "phase:1,~{nosecaction},t:none,setenv:mso_client"

<IfDefine !noXML>
 # Store XML in REQUEST_BODY (if not parsed as XML)
 SecRule ENV:req_xml @unconditionalMatch "phase:1,t:none,~{nosecaction},tag:security,setenv:req_ajax,ctl:forceRequestBodyVariable=on"
</IfDefine>

SecRule ENV:req_js|ENV:req_json|ENV:resp_json|ENV:req_xml @unconditionalMatch "phase:1,~{nosecaction},t:none,setenv:req_ajax"
SecRule ENV:req_ajax                                      @unconditionalMatch "phase:1,~{nosecaction},t:none,setenv:resp_js"

SecRule REQUEST_HEADERS:Sec-Fetch-Dest "^(?:audio|font|image|object|paintworklet|track|video)" "phase:1,tag:security,~{noResponseBodyAccess},~{caseSensitive}"

# White-list monitoring API
Use MonitoringIP "~{RP_IP_Check}|~{MonitoringIP}"

# For auto-discovery
SecRule ENV:req_js|ENV:req_json|ENV:resp_json|ENV:req_xml  @unconditionalMatch "phase:2,t:none,~{nosecaction},setenv:req_ajax"
SecRule ENV:req_ajax                                       @unconditionalMatch "phase:2,t:none,~{noResponseBodyAccess},ctl:ruleRemoveById=2000001,ctl:ruleRemoveById=2000002"

# AJAX responses
SecRule RESPONSE_HEADERS:Content-Type "^~{MimeJSON}"            "phase:3,~{nosecaction},t:none,setenv:resp_json"
SecRule ENV:resp_json                 @unconditionalMatch       "phase:3,~{nosecaction},t:none,setenv:resp_js,ctl:ruleRemoveByTag=/^Output/"
# Set a variable if content type is HTML
SecRule RESPONSE_STATUS "!^(?:200|30[12])"                              "phase:3,t:none,~{skipAfter}:RespContentType"
SecRule RESPONSE_CONTENT_TYPE "^(?:text/html|application/xhtml[+]xml)"  "phase:3,t:none,~{nosecaction},setenv:HTML"
SecRule ENV:resp_js @unconditionalMatch                                 "phase:3,t:none,~{nosecaction},setenv:!HTML"
SecMarker RespContentType

#Use SecRule &TX:allowed3 "@eq 0"                        "phase:4,t:none,~{skip}:2"
#Use SecRule TX:noResponseBodyAccess @unconditionalMatch "phase:4,t:none,~{skip}:1"
#Use SecRule RESPONSE_BODY            "^<[?]xml "        "phase:4,t:none,~{nosecaction},setenv:resp_xml"

# Do not scan content of AJAX requests but log it
#SecRule  ENV:resp_js @unconditionalMatch  "phase:5,~{nosecaction},t:none,ctl:auditLogParts=+I"

# Scan text upload
#SecRule REQUEST_HEADERS:Content-Type "^text/plain" "phase:1,~{nosecaction},t:none,ctl:forceRequestBodyVariable=on,setvar:TX.plaintext"

# Response filtering (should add text/xml if needed)
#SecResponseBodyMimeType (null) text/html text/plain application/xhtml+xml
SecResponseBodyMimeType text/html text/plain application/xhtml+xml application/problem+json application/problem+xml

# Remove query (in case of)
RewriteCond %{QUERY_STRING} .
 RewriteRule "(?i)^(/SecError/errorPage/.*)" "$1?"

# For ErrorDocument handling
Use ErrorDocs

# Do not check loopback requests (proxying)
SecRule ENV:loopback @unconditionalMatch "phase:1,t:none,~{stopSecurity},ctl:auditEngine=off,setenv:allowAllCookies,setenv:noCSPChange,setenv:localhost"
# Do not check requests proxied by another (trusted) WAF
SecRule REMOTE_ADDR "~{WAF_RP_IP_Check}" "phase:1,t:none,~{stopSecurity},ctl:auditEngine=off,setenv:allowAllCookies"
# Disable processing of requests that were ignored in previous phases
SecRule TX:StopSecurity  "@eq 1"        "phase:2,t:none,~{stopSecurity},~{skipAll}"
SecRule TX:StopSecurity  "@eq 1"        "phase:3,t:none,~{stopSecurity},~{skipAll}"
SecRule TX:StopSecurity  "@eq 1"        "phase:4,t:none,~{stopSecurity},~{skipAll}"
<IfDefine !EXTENDEDSTATUS>
 SecRule TX:StopSecurity  "@eq 1"       "phase:5,t:none,~{skipAll}"
</IfDefine>

<IfDefine Publish>
 RewriteCond %{REMOTE_ADDR} "!=127.0.0.1"
 RewriteRule "(?i)^/__restricted/waf-publish/[-_.a-z0-9]+[.]log$" http://127.0.0.1%{REQUEST_URI} [P]
</IfDefine>

# Disable security for probes
SecRule TX:remote_addr  "~{ProbeIP_}"  "phase:1,t:none,~{stopSecurity},ctl:auditEngine=RelevantOnly,setenv:~{LogProbe}-log,setenv:ProbeIP_"
SecRule REQUEST_URI_RAW "~{ProbeURL_}" "phase:1,t:none,~{stopSecurity},ctl:auditEngine=RelevantOnly,setenv:~{LogProbe}-log"
# Special case for LB probes
SecRule TX:remote_addr  "!~{RP_IP_Check}" "phase:1,t:none,~{skip}:1"
SecRule &REQUEST_HEADERS:Host "@eq 0"     "phase:1,t:none,~{stopSecurity},ctl:auditEngine=RelevantOnly,setenv:~{LogProbe}-log,setenv:ProbeIP_"

# In case security is off
SetEnv noCSPChange 1
SecAction "phase:2,~{nosecaction},tag:security,setenv:!noCSPChange"

# In case SecRequestBodyLimitAction ProcessPartial
Use SecRuleDeny INBOUND_DATA_ERROR "@eq 1"   "phase:2,t:none,id:1000109,~{status}:400,msg:'Request too big (Use SecRequestBodyLimit)',~{NoLogC_}"

# Don't check the body if compressed (and allowed)
SecRule REQUEST_HEADERS:Content-Encoding "\bbr\b|gzip|deflate|compress" "phase:1,~{nosecaction},ctl:requestBodyAccess=off,~{caseSensitive}"

<IfDefine !noSecurityRules>
 # Map files for minified JS & CSS -> ignore
 # ruleRemoveById=2002400 useful in DetectionOnly to avoid false positives
 SecRule TX:BASENAME "[.](?:css|js|min)[.]map$"  "phase:1,~{stop404},t:none,ctl:ruleRemoveById=2002400,ctl:ruleRemoveById=2102404,msg:'Map files for minified JS & CSS -> ignore'"

 # Outlook autodiscovery -> ignore
 SecRule REQUEST_URI_RAW  "/autodiscover/"                                                               "phase:1,id:1000108,~{stop404},tag:Exchange,~{caseSensitive}"
 SecRule REQUEST_HEADERS:X-AnchorMailbox|REQUEST_HEADERS:X-AutoDiscoverArchiveAsSmtp @unconditionalMatch "phase:1,id:1000108,~{stop404},tag:Exchange"
 SecRule REQUEST_HEADERS:Content-Type "!^text/xml"                            "phase:2,~{caseSensitive},id:1000108,tag:Exchange,tag:security,tag:Ignore,~{skip}:1"
 SecRule STREAM_INPUT_BODY "^(?:(?><[?]xml [^>]{10,40})>\s*+)?<Autodiscover\s" "phase:2,~{caseSensitive},id:1000108,tag:Exchange,~{stop404}"
 
 # For Safari "preview" feature -> do not count as attack
 SecRule REQUEST_HEADERS:X-Purpose  "^preview$"  "phase:2,t:none,id:~{SafariPreviewId},~{stop404}"
</IfDefine>

# Switch to blocking mode if (test) header is present
SecRule REQUEST_HEADERS:X-WAF-AlwaysBlock @unconditionalMatch  "phase:1,t:none,~{nosecaction},ctl:ruleEngine=on"

# Cookies ----------------------------------------------------------------------
# IgnoreAllCookies => never check generic syntax
# AllowAllCookies  => check generic syntax
# AcceptCookie     => no generic syntax (unless AllowAllCookies) 
Use SecRule ENV:ignoreAllCookies @unconditionalMatch "phase:2,tag:security,tag:COOKIE,~{skip}:3"
Use SecRule ENV:allowAllCookies  @unconditionalMatch "phase:2,tag:security,tag:COOKIE,~{skip}:1"
Use SecRule ENV:acceptCookie     @unconditionalMatch "phase:2,tag:security,tag:COOKIE,~{skip}:1"
Use SecAction                                        "phase:2,tag:security,tag:COOKIE,~{nosecaction},setvar:TX.CheckCookiesNames"

# Maximum response body size that will be accepted for buffering (multipart/form-data).
# This setting will not affect the responses with MIME types that are not marked for buffering.
# There is a hard limit of 1 GB.
# Only 128 KB are stored in memory, if bigger the file is copied to disk
# (use SecRequestBodyInMemoryLimit to change this)
SecResponseBodyLimit ~{MaxResponseLengthToAnalyse}
# Anything over the above limit will be ignored
SecResponseBodyLimitAction ProcessPartial

<LocationMatch "[.]~{StaticFileExt}$">
 Use SecNoCheckResponse
</LocationMatch>

# Set Web server identification string
Header always set Server "~{ServerBanner}"
SecServerSignature           "~{ServerBanner}"

## -- Temporary files -----------------------------------------------
## All the directories must be created and writeable

# Configures the directory where temporary files will be created.
SecTmpDir "~{SecRootDir}/TmpDir"

# Upload storage path.
SecUploadDir "~{SecRootDir}/UploadDir"

# Path for persistent data (e.g. IP address data, session data, etc)
SecDataDir "~{SecRootDir}/DataDir"

## -- File uploads configuration -----------------------------------------------
# Whether or not to keep the stored files: "RelevantOnly" to store suspicious requests
SecUploadKeepFiles Off

# Inspect uploaded files (ex: anti-virus)
# An example script is included with ModSecurity (/util/modsec-clamscan.pl)
# SecRule  FILES_TMPNAMES "@inspectFile /opt/apache/bin/inspect_script.pl" "t:none,msg:'Anti-virus scan',tag:Virus"

## -- Logging ----------------------------------------------------------------

#SecComponentSignature "Approach/~{WAF_CONF_COMMON}"

# Whether to log requests to the audit log.
SecAuditEngine RelevantOnly

# Do not log any other error than pure filtering ones
# Could add "^[45]" to log 4xx & 5xx errors
SecAuditLogRelevantStatus "^$"

# Log files structure
#
# You can select to log all events to a single log file (set SecAuditLogType to 
# "Serial") or to log each request to a separate file (set it to "Concurrent"). 
# The former is usually easier to use, but if full logging is required or if 
# the protected system supports a large transaction volume the later may
# be a better option.
SecAuditLogType Serial

# Audit log
SecAuditLog  ~{SecLog}

# Select what portions of the request to log
#
# Modify the string by adding any of the letter below to it:
# A - audit log header (mandatory)
# B - request headers
# C - request body (present only if the request body exists and ModSecurity is 
#     configured to intercept it)
# E - intermediary response body (present only if ModSecurity is configured to 
#     intercept response bodies, and if the audit log engine is configured to 
#     record it). Intermediary response body is the same as the actual response 
#     body unless ModSecurity intercepts the intermediary response body, in 
#     which case the actual response body will contain the error message 
#     (either the Apache default error message, or the ErrorDocument page).
# F - final response headers (excluding the date and headers, which are 
#     always added by Apache in the late stage of content delivery).
# G - Reserved for the actual response body; not implemented yet
# H - audit log trailer
# I - This part is a replacement for part C. It will log the same data as C in 
#     all cases except when multipart/form-data encoding in used. In this case 
#     it will log a fake application/x-www-form-urlencoded body that contains 
#     the information about parameters but not about the files. This is handy 
#     if you don't want to have (often large) files stored in your audit logs.
# J - Multipart Files Information
# K - matching rules
# Z - final boundary, signifies the end of the entry (mandatory)
SecAuditLogParts  ABIFHZ

# Sanitise Authorization header
Use SanitizeHeaderExt         /(?i)Authori[sz]ation/ "^[^ ]{0,10}(.*)"
Use SanitizeResponseHeaderExt /(?i)Authori[sz]ation/ "^[^ ]{0,10}(.*)"
# Treat the following as passwords
Use SanitizeArg "/~{_passwArgs_}/"
# Not possible because of quotes needed inside regex
Use SanitizeXML "~{_passwArgs_}"

# --------------------------------------------------------------------------------------------------------

# Add Basic Authentication userid to logs
SecRule REQUEST_HEADERS:Authorization  "^Basic\s(~{syntax_base64})$"  "phase:1,~{nosecaction},chain,t:none,capture"
 SecRule  TX:1  "^(.*)$"                                              "chain,t:none,t:base64Decode,capture"
  SecRule  TX:1  "^([^:]+):(.*)$"                                     "t:none,capture,setuid:%{TX.1},setenv:WAF_USER=%{TX.1},setenv:AUTH_PWD=%{TX.2},setvar:TX.AuthHeader"
#SecAction "phase:1,~{log},msg:'%{USERID}/%{ENV.AUTH_PWD}'"

# Add Digest Authentication userid to logs
SecRule REQUEST_HEADERS:Authorization  "^Digest\susername=\x22([^\x22]*)"  "phase:1,~{nosecaction},t:none,capture,setuid:%{TX.1},setenv:WAF_USER=%{TX.1},setvar:TX.AuthHeader"
#SecAction "phase:1,~{log},msg:'%{USERID}'"


# Set session cookies with user info
Setenvif  USERID "^(.+)$"  WAF_USER=$1
<IfDefine !NOSSL>
 SetEnvIf  SSL_CLIENT_S_DN "^(.+)$"  WAF_CN=$1
</IfDefine>


# Load the variable collection relating to the requested resource (first level directory)
# In case it is blocked in phase 1/2 => phase 3 is not executed ==> initialiase in phase 5
#  in case of blocking rules using resource (hash, etc.)
# Cannot be overwritten by Proxy... directives
# Initiate collection only on error to prevent overloading (some servers use 302 for real contents)
SecRule RESPONSE_STATUS "^(?:30[17]$|[45])" "phase:5,~{nosecaction},t:none,initcol:RESOURCE=global,setvar:tx.skip_resource"

## GeoIP -----------------------------------
# New format (mod_maxminddb): https://dev.maxmind.com/geoip/geoip2/geolite2/
<IfModule maxminddb_module>
 MaxMindDBEnable On
 MaxMindDBFile CITY_DB "~{GeoPath}"
 MaxMindDBEnv geo_country_code  CITY_DB/country/iso_code
 MaxMindDBEnv geo_country_name  CITY_DB/country/names/en
 MaxMindDBEnv geo_city          CITY_DB/city/names/en
 MaxMindDBEnv geo_zip           CITY_DB/city/iso_code
</IfModule>
## -----------------------------------

# Google Safe Browsing DB
#SecGsbLookupDB ~{GsbPath}

# Disallow all extensions, methods
SecAction "phase:1,~{nosecaction},setvar:tx.allowed_upfileext=,setvar:tx.allowed_method=0"

# Only accepts safe methods (especially, deny TRACE & TRACKS)
SecRule REQUEST_METHOD "^(?:HEAD|GET|OPTIONS|POST)$"  "phase:1,t:none,~{nosecaction},setvar:TX.allowed_method=1"

# Allow OPTIONS method for Cross-Origin Resource Sharing
Use SecRule REQUEST_METHOD "^OPTIONS$"  "phase:1,~{nosecaction},t:none,chain"
 Use SecRule REQUEST_HEADERS:Access-Control-Request-Method "^[A-Z]+$"  "t:none,chain"
  Use SecRule REQUEST_HEADERS:Access-Control-Request-Headers @unconditionalMatch  "t:none,chain"
   Use SecRule REQUEST_HEADERS:Origin @unconditionalMatch  "t:none,setvar:TX.allowed_method=1,ctl:ruleRemoveById=2002400"

# Accept internal cookies but don't check syntax
#  _acl has a very strict rule
#  waf_user may contain \ in case of Windows auth, etc.
#  waf_user checked against user name syntax
#  waf_cn is generated by CA
Use AcceptSetCookie_ "_acl|waf_[^= ]*"

# Store referer
Use SecRule REQUEST_HEADERS:Origin  @unconditionalMatch  "phase:1,t:none,~{skip}:1,setenv:referer=%{MATCHED_VAR}"
Use SecRule REQUEST_HEADERS:Referer "^(https?://[^/]+)"  "phase:1,t:none,~{nosecaction},capture,setenv:referer=%{TX.1}"
Use SecRule ENV:referer             "^https?://(.*)"     "phase:1,t:none,~{nosecaction},capture,setenv:referer_host=%{TX.1}"

# Disable compression between proxy and back-end to be able to parse the data
# Accept-Encoding=end-to-end
<IfModule brotli_module>
 # Let 'br' active otherwise brotli_module doesn't accept to compress
 RequestHeader set Accept-Encoding "identity;q=1,*;q=0,br;q=0.1" "expr=reqenv('be_cannot_compress') == '1' || reqenv('be_shouldnt_compress') == '1'"
</IfModule>
<IfModule !brotli_module>
 RequestHeader set Accept-Encoding "identity;q=1,*;q=0"          "expr=reqenv('be_cannot_compress') == '1' || reqenv('be_shouldnt_compress') == '1'"
</IfModule>
# TE=hop-by-hop, stripped by httpd
#RequestHeader edit TE "^.*(trailers *,)?.*$" "$1*;q=0" env=be_cannot_compress
#RequestHeader setifempty TE                    "*;q=0" env=be_cannot_compress

# Unset header in case it contains "undefined"
RequestHeader unset Authorization env=unsetAuthHeader

Use SetHomePage /

# Disable scan content of some responses ---------------------------------------
DefineStr skipResponseBodyAccess   "~{noResponseBodyAccess},~{skipAfter}:AfterNoResponseBodyAccess"
#DefineStr skipResponseBodyAccessP3 "~{noResponseBodyAccessP3},~{skipAfter}:AfterNoResponseBodyAccess"
# Never compress compressed files
SecRule TX:EXT "^~{AllCompressedExt}$" "phase:1,t:none,~{skipResponseBodyAccess},setenv:be_shouldnt_compress"
#SecRule TX:EXT "^~{AllCompressedExt}$"  "phase:3,t:none,~{skipResponseBodyAccessP3}"
# Don't scan CSS, JS & documents
SecRule TX:EXT "~{StaticFileExt}$"     "phase:1,t:none,~{skipResponseBodyAccess}"

# Allow static compressed responses
#SecRule TX:EXT "^~{StaticFileExt}$"                                                    "phase:3,t:none,~{nosecaction},setenv:!be_cannot_compress"
SecRule RESPONSE_CONTENT_TYPE "!^(?:text/(?:plain|html)|application/xhtml[+]xml|~{MimeJSON})" "phase:3,t:none,~{nosecaction},setenv:!be_cannot_compress"

SecRule TX:noResponseBodyAccess "@unconditionalMatch" "phase:3,t:none,~{noResponseBodyAccessP3}"

# Always log invalid access (even to images, css, ...)
# Only scan response on status 200 & 500 (also on 4xx & 5xx if JSON)
SecRule RESPONSE_STATUS "^[45]"  "phase:3,t:none,chain,setenv:!no-log,~{skipAfter}:AfterNoResponseBodyHTML"
 SecRule RESPONSE_CONTENT_TYPE "~{MimeJSON}"  "ctl:auditLogParts=+E"

 SecRule RESPONSE_STATUS "!^[25]00$"                                               "phase:3,t:none,~{noResponseBodyAccessP3},setenv:noCSP"
 # Only scan HTML
 SecRule RESPONSE_CONTENT_TYPE "!^(?:text/(?:plain|html)|application/xhtml[+]xml)" "phase:3,t:none,~{noResponseBodyAccessP3}"
SecMarker AfterNoResponseBodyHTML

# Check also in phase 4 if Content-Length was not provided
Use SecRule OUTBOUND_DATA_ERROR "@eq 1"                                            "phase:3,t:none,~{noResponseBodyAccessP3}"

# Do not scan attachments
SecRule RESPONSE_HEADERS:Content-disposition "^attachment"                         "phase:3,t:none,~{noResponseBodyAccessP3}"
# Do not scan very long pages
Use SecRuleIntComp_ RESPONSE_HEADERS:Content-Length ~{MaxResponseLengthToAnalyse} ",phase:3" ",t:none"
SecRule TX:intcmp "^gt"                                                            "phase:3,t:none,~{noResponseBodyAccessP3}"

# Don't scan compressed response (warning potentially generated later)
Use SecRule RESPONSE_HEADERS:Content-Encoding  "~{ContentNeg_CompressedResponse}"  "phase:3,t:none,~{noResponseBodyAccessP3},setenv:resp_compressed"

SecMarker AfterNoResponseBodyAccess

# If needed, check in phase 4 if Content-Length was not provided
Use SecRule OUTBOUND_DATA_ERROR "@eq 1" "phase:4,t:none,~{noResponseBodyAccessP3}"

# ------------------------------------------------------------------------------

# Calculate a hash of client (almost) invariants
#SecRule  REQUEST_HEADERS:Host|REQUEST_HEADERS:User-Agent|REQUEST_HEADERS:Accept|REQUEST_HEADERS:Accept-Charset|REQUEST_HEADERS:Accept-Encoding|REQUEST_HEADERS:Accept-Language|REQUEST_HEADERS:Via|TX:remote_addr @unconditionalMatch "phase:1,~{nosecaction},t:none,setvar:TX.ua_hash=%{TX.ua_hash}%{MATCHED_VAR}"

# Calculate a (psseudo) random
#SecAction                           "phase:1,~{nosecaction},setvar:TX.rnd=%{TX.ua_hash}%{ENV.UNIQUE_ID}"
#SecRule  TX:rnd @unconditionalMatch "phase:1,~{nosecaction},t:none,t:sha1,t:base64Encode,setvar:TX.rnd=%{MATCHED_VAR},setenv:rnd=%{MATCHED_VAR}"

# HTTP Parameter Pollution (HPP)
#
# One HPP attack vector is to try evade signature filters by distributing the attack payload
# across multiple parameters with the same name.
# Some back-end web application may (in the case of ASP.NET) consolidate all of the payloads
# into one, thus making the attack payload active.
#
# The ruleset below is not looking for attacks directly, but rather is a crude normalization
# function that mimics ASP.NET with regards to joining the payloads of parameters with the
# same name.  These rules will create a new TX:HPP_DATA variable that will hold this data.
#SecRule  ARGS @unconditionalMatch "phase:2,chain,~{nosecaction},t:none,capture,id:'960022',setvar:TX.%{MATCHED_VAR_NAME}=+1"
 #SecRule  TX:/^ARGS:/ "@gt 1" "chain,t:none"
  #SecRule  MATCHED_VAR_NAMES "TX:(ARGS:.*)" "chain,capture,t:none,setvar:TX.HPP_NAMES=%{TX.1}"
   #SecRule  ARGS "." "chain,t:none,capture,setvar:tx.arg_counter=+1,setvar:'TX.HPPNAMEDATA_%{TX.ARG_COUNTER}=%{MATCHED_VAR_NAME}=%{MATCHED_VAR}'"
    #SecRule  TX:/HPPNAMEDATA_/ "@contains %{TX.HPP_NAMES}" "chain,setvar:TX.HPP_COUNTER=+1,setvar:TX.HPP_COUNTER_%{TX.HPP_COUNTER}=%{MATCHED_VAR}"
     #SecRule  TX:/HPP_COUNTER_/ "ARGS:(.*)?=(.*)" "capture,setvar:'TX.HPP_DATA=%{TX.HPP_DATA},%{tx.2}'"

#SecRule  ARGS "." "phase:2,~{nosecaction},t:none,setvar:'TX.HPP_COUNT:%{MATCHED_VAR_NAME}=+1'"
#SecRule  ARGS "." "phase:2,~{nosecaction},chain,t:none,setvar:'TX.HPP_%{MATCHED_VAR_NAME}=>,%{MATCHED_VAR}'"
 #SecRule  TX:HPP_COUNT:%{MATCHED_VAR_NAME} "@gt 1" "t:none"
#SecRule  TX:/^HPP_ARGS:(.*)/ @unconditionalMatch "phase:2,~{log},t:none,msg:'HTTP Parameter Pollution'"

# ?Also: text/css text/javascript application/x-css application/x-javascript

# Disable error checking in case of connection closed in the middle (mod_jk)
#SecRule  RESPONSE_BODY "A connection attempt failed because the connected party did not properly respond after a period of time" "phase:4,~{stopSecurity},ctl:auditEngine=RelevantOnly"

# Capture relevant part of URL (without the jsessionid)
Use ParseURL_ "^(.*)(?i:;jsessionid=[^/?;]*)$" none,tag:specific

Include conf/common/security/session.conf

# Detect backend
SecRule RESPONSE_HEADERS:~{BackendIdHeader} @unconditionalMatch "phase:3,t:none,~{nosecaction},setvar:TX.backend=%{MATCHED_VAR}"

# Set Access-Control-Allow-Origin
<IfDefine !noCORSheader>
 Use SecAction "phase:1,~{nosecaction},setenv:allowCORS=%{REQUEST_HEADERS.Host}"
 # Check Origin to use it as Access-Control-Allow-Origin if authorised
 Use SetenvSec allowCORSProtocol "https"
 SecRule &ENV:allowCORS "@eq 0" "phase:3,t:none,~{skipAfter}:AfterSetAuthCORS,tag:security"
 SecRule ENV:allowCORS "^[*]$"  "phase:3,t:none,~{skipAfter}:AfterSetAuthCORS,tag:security"
  #???SecRule REQUEST_HEADERS:sec-fetch-mode "^no-cors$"  "phase:3,t:none,~{skipAfter}:AfterSetAuthCORS,tag:security"
  # Store actual header
   SecRule REQUEST_HEADERS:Origin "^%{ENV.allowCORSProtocol}://(?:%{ENV.allowCORS})$" "phase:3,t:none,~{nosecaction},tag:security,setenv:CorsOrigin=%{REQUEST_HEADERS.Origin}"
  SecMarker AfterSetAuthCORS,tag:security
</IfDefine>

# Logging ------------------------

# Requests blocked by Apache/Modsecurity core
<Macro ErrorLogMsg $context $id $pattern $msg>
 <IfDefine !noSecurityRules>
  Use SecRule WEBSERVER_ERROR_LOG "[[]Level 3[]] +$pattern" "phase:5,id:$id,t:none,~{increaseBlockCounter},~{requestWarn},severity:ERROR,capture,msg:'$context Error: $msg',tag:Log"
 </IfDefine>
 <IfDefine noSecurityRules>
  Use UnusedParam "$context $id $pattern $msg"
 </IfDefine>
</Macro>
<Macro ErrorLogMsgApache @id @pattern @msg>
 Use ErrorLogMsg Apache  @id @pattern @msg
</Macro>
<Macro ErrorLogMsgModSec     @id                $pattern  @msg>
 Use ErrorLogMsg ModSecurity @id " ModSecurity: $pattern" @msg
</Macro>
# httpd trapped errors
Use SecRule WEBSERVER_ERROR_LOG "!^[[]level 3[]] AH[0-9]{5}:" "phase:5,t:none,~{skipAfter}:AfterAH,tag:Log"
 #AH00134: Invalid method in request (TLS on HTTP port?)
 #AH02219: SSL connection required
 Use ErrorLogMsgApache 1000110 "AH0(?:056[567]|0570|2539): (.{0,200})"   "Invalid request: %{TX.1}"
 Use ErrorLogMsgApache 1000111 "AH0013[45]:"                             "Invalid method in request"
 Use ErrorLogMsgApache 1000112 "AH00569:"                                "Request without hostname"
 Use ErrorLogMsgApache 1000113 "AH0203[123]:"                            "SNI different from hostname"
 Use ErrorLogMsgApache 1000114 "AH02018:"                                "TLS body exceeds max. size (possibly increase size with SecAllowSOAP or SSLRenegBufferSize)"
 Use ErrorLogMsgApache 1000115 "AH(?:00(?:0[23]6|12[67])|10244):"        "Invalid URI"
 Use ErrorLogMsgApache 1000116 "AH0(?:22(?:19|6[56]|2[89])): (.{0,200})" "TLS problem: %{TX.1}"
 Use ErrorLogMsgApache 1000117 "AH02430: (.{0,300})"                     "Invalid header (smuggling attack?): %{TX.1}"
 Use ErrorLogMsgApache 1000118 "AH0056[67]: (.{0,300})"                  "Smuggling attack?: %{TX.1}"
 Use ErrorLogMsgApache 1000119 "AH00561: (.{0,300})"                     "Header too long: %{TX.1}"
 # Only logged at debug level
 #Use ErrorLogMsgApache 1000119 "AH02426: [^:]+: (.*)"                    "Header name malformed: %{TX.1}"
 #Use ErrorLogMsgApache 1000119 "AH00567:"                                "Error reading headers"
Use SecMarker AfterAH,tag:Log

SecRule ENV:locationOK "^1" "phase:5,tag:security,~{skipAfter}:EndOfLocalFileNotFound"
 Use ErrorLogMsgApache 1000130,capture "File does not exist: (.*)"   "Local file does not exist <%{TX.1}>"
SecMarker EndOfLocalFileNotFound

# ModSecurity trapped errors
Use ErrorLogMsgModSec 1000131 "(.*). Deny with code" "Request refused, see error.log. Body probably too large (%{TX.req_size}/%{TX.1}), use SecRequestBodyLimit/SecRequestBodyNoFilesLimit to change it"

# Config sanity checks (only in detection mode)
SecRule &ENV:detection  "@eq 0"             "phase:5,tag:security,~{skipAfter}:EndOfConfigCheck"
SecRule RESPONSE_STATUS "^[45]"             "phase:5,tag:security,~{skipAfter}:EndOfConfigCheck"
SecRule ENV:StaticPages @unconditionalMatch "phase:5,tag:security,~{skipAfter}:EndOfConfigCheck"
 Use LogOncePerApp "*Config: Specify OS (Use BackendOSWindows/BackendOSUnix)"                               1000103 "tag:security,tag:config"
 Use LogOncePerApp "*Config: Specify Web Server (Use BackendWebApache, BackendWebIIS, ...)"                 1000104 "tag:security,tag:config"
 Use LogOncePerApp "*Config: Specify Dev Framework (Use FrameworkDotNet, FrameworkPHP, FrameworkJava, ...)" 1000105 "tag:security,tag:config"
 Use LogOncePerApp "*Config: Specify DB (Use DBSqlServer, DBOracle, DBMySQL, ...)"                          1000106 "tag:security,tag:config,tag:DBAll"
SecMarker EndOfConfigCheck,tag:security

# Log invalid root path (case error)
Use RuleLogOnceExt ENV:InvalidProxyCase "@eq 1" t:none "tag:security" "Invalid root path case" 1000107 "tag:security" "%{WEBAPPID}"

# Paths to ignore: check only once 
SecRule TX:url "~{PathToIgnore}"       "phase:1,t:none,~{nosecaction},setenv:PathToIgnore,setenv:be_shouldnt_compress"
SecRule &ENV:PathToIgnore "@eq 0"      "phase:1,t:none,~{skip}:2"
SecRule TX:url "~{PathToIgnoreIcons}"  "phase:1,t:none,~{nosecaction},setenv:PathToIgnoreIcons"
SecRule TX:url "~{PathToIgnoreRobots}" "phase:1,t:none,~{nosecaction},setenv:PathToIgnoreRobots"

# Send request unique ID to client
Header always unset X-Unique-id
Header always   set X-Unique-id "~{UNIQUE_ID}" "expr=-z resp('X-Unique-id')"

# Send error message to browser
# For ErrorDocument, headers not processed => processed in sub-phase where VAR becomes REDIRECT_VAR
Header          set X-SecError-Msg  "%{REDIRECT_errorMsg}e"                                 "expr=-z resp('X-SecError-Msg')  && reqenv('REDIRECT_errorMsg')  != '' && reqenv('noErrorHeader') == ''"
Header always   set X-SecError-Msg  "%{errorMsg}e"                                          "expr=-z resp('X-SecError-Msg')  && reqenv('REDIRECT_errorMsg')  == '' && reqenv('noErrorHeader') == '' && reqenv('errorMsg') != ''"
Header          set X-SecError-Page "https://%{HOST}e/SecError/%{REDIRECT_errorPage}e.html" "expr=-z resp('X-SecError-Page') && reqenv('REDIRECT_errorPage') != '' && reqenv('noErrorHeader') == ''"
Header always   set X-SecError-Page "https://%{HOST}e/SecError/%{errorPage}e.html"          "expr=-z resp('X-SecError-Page') && reqenv('REDIRECT_errorPage') == '' && reqenv('noErrorHeader') == '' && reqenv('errorPage') != ''"
# Send additional info to back-end (and to browser in EXTENDEDSTATUS)
Use SendWafInfo

<IfDefine EXTENDEDSTATUS>
 # Check if XML needs to be sanitized
 SecRule ENV:req_xml @unconditionalMatch "phase:2,t:none,~{nosecaction},chain"
  SecRule STREAM_INPUT_BODY "<(?:(?>[^/> ]+):)?(?:%{TX.XmlSanArgs})"   "setenv:LOG_SANITIZED"
</IfDefine>

<IfDefine ExtendedInfo>
 # Check cookies sent by back-end (normally fix them without notice)
 <Macro ExtendedInfoSetcookie $keyword @pattern $msg>
  # This must stay in phase 3 to set exceptions
  SecRule RESPONSE_HEADERS:Set-Cookie  @pattern "phase:3,chain,tag:security,~{nosecaction}"
   SecRule MATCHED_VARS "^([^=]+)"     "capture,setvar:'tx.cookieNot$keyword=%{TX.1},%{tx.cookieNot$keyword}'"
   
  SecRule &TX:cookieNot$keyword "@eq 0"                                              "phase:4,tag:security,t:none,~{skipAfter}:AfterNot$keyword"
  SecRule GLOBAL:cookieNot$keyword "@contains |%{WEBAPPID}/%{TX.cookieNot$keyword}|" "phase:4,tag:security,t:none,~{skipAfter}:AfterNot$keyword"
   SecAction                                                                         "phase:4,tag:security,~{nosecaction},setvar:'GLOBAL.cookieNot$keyword=|%{WEBAPPID}/%{tx.cookieNot$keyword}|%{GLOBAL.cookieNot$keyword}',setenv:'cookieNot$keyword=%{TX.cookieNot$keyword}'"
  SecMarker AfterNot$keyword,tag:security
  SecRule ENV:cookieNot$keyword @unconditionalMatch "phase:5,~{debug},msg:'Cookies sent by back-end $msg <%{tx.cookieNot$keyword}>'"
  <IfDefine EXTENDEDSTATUS>
   Header add X-CookieNot$keyword "%{cookieNot$keyword}e" env=cookieNot$keyword
  </IfDefine>
 </Macro>
 Use ExtendedInfoSetcookie HttpOnly     "!(?i)HttpOnly"      "not HttpOnly"
 Use ExtendedInfoSetcookie Samesite     "!(?i)Samesite"      "not Samesite"
 Use ExtendedInfoSetcookie SamesiteNone "(?i)Samesite=none"  "insecure Samesite"
</IfDefine>

# Concatenate all ARGS -------------------------------
#SecRule "~{args}"  @unconditionalMatch "phase:2,~{nosecaction},t:none,setvar:'tx.args=%{tx.args},%{MATCHED_VAR}',tag:ARGS"
#SecRule TX:args  "^,(.*)"              "phase:2,~{nosecaction},t:none,capture,setvar:'tx.args=%{TX.1}',tag:ARGS"

SecAction "phase:1,~{nosecaction},setenv:WORKER_NAME=^@@--@@$"
<IfModule proxy_balancer_module>
 <Location "/_restricted/balancer-manager">
  SetHandler balancer-manager
 </Location>
 SecRule ENV:BALANCER_WORKER_NAME "(.)$"              "phase:3,~{nosecaction},t:none,capture,setenv:WORKER_NAME=%{MATCHED_VAR},setenv:WORKER_NUM=%{TX.1}"
 SecRule ENV:BALANCER_WORKER_NAME @unconditionalMatch "phase:3,~{nosecaction},t:none,t:sha1,t:base64Encode,setenv:WORKER_HASH=%{MATCHED_VAR}"
</IfModule>
SecAction "phase:3,~{nosecaction},setenv:backstatus=RESPONSE_STATUS"

# First because of special treatment
include conf/common/security/csp.conf

# Initial place to disable some locations --------------------------------------
Include conf/site/disable.conf
# wildcard mandatory before 2.4.30 but keep it to allow multiple files
IncludeOptional conf/emergenc?/disable*.conf

Use SecRule &TX:allowed3  "@eq 0" "phase:4,tag:security,tag:Output,t:none,~{nosecaction},setvar:tx.noResponseBodyAccess"
Use SecRule &ENV:allowed4 "@eq 0" "phase:5,tag:security,tag:Output,t:none,~{nosecaction},setvar:tx.noResponseBodyAccess"
