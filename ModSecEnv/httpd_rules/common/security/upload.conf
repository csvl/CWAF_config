# ModSecurity rules for file upload
# ---------------------------------------------------------------
# Range: 2002300-2002319

Use SecAllowUpChars ""

# Store forced upload filename (usually forbidden anyway) => only one of "filename" & "filename*"
# ...;filename*=UTF-8''"/.../name" ...
#SecRule REQUEST_HEADERS:Content-Disposition "(?i)filename[*]?\s*+=\s*+(?:.+')?\x22(?:[^\x22]+/)?([^\x22]+)"   "phase:1,t:none,t:normalisePathWin,t:lowercase,capture,setvar:TX.uploadfname=%{TX.1},~{skip}:1"
#SecRule REQUEST_HEADERS:Content-Disposition "(?i)filename[*]?\s*+=\s*+(?:.+')?[^\x22](?:[^ ]*/)?(.+)(?: |$)"  "phase:1,t:none,t:normalisePathWin,t:lowercase,capture,setvar:TX.uploadfname=%{TX.1},~{nosecaction}"
# filename* shouldn't be used anymore
SecRule REQUEST_HEADERS:Content-Disposition "(?i)filename\s*+=\s*+\x22(?:[^\x22]+/)?([^\x22]+)"   "phase:1,t:none,t:normalisePathWin,capture,setvar:TX.uploadfname=%{TX.1},~{skip}:1"
SecRule REQUEST_HEADERS:Content-Disposition "(?i)filename\s*+=\s*+[^\x22](?:[^ ]*/)?(.+)(?: |$)"  "phase:1,t:none,t:normalisePathWin,capture,setvar:TX.uploadfname=%{TX.1},~{nosecaction}"
Use SecRuleDeny REQUEST_HEADERS:Content-Disposition "(?i)filename[*]\s*+="          "phase:1,id:2002309,t:none,msg:'filename* is obsolete',~{testRule},rev:20231129"
<IfDefine MODSEC_AnalyseMultipartHeaders>
 Use SecRuleDeny MULTIPART_PART_HEADERS "(?i)Content-Disposition.*filename[*]\s*+=" "phase:2,id:2002309,t:none,msg:'filename* is obsolete',~{testRule},rev:20231129"  
</IfDefine>

# Store PUT upload filename
SecRule &ENV:webdav  "@eq 0"              "phase:1,tag:security,~{skipAfter}:AfterPutFn"
SecRule ENV:req_json "@eq 1"              "phase:1,tag:security,~{skipAfter}:AfterPutFn"
 SecRule REQUEST_METHOD "^PUT" "phase:1,tag:security,chain,t:none,~{nosecaction},msg:'fname=%{TX.uploadfname}'"
  SecRule TX:BASENAME @unconditionalMatch "t:~{urlUnicode},t:lowercase,setvar:TX.uploadfname=%{MATCHED_VAR}"
Use SecMarker AfterPutFn,tag:security

# Store WebDAV copy/move filename
SecRule REQUEST_HEADERS:Destination "([^/]*)$"  "phase:1,t:~{urlUnicode},t:normalisePathWin,t:lowercase,~{nosecaction},capture,setvar:TX.uploadfname=%{TX.1},msg:'fname=%{TX.uploadfname}'"

# '+' is decoded as a space => dedicated rule
Use SecRuleUpFile "[+]" "2002307,msg:'character + in URL (Use SecAllowPlusInUpDocs / SecAllowPlusInUpDownDocs and allow space in URL)'"

# Block SVG extension in filenames (can contain script)
Use SecRuleUpFile   "(?i)[.]svgz?$"                        "2002306,msg:'SVG images can contain scripts (Use SecAllowSVGUpLoad)'"
Use SecRuleDeny ENV:req_svg @unconditionalMatch "phase:2,id:2002308,msg:'SVG images can contain scripts (Use SecAllowSVGUpLoad)'"

# Block double extensions in filenames
#Use SecRuleUpFile  "[.].*[.]"   "2002301,msg:'Double extension in uploaded file <%{MATCHED_VAR}>'"
#Use SecRuleUpFile  "[.][.]"     "2002302,msg:'.. in uploaded file'"

Use SecRuleUpFile  "^[.]"       "2002304,msg:'Uploaded file beginning with dot'"

# Validate URL encoding
#Use SecRuleUpFile  "@validateUrlEncoding"   "2002303,msg:'Invalid filename encoding'"

# Upload exploits
Use SecRuleUpFile "[;:][.]"  "2002305,msg:'Invalid sequence of chars in upload filename'"
