# ModSecurity rules: final rules in phase 5
# Global scope because locations not available when blocking in phase 1
# Range: 4001000-4001099

<LocationMatch [.]~{UsualResFileExt}$>
 Use SecIgnorePageNotFound
</LocationMatch>

<Location />
 # Check that ReqBodyNoFilesSizeMax is >= than SecArgsTotalSizeMax
 Use SecRule &TX:ReqBodyNoFilesSizeMax "@eq 0"                         "phase:~{Phase5Warn},t:none,tag:security,~{skipAfter}:AfterReqBodyNoFilesSizeMax"
 Use SecRule &TX:ArgsTotalSizeMax      "@eq 0"                         "phase:~{Phase5Warn},t:none,tag:security,~{skipAfter}:AfterReqBodyNoFilesSizeMax"
 Use SecRuleIntComp_  TX:ReqBodyNoFilesSizeMax %{TX.ArgsTotalSizeMax} ",phase:~{Phase5Warn},tag:security" ",t:none"
 Use SecRule TX:intcmp "!^lt"                                          "phase:~{Phase5Warn},t:none,tag:security,~{skipAfter}:AfterReqBodyNoFilesSizeMax"
  Use LogOncePerApp "SecRequestBodyNoFilesLimit parameter (%{TX.ReqBodyNoFilesSizeMax}) < SecArgsTotalSizeMax parameter (%{TX.ArgsTotalSizeMax})" 4001008 "tag:security,tag:config"
 Use SecMarker AfterReqBodyNoFilesSizeMax,tag:security

 <IfDefine ---ExtendedInfo>
  Use LogOrgRespHeader 4001002 Content-Security-Policy    noCSPChange
  Use LogOrgRespHeader 4001003 Cross-Origin-Opener-Policy noCSPChange
  Use LogOrgRespHeader 4001004 Referrer-Policy            noReferrerPolicy
  Use LogOrgRespHeader 4001005 X-Frame-Options            noCSPChange
 </IfDefine>

 # Modify counters
 Use SecAction "phase:5,t:none,~{nosecaction},setvar:IP.blocked=+%{tx.blocked},setvar:IP.BadAuth=+%{tx.BadAuth}"
 # ,setvar:SESSION.blocked=+%{tx.blocked},setvar:SESSION.BadAuth=+%{tx.BadAuth}

 # Clean-up invalid collections
 Use DontWriteInvalidCol IP
 Use DontWriteInvalidCol SESSION
 Use DontWriteInvalidCol RESOURCE

 Use CleanupCounters

 # For compression -------------------------------------------------------------
 # Log invalid header specifying compression (only once, if content needed to be analysed)
 # Buggy, ignore for the moment?
 Use SecRule RESPONSE_STATUS "!^200"                    "phase:~{Phase5Warn},t:none,id:4001007,tag:security,~{skipAfter}:AfterNoResponseBodyAccess"
 Use SecRule &ENV:allowed4 "@eq 0"                      "phase:~{Phase5Warn},t:none,id:4001007,tag:security,~{skipAfter}:AfterNoResponseBodyAccess"
 Use SecRule &ENV:be_cannot_compress "@eq 0"            "phase:~{Phase5Warn},t:none,id:4001007,tag:security,~{skipAfter}:AfterNoResponseBodyAccess"
 Use SecRule RESOURCE:invalidheader @unconditionalMatch "phase:~{Phase5Warn},t:none,id:4001007,tag:security,~{skipAfter}:AfterNoResponseBodyAccess"
  Use RuleLogOnceExt RESPONSE_HEADERS:Content-encoding  "~{ContentNeg_CompressedResponse}" "t:none" "~{responseWarn},setvar:TX.responseBody" "Compressed body from back-end (C-E=%{RESPONSE_HEADERS.Content-encoding}, noResponseBodyAccess=%{tx.noRespBodyAccess2}, resp_subst=%{tx.resp_subst}, be_cannot_compress=%{env.be_cannot_compress}, %{RESPONSE_PROTOCOL})" 4001007 "phase:~{Phase5Warn},tag:Output,tag:security" "%{env.WORKER_NAME}"
  <IfDefine EXTENDEDSTATUS>
   Use SecRule RESPONSE_HEADERS:Content-Encoding "~{ContentNeg_CompressedResponse}" "phase:~{Phase5Warn},id:4001007,tag:security,~{nosecaction},setenv:respBodyCompressedWarning"
  </IfDefine>
 Use SecMarker AfterNoResponseBodyAccess,tag:security
 # -----------------------------------------------------------------------------

 # mod_substitute removes the ETag header => enforce it
 Use SecRule RESPONSE_HEADERS:Etag @unconditionalMatch "phase:3,t:none,~{nosecaction},setenv:ETAG=%{MATCHED_VAR}"
 Header setifempty Etag "%{ETAG}e" env=ETAG

 # mod_deflate adds -gzip to ETags => remove them for back-end
 # As we overwrite Etag, add -gzip ourself if needed
 <IfModule mod_brotli.c>
  Header edit Etag "^([^\"].*)$"      "$1-br"     env=!no-brotli
  Header edit Etag "^\"([^\"]*)\"$" "\"$1-br\""   env=!no-brotli
  RequestHeader edit* If-None-Match "-br\b"  ""   env=!no-brotli
  RequestHeader edit* If-Match      "-br\b"  ""   env=!no-brotli
 </IfModule>
 <IfModule mod_deflate.c>
  Header edit Etag "^([^\"].*)$"      "$1-gzip"     env=!no-gzip
  Header edit Etag "^\"([^\"]*)\"$" "\"$1-gzip\""   env=!no-gzip
  RequestHeader edit* If-None-Match "-gzip\b"  ""   env=!no-gzip
  RequestHeader edit* If-Match      "-gzip\b"  ""   env=!no-gzip
 </IfModule>
 <IfModule mod_brotli.c>
 <IfModule mod_deflate.c>
  Header edit Etag "-br-gzip" "-br"   env=brotli_supported
  Header edit Etag "-br-gzip" "-gzip"
 </IfModule>
 </IfModule>

 # Additional message in case of \n
 Use SecRule ENV:AllowBackSlash "@eq 1" "id:4001001,phase:5,t:none,tag:security,tag:Command,tag:BackSlash,tag:JSON,~{skipAfter}:AfterBackSlashN"
 Use SecRule &TX:BackSlash      "@eq 0" "id:4001001,phase:5,t:none,tag:security,tag:Command,tag:BackSlash,tag:JSON,~{skipAfter}:AfterBackSlashN"
  Use SecRuleArgsCookies "\x5cn"           "4001001,phase:5,~{caseSensitive},tag:Command,tag:BackSlash,tag:JSON" "multiMatch,~{decreaseBlockCounter},~{warn},msg:'#NewLine# in ARG or cookie'"
 Use SecMarker AfterBackSlashN,tag:security,tag:Command,tag:BackSlash,tag:JSON

 # For locations where request body parsing is a known issue
 Use SecRule &ENV:IgnoreReqBodyParsingError "@eq 0" "phase:5,t:none,tag:internal,tag:security,~{skip}:1"
 Use SecRule REQBODY_ERROR "!@eq 0"                 "phase:5,t:none,tag:internal,~{warn},msg:'Known issue: Request parsing error'"

 # Log X.509 blocked requests
 <IfModule ssl_module>
  Use SecRule ENV:X509_USER_NOT_ALLOWED "@unconditionalMatch" "phase:5,tag:Auth,t:none,~{warn},msg:'X.509 authentication: unauthorised user <%{ENV.X509_USER_NOT_ALLOWED}>'"
 </IfModule>

 # Remove some binary content from logs --------------------------------------------------------------------

 # Request ---
 DefineStr skipLogC  "phase:5,t:none,~{skipAfter}:EndOfLogC"
 DefineStr NoLogC    "~{skipLogC},~{NoLogC_}"
 DefineStr LogI      "~{NoLogC},ctl:auditLogParts=+I"

 # Add JSON response for some errors (body was not buffered)
 # Why is STREAM_OUTPUT_BODY not populated?
 #Use SecRule RESPONSE_STATUS "^(?:40[03]|50[01])" "phase:5,t:none,tag:Status,chain,~{log},msg:'Error from application',logdata:%{TX.resp_body}"
  #Use SecRule RESPONSE_HEADERS:Content-Type "json|xml" t:none,chain
   #Use SecRule STREAM_OUTPUT_BODY "(.{1,500})" "t:none,capture,setvar:TX.resp_body=%{TX.1}"

 # Don't log bad content, but first check if it's really bad
 Use SecRule TX:json_detected|TX:xml_detected @unconditionalMatch "phase:5,~{skipAfter}:DontLogBadContent"
  Use SecRule &REQUEST_HEADERS:Content-Type  "@eq 0"              "~{NoLogC}"
  Use SecRule REQUEST_METHOD                 "^CHECKIN"           "~{NoLogC}"

  # Check if request is compressed
  Use SecRule TX:ReqCompressed               @unconditionalMatch  "~{NoLogC}"

  # Do not log except known text type
  Use SecRule REQUEST_HEADERS:Content-Type   "!^(?i)~{MimeText}"  "~{NoLogC}"

  # Do not log known text documents (ex: OpenText, CSV, etc.)
  Use SecRule REQUEST_HEADERS:Content-Type   "^(?i)~{MimeDoc}"    "~{NoLogC}"

  # Do not log compressed content
  Use SecRule REQUEST_HEADERS:Character-Encoding "\bbinary"                   "~{NoLogC},setvar:'TX.additionalInfo=(binary content not logged)'"
  Use SecRule REQUEST_HEADERS:Content-Encoding   "~{ContentNeg_CompressAll_}" "~{NoLogC},setvar:'TX.additionalInfo=(compressed content not logged)'"
 Use SecMarker DontLogBadContent

 # Check if XML needs to be sanitized
 Use SecRule ENV:req_xml @unconditionalMatch "phase:5,t:none,~{nosecaction},chain,tag:LowerThan"
  Use SecRule STREAM_INPUT_BODY "<(?:(?>[^/> ]+):)?(?i:%{TX.XmlSanArgs})"   "setvar:TX.SanLogC"
 Use SecRule TX:SanLogC  @unconditionalMatch  "~{NoLogC}"

 # Do not log too big request bodies (ARGS_COMBINED_SIZE contains "expanded" JSON names => check on real total size also)
 Use SecRuleIntComp_ TX:req_size ~{MaxReqSizeC} ",phase:5" ",t:none"
 Use SecRule TX:intcmp "!^gt"   "phase:5,t:none,~{skipAfter}:AfterReqSizeCheck"
  Use SecRuleIntComp_ ARGS_COMBINED_SIZE ~{MaxReqSizeC} ",phase:5" ",t:none"
  Use SecRule TX:intcmp "gt"   "t:none,~{NoLogC},setvar:'TX.additionalInfo=%{TX.invalidTarget} (too big content not logged)'"
 Use SecMarker AfterReqSizeCheck

 # multipart/form-data -------------------------
 Use SecRule REQUEST_HEADERS:Content-Type "!^multipart/form-data"  "~{skipAfter}:LogMultiPart"
  Use SecRule FILES_COMBINED_SIZE "^[^0]"                       "t:none,~{logI}"
  Use SecRule TX:uploadfname @unconditionalMatch                "t:none,~{logI}"
  #SecRule REQUEST_HEADERS:Content-Disposition "filename[*]?\s*+=" "t:none,~{logI}"

  # When files are combined with ARGS and are not recognised by ModSecurity ("Invalid Content-Disposition header")
  Use SecRule MULTIPART_STRICT_ERROR "@eq 1"   "phase:5,t:none,chain,~{nosecaction}"
    Use SecRule STREAM_INPUT_BODY "(?i)^.{1,200}content-disposition:[^\n\r]{0,50};\s*+name\s*+=\s*+\x22([^\x22]{1,100})\x22[^\n\r]{0,200};\s*+filename\s*+=" "chain,capture,t:none,tag:Dash,tag:Colon,tag:SemiColon,tag:Equal,tag:Quote"
     Use SecRule ARGS:%{TX.1} "@unconditionalMatch" "t:none,sanitiseMatched"
 Use SecMarker LogMultiPart

 Use SecMarker EndOfLogC

 # Response ---
 # Do not log compressed response
 DefineStr noLogE  "phase:5,t:none,ctl:auditLogParts=-E,~{skipAfter}:EndOfLog-E"
 Use SecRule RESPONSE_HEADERS:Content-Encoding "~{ContentNeg_CompressAll_}" "~{noLogE}"
 Use SecRule RESPONSE_CONTENT_LENGTH "@eq 0"                                "~{noLogE}"
 Use SecMarker EndOfLog-E

 # Skip contextual data if nothing logged
 <IfDefine !EXTENDEDSTATUS>
  Use SecRule HIGHEST_SEVERITY "@eq 255" "phase:5,chain,~{skipAfter}:AfterLogContext"
   Use SecRule &TX:heuristic "@eq 0" "t:none,chain"
    Use SecRule &TX:allowed1 "@eq 1" "t:none"
 </IfDefine>

 # Log begin & end of body when body not logged:
 Use SecRule TX:logReqBodyBegin "@unconditionalMatch" "phase:5,~{nosecaction},chain"
  Use SecRule STREAM_INPUT_BODY "^(.{1,30})" "t:none,capture,setvar:'TX.reqBody=Body begin:<%{TX.1}>'"
 Use SecRule TX:logReqBodyEnd   "@unconditionalMatch" "phase:5,~{nosecaction},chain"
  Use SecRule STREAM_INPUT_BODY "(.{1,30})$" "t:none,capture,setvar:'TX.reqBody=%{TX.reqBody}Body end:<%{TX.1}>'"
 Use SecRule TX:reqBody "@unconditionalMatch" "phase:5,t:none,~{responseWarn},msg:'*Partial request body logged'"

 Use SecRule &TX:responseBody "@eq 0" "phase:5,~{skipAfter}:AfterResponseBody"
  # logdata only logs 500 chars
  Use SecRule RESPONSE_BODY "\s*+(.{1,500})" "phase:5,t:none,capture,~{responseWarn},severity:INFO,msg:'*Response body logged',logdata:%{TX.1}"
 SecMarker AfterResponseBody
 
 Use SecAction                                "phase:5,~{nosecaction},auditlog,msg:Env,logdata:'*server: ~{ServerId}, *conf: ~{WAF_CONF_COMMON}/%{ENV.WAF_CONF_APP}/%{ENV.WAF_CONF_CUSTOM}',severity:INFO"

 Use SecRule TX:heuristic "!@eq 0"            "phase:5,~{nosecaction},t:none,setvar:'TX._reqdata=%{TX._reqdata}*heuristic=%{TX.heuristic}, ',tag:security"
 Use SecRule TX:sessionnb .                   "phase:5,~{nosecaction},t:none,setvar:'TX._reqdata=%{TX._reqdata}sessions=%{TX.sessionnb}, ',tag:security"
 Use SecRule TX:InvalidBytes .                "phase:5,~{nosecaction},t:none,t:base64encode,setvar:'TX._reqdata=%{TX._reqdata}InvalidBytes=<%{MATCHED_VAR}>, ',tag:security"
 <IfDefine EXTENDEDSTATUS>
  Use SecRule TX:SESSIONID "!^none$"          "phase:5,~{nosecaction},t:none,setvar:'TX._reqdata=%{TX._reqdata}sessionid=%{SESSIONID}, ',~{caseSensitive}"
 </IfDefine>
 Use SecRule env:WAF_USER .                   "phase:5,~{nosecaction},t:none,setvar:'TX._reqdata=%{TX._reqdata}user=<%{MATCHED_VAR}>, '"
 Use SecRule ENV:moidc401 .                   "phase:5,~{nosecaction},t:none,setvar:'TX._reqdata=%{TX._reqdata}moidc401=%{MATCHED_VAR}, '"
 Use SecRule ENV:backend  .                   "phase:5,~{nosecaction},t:none,setvar:'TX._reqdata=%{TX._reqdata}back-end=%{MATCHED_VAR}, '"
 Use SecRule TX:additionalInfo .              "phase:5,~{nosecaction},t:none,setvar:'TX._reqdata=%{TX._reqdata}<%{MATCHED_VAR}>, '"
 ###SecRule SESSION:blocked "!@eq 0"         "phase:5,~{nosecaction},t:none,setvar:'TX._reqdata=%{TX._reqdata}session_blocked=%{MATCHED_VAR}, ',tag:security"
 Use SecRule TX:sessionnb @unconditionalMatch "phase:5,~{nosecaction},t:none,setvar:'TX._reqdata=%{TX._reqdata}sessions=%{MATCHED_VAR}, ',tag:security"
 Use SecRule PERF_COMBINED "^(.*)...$" "phase:5,~{nosecaction},capture,setenv:perf=%{TX.1}"
 Use SecAction "phase:5,~{nosecaction},auditlog,msg:Request,logdata:'%{TX._reqdata}, sev=%{HIGHEST_SEVERITY}, Req. length=%{TX.req_size}, microsec=%{PERF_COMBINED}',severity:INFO"

 Use SecRule TX:url_arg "@gt 0" "phase:5,tag:security,t:none,~{nosecaction},auditlog,msg:URL,logdata:'URL after parsing: %{TX.url}',severity:INFO"

 Use SecAction "phase:5,~{nosecaction},setvar:IP.TIMEOUT=~{ip_timeout},expirevar:IP.KEY=~{block_timeout}"
 Use SecRule IP:blocked    "!@eq 0" "phase:5,tag:security,~{nosecaction},t:none,setvar:'TX._ipdata=%{TX._ipdata}, blocked=%{MATCHED_VAR}',expirevar:IP.blocked=~{block_timeout}"
 Use SecRule IP:dos        "!@eq 0" "phase:5,tag:security,~{nosecaction},t:none,setvar:'TX._ipdata=%{TX._ipdata}, DoS=%{MATCHED_VAR}',setvar:IP.dos=%{MATCHED_VAR},expirevar:IP.dos=~{block_timeout}"
 Use SecRule IP:BadAuth    "!@eq 0" "phase:5,tag:security,~{nosecaction},t:none,setvar:'TX._ipdata=%{TX._ipdata}, Auth=%{MATCHED_VAR}',setvar:IP.BadAuth=%{MATCHED_VAR},expirevar:IP.BadAuth=~{block_timeout}"
 Use SecRule IP:LastUser          . "phase:5,tag:security,~{nosecaction},t:none,setvar:'TX._ipdata=%{TX._ipdata}, LastUser=<%{MATCHED_VAR}>',expirevar:IP.LastUser=~{block_timeout}"
 Use SecRule ENV:geo_country_name . "phase:5,tag:security,~{nosecaction},t:none,setvar:'TX._ipdata=%{TX._ipdata}, Loc=<%{ENV.geo_country_name}/%{ENV.geo_city}>'"

 # Restore original value of attack counter (in case it was modified during detection)
 Use SecAction  "phase:5,tag:security,~{nosecaction}"

 <IfDefine Throttling>
  # Fake change to update counter update_rate => screw up deprecatevar
  # (counters don't decrease when requests continue to arrive)
  Use SecAction "phase:5,~{nosecaction},tag:security,setvar:IP.IS_NEW=+0,setvar:'TX._ipdata=%{TX._ipdata}, connect#=%{IP.UPDATE_COUNTER}, connect.rate=%{IP.UPDATE_RATE}/min'"
 </IfDefine>
 Use SecAction "phase:5,tag:security,~{nosecaction},auditlog,msg:IP,logdata:'*IP=<%{TX.remote_addr}>%{TX._ipdata}',severity:INFO"
 Use SecMarker AfterLogContext

 # Log invalid response headers only once (don't differentiate between applications)
 Use SecRule RESPONSE_HEADERS_NAMES:/^(?i)x-/ "!^(?i)x-(?:~{IgnoredResponseHeaders_}|~{IgnoredResponseHeaders}|%{TX.AllowXHeader})$" "phase:~{Phase5Warn},chain,t:none,id:4001006,tag:OutputHeader,tag:security,~{warn},~{denyOnNextLine},msg:'Unknown header sent by back-end <%{MATCHED_VAR}> -> unset it or allow (Use AllowResponseXHeader, DefineStr IgnoredResponseHeaders)'"
  Use SecRule MATCHED_VARS "!@within %{GLOBAL.unknownResponseHeader}" "setvar:'GLOBAL.unknownResponseHeader=%{MATCHED_VAR},%{GLOBAL.unknownResponseHeader}',~{denySetEnv},~{noIncreaseBlockCounter}"
</Location>
