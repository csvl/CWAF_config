# ModSecurity rules for HTTP protocol compliance and policy
# Range: 2002900-2002999
# ---------------------------------------------------------------

DefineStr ArgsNamesXml_ "ARGS_NAMES"
<IfDefine XMLParsing>
 DefineStr ArgsNamesXml_ "ARGS_NAMES|XML:/*"
</IfDefine>

# Validate request line
Use SecRuleDeny REQUEST_LINE "!(?i)^(?:(?:[a-z]{3,10}\s+(?:\w{3,7}?://[\w./-]*(?::\d+)?)?/[^?#]*(?:[?][^#\s]*)?(?:#[\S]*)?|connect (?:\d{1,3}[.]){3}\d{1,3}[.]?(?::\d+)?|options \*)\s+[\w./]+|get /[^?#]*(?:\?[^#\s]*)?(?:#[\S]*)?)$" \
    "phase:1,t:none,~{status404},id:2002944,msg:'Invalid HTTP Request Line'"

# URI --------------------------------------------------------------------------
SecRule REQUEST_LINE "^OPTIONS [*]$"    "phase:1,t:none,id:2002943,tag:Protocol,tag:security,~{skipAfter}:AfterNoSlashInUrl"
 Use SecRuleDeny REQUEST_URI_RAW "!^/"  "phase:1,t:none,id:2002943,tag:Protocol,status:505,~{drop},msg:'Invalid URI',tag:noreport2"
SecMarker AfterNoSlashInUrl,tag:security,tag:Protocol

# Validate raw characters of URL (others will be validated after decoding)
Use SecRuleDeny REQUEST_URI_RAW "([\x00-\x20#<>\x7f]+)"   "phase:1,id:2002926,t:none,~{status404},msg:'Bad character in URL',logdata:'<%{MATCHED_VAR_NAME}=%{MATCHED_VAR}',tag:URL"

# Validate URL encoding of URL (query is also validated after with URLENCODED_ERROR)
###Use SecRuleDeny REQUEST_URI_RAW "@validateUrlEncoding"   "phase:1,id:2002901,t:none,~{status404},msg:'Bad URL Encoding',tag:URL"

# Validate URL encoding (body & query), except for JSON (in case it was forced)
SecRule ENV:req_json      "@gt 0" "phase:2,t:none,id:2002902,tag:security,tag:HEUR,tag:Protocol,~{skipAfter}:AfterUrlEncodeError"
 SecRule URLENCODED_ERROR "@eq 1" "phase:2,t:none,id:2002902,tag:security,tag:HEUR,tag:Protocol,~{log},setvar:tx.heuristic=+1,msg:'Invalid URL encoding of data (heuristic)',severity:WARNING"
SecMarker AfterUrlEncodeError,tag:security,tag:HEUR,tag:Protocol

# Disallow use of full/half-width unicode
DefineStr FWUnicodePattern  "(?i)%uff[0-9a-f]{2}"
DefineStr FWUnicodeAction   "phase:2,t:none,~{deny},~{increaseBlockCounter},msg:'Unicode Full/Half Width'"
SecRule REQUEST_URI_RAW  "~{FWUnicodePattern}" "~{FWUnicodeAction},id:2002903,tag:Protocol,tag:URL"
# False positive: %ef may be last byte of previous char & %bc first byte of next char
#SecRule REQUEST_URI_RAW|REQUEST_HEADERS|!REQUEST_HEADERS:/OIDC_/|ARGS|~{ArgsNamesXml_}|!REQUEST_HEADERS:Referer "%ef%bc" "phase:2,t:none,~{deny},msg:'Unicode Full/Half Width',setvar:TX.heuristic=+2,~{noIncreaseBlockCounter},tag:HEUR,tag:Protocol"

# Disallow use of extended Microsoft specific Unicode
DefineStr MSUnicodePattern  "(?i)%u[0-9a-f]{4}"
DefineStr MSUnicodeAction   "~{FWUnicodeAction},msg:'Microsoft proprietary Unicode'"
SecRule REQUEST_URI_RAW  "~{MSUnicodePattern}" "id:2002934,~{MSUnicodeAction},tag:URL,tag:Protocol"
 
# Double slash in URL (sometimes bad URL in some apps & fixed by Apache => to ignore?)
Use SecRuleDeny TX:url "//"   "phase:2,id:2002917,t:none,~{status404},msg:'// in URL',tag:URL,tag:Parano,tag:noreport2"

# Headers ----------------------------------------------------------------------
# Disallow use of full/half-width unicode
SecRule REQUEST_HEADERS|~{ArgsNamesXml_}  "~{FWUnicodePattern}" "~{FWUnicodeAction},id:2002931,tag:Protocol"

# Disallow use of extended Microsoft specific Unicode
SecRule REQUEST_HEADERS|~{ArgsNamesXml_}  "~{MSUnicodePattern}" "id:2002935,~{MSUnicodeAction},tag:Protocol,tag:Percent"

# Response headers only
Use InvalidRequestHeader /^(?i:Age|ETag|Location|Proxy-Authenticate|Refresh|Retry-After|Server|Set-Cookie|Trailer|Vary|Warning|WWW-Authenticate)$/

# Headers only used by applications like WebDAV, etc.
Use InvalidRequestHeader_ "/^(?:Allow|Content-(?:Language|Location|MD5|Range)|Last-Modified)$/" "id:2002913,msg:'Content Entity header',logdata:%{MATCHED_VAR}"

# Body -------------------------------------------------------------------------
# Validate URL encoding of body
Use SecRule REQUEST_HEADERS:Content-Type "!(?i)^application/x-www-form-urlencoded" "phase:2,t:none,tag:security,~{skip}:1"
Use SecRuleDeny REQUEST_BODY "@validateUrlEncoding"                                "phase:2,t:none,msg:'Bad URL Encoding of body'"

# Disallow use of full/half-width unicode
SecRule ARGS            "~{FWUnicodePattern}" "~{FWUnicodeAction},id:2002919,tag:Protocol,tag:ARGS"
###SecRule REQUEST_BODY "~{FWUnicodePattern}" "~{FWUnicodeAction},id:2002919,tag:Protocol,tag:ARGS"

# Disallow use of extended Microsoft specific Unicode
SecRule ARGS            "~{MSUnicodePattern}" "id:2002936,~{MSUnicodeAction},tag:ARGS,tag:Protocol,tag:Percent"
###SecRule REQUEST_BODY "~{MSUnicodePattern}" "id:2002936,~{MSUnicodeAction},tag:ARGS,tag:Protocol,tag:Percent"

# Check UTF-8 encoding
#  - if the client set the charset to UTF-8
#  - if the server uses UTF-8 encoding (Use UTF8Encoding ...)
SecRule REQUEST_HEADERS:Content-Type "(?i)charset=['\x22]?utf-8" "phase:1,t:none,tag:Equal,~{nosecaction},setvar:TX.UTF8_ENCODING_USED"
SecRule &TX:UTF8_ENCODING_USED "@eq 0" "phase:2,id:2002945,t:none,tag:security,~{skipAfter}:AfterUtf8Encoding"
 Use SecRuleDeny REQUEST_URI_RAW|ARGS_NAMES "@validateUtf8Encoding" "phase:2,id:2002945,t:none,~{status}:400,msg:'Bad UTF8 Encoding in <%{MATCHED_VAR_NAME}>'"
 # JSON parser already validates UTF-8 encoding
 SecRule ENV:req_json @unconditionalMatch                           "phase:2,id:2002945,t:none,tag:security,~{skipAfter}:AfterUtf8Encoding"
  Use SecRuleDeny ARGS                      "@validateUtf8Encoding" "phase:2,id:2002945,t:none,~{status}:400,msg:'Bad UTF8 Encoding in <%{MATCHED_VAR_NAME}>'"
SecMarker AfterUtf8Encoding,tag:security

# Detect locations not protected with previous rule
SecRule RESPONSE_STATUS "!^20[0-35-9]"                                    "phase:~{Phase5Warn},t:none,id:2002912,tag:security,~{skipAfter}:AfterNoMixedEncoding"
SecRule RESPONSE_HEADERS:Content-Type "!text/html|application/xhtml+xml;" "phase:~{Phase5Warn},t:none,id:2002912,tag:security,~{skipAfter}:AfterNoMixedEncoding"
SecRule RESOURCE:invalidheader "@gt 0"                                    "phase:~{Phase5Warn},t:none,id:2002912,tag:security,~{skipAfter}:AfterNoMixedEncoding"
SecRule TX:UTF8_ENCODING_USED  @unconditionalMatch                        "phase:~{Phase5Warn},t:none,id:2002912,tag:security,~{skipAfter}:AfterNoUtf8"
 SecRule RESPONSE_HEADERS:Content-Type "(?i)charset=['\x22]?utf-8"        "phase:~{Phase5Warn},t:none,id:2002912,tag:security,~{skipAfter}:AfterNoUtf8,~{warnalso},msg:'Application uses UTF-8, must protect with [Use UTF8Encoding] (or disable with [Use MixedEncoding])',initcol:RESOURCE=url_%{TX.hash_url},setvar:RESOURCE.invalidheader"
SecMarker AfterNoUtf8,tag:security

# Detect locations with mixed encoding
SecRule TX:UTF8_ENCODING_USED "!@eq 1"                                     "phase:~{Phase5Warn},t:none,id:2002912,tag:security,~{skipAfter}:AfterNoMixedEncoding"
 SecRule RESPONSE_HEADERS:Content-Type "(?i)charset *= *['\x22]?(?!utf-8)" "phase:~{Phase5Warn},t:none,id:2002912,~{responseWarn},msg:'Application uses mixed encoding, remove <Use UTF8Encoding> and add <Use MixedEncoding>)',initcol:RESOURCE=url_%{TX.hash_url},setvar:RESOURCE.invalidheader"
SecMarker AfterNoMixedEncoding,tag:security
# ----------------------------------------------------------------------------

# Content-Disposition header only used by SOAP (client-side)
SecRule REQUEST_HEADERS:Content-Type "^(?:~{MimeJSON}|~{MimeSOAP})" "phase:2,t:none,tag:security,~{skipAfter}:AfterInvalidContentDisposition"
 Use InvalidRequestHeader Content-Disposition
SecMarker AfterInvalidContentDisposition,tag:security
Use SecRuleHeader Content-Disposition "(?i)\bname\s*+=.*;\s*+name\s*+=" "t:none,~{status}:400,tag:Protocol,msg:'Content-Disposition header: name=...; name='"
# Sanitise but do not block some headers
# Warning: ; is needed by some frameworks (to check browser versions)
<Macro SanitiseRequestHeader $header>
 RequestHeader edit* $header "[\x00-\x1f\x21\x22-\x27\x2a\x2b\x3c-\x3f\x5b-\x60\x7b-\xff]" " " early
</Macro>
Use SanitiseRequestHeader from
Use SanitiseRequestHeader group
Use SanitiseRequestHeader uname
Use SanitiseRequestHeader user
Use SanitiseRequestHeader User-Agent
Use SanitiseRequestHeader Via
# Fix Firefox bug
RequestHeader edit Accept "chrome://global/locale/intl.properties[^,]*" "x" early

# Restricted HTTP headers 
SecRule REQUEST_METHOD "^(?:(?:UN)?LOCK|PROPPATCH|PUT)"    "phase:1,id:2002946,t:none,tag:security,~{skipAfter}:AfterInvalidHeaderIL"
 Use SecRuleDeny REQUEST_HEADERS_NAMES "(?i)^(lock-token|if)$" "phase:1,id:2002946,t:none,~{drop},msg:'HTTP header <%{TX.1}>is restricted by policy'"
SecMarker AfterInvalidHeaderIL,tag:security

# Only accept HTTP 1.0 & 1.1 (0.9 exists but should never been used)
# Remark: proxies (ex: ISA) sometimes send requests "GET /" without the protocol
#         (HTTP 0.9 Simple-Request)
#SecRule REQUEST_LINE "^GET /$"             "phase:1,t:none,setvar:TX.noblock=1,~{stopStatus}:505,~{increaseBlockCounter},tag:Protocol"
#SecRule REQUEST_PROTOCOL "^RSTP/[0-9.]+$"  "phase:1,t:none,status:505,~{drop},~{increaseBlockCounter},tag:Protocol,tag:Slash,msg:'RSTP protocol not supported'"
#SecRule REQUEST_PROTOCOL "^SIP/[0-9.]+$"   "phase:1,t:none,status:505,~{drop},~{increaseBlockCounter},tag:Protocol,tag:Slash,msg:'SIP protocol not supported'"
# No "drop" to disable fingerprinting
Use SecRuleDeny REQUEST_PROTOCOL "!~{ProtocolsRegex}"  "phase:1,id:2002932,t:none,~{status}:505,tag:Protocol,msg:'Invalid protocol'"

# Accept only digits in content length 
Use SecRuleHeader Content-Length "!^\d{1,13}$" "phase:1,t:none,~{drop},tag:Protocol,msg:'Invalid header Content-Length (not numeric or too long)'"
Use SecRuleHeader Content-Length "^0."         "phase:1,t:none,tag:Protocol,msg:'Invalid header Content-Length (0...)'"

# Require Content-Length to be provided with every POST/PUT request.
SecRule REQUEST_HEADERS:Transfer-Encoding "^chunked$"  "phase:1,id:2002947,t:none,tag:Protocol,tag:security,~{skipAfter}:AfterCTPost"
 SecRule &REQUEST_HEADERS:Content-Length "@eq 1"       "phase:1,id:2002947,t:none,tag:Protocol,tag:security,~{skipAfter}:AfterCTPost"
  SecRule REQUEST_METHOD  "^(?:POST|PUT)"              "phase:1,id:2002947,t:none,tag:Protocol,~{increaseBlockCounter},~{status}:411,msg:'POST/PUT request must have a Content-Length header'"
SecMarker AfterCTPost,tag:security,tag:Protocol

# Do not accept GET or HEAD requests with bodies, except for Sharepoint & JSON
# HTTP standard allows GET requests to have a body but this feature is not used in real life.
# Also, ctl:ruleRemoveById=2000021 that checks ARGS_NAMES for JSON requests
# (ModSecurity does not parse it as names for POST)
SecRule REQUEST_METHOD  "!^(?:GET|HEAD|OPTIONS)$"  "phase:1,t:none,tag:security,~{skipAfter}:EndOfGetBodyCheck"
SecRule REQUEST_METHOD  "^GET"  "phase:1,chain,t:none,tag:security,~{skipAfter}:EndOfGetBodyCheck,msg:'For Sharepoint'"
 SecRule REQUEST_HEADERS:X-Vermeer-Content-Type  @unconditionalMatch  "t:none"
SecRule ENV:req_ajax "@unconditionalMatch" "phase:1,t:none,tag:security,~{skipAfter}:EndOfGetBodyCheck,msg:'For JSON/XML',ctl:ruleRemoveById=2000021"
 Use SecRuleHeader Content-Length "!^0?$"       "phase:1,t:none,id:2002952,~{drop},tag:Protocol,msg:'GET/HEAD/OPTIONS request with body'"
 Use SecRuleHeader Transfer-Encoding "chunked"  "phase:1,t:none,id:2002916,~{drop},tag:Protocol,msg:'GET/HEAD/OPTIONS request with body'"
SecMarker EndOfGetBodyCheck,tag:security

# Expect header is an HTTP/1.1 protocol feature
SecRule REQUEST_PROTOCOL "!^HTTP/1.0$"                      "phase:1,id:2002948,tag:Protocol,tag:security,t:none,~{skipAfter}:After100Continue"
 Use SecRuleDeny REQUEST_HEADERS:Expect "(?i)^100-continue" "phase:1,id:2002948,tag:Protocol,t:none,~{status}:417,msg:'Expect Header not allowed in HTTP 1.0'"
SecMarker After100Continue,tag:security,tag:Protocol

# Check host header syntax
# Ignore checks in case of a front-end (as host are registered)
SecRule &REQUEST_HEADERS:Host  "!@eq 1"               "phase:1,t:none,id:2002937,~{increaseBlockCounterMax},~{drop},msg:'No or multiple header Host',tag:Protocol,tag:noreport1"
SecRule  REQUEST_HEADERS:Host  "(?i)^(?:localhost)?$" "phase:1,t:none,id:2002938,~{increaseBlockCounterMax},~{drop},msg:'Header Host empty or equals <localhost>',tag:Protocol,tag:noreport1"
SecRule REMOTE_ADDR "~{RP_IP_Check}"                         "phase:1,t:none,id:2002949,~{skipAfter}:AfterCheckHostHeader"
 Use SecRuleHeader Host "^[0-9.:]+$"                         "phase:1,t:none,id:2002949,~{drop},msg:'Host = IP address',tag:Protocol,tag:noreport1"
 Use SecRuleHeader Host "!^[-[:alnum:]._]+(?::[0-9]{1,8})?$" "phase:1,t:none,id:2002949,~{drop},msg:'Bad host syntax',tag:Protocol,tag:noreport2"
SecMarker AfterCheckHostHeader,tag:security

# Check Basic/Digest Authentication format
# Oulook sometimes send "Bearer" without token ...
Use CustomAuthHeader "^(?i:Basic |Bearer(?: |$)|Digest username=\x22|Kerberos |Negotiate |NTLM )"
SecRule REQUEST_HEADERS:Authorization  "^(?i:Negotiate TlR|NTLM)" "phase:1,t:none,~{nosecaction},msg:'Warning: Client uses NTLM/Negotiate authentication (unsupported via a reverse proxy)'"

# Check Basic Authentication format -> block without sending the realm -> no userid/password box
# Ignore empty userid/password
SecRule REQUEST_HEADERS:Authorization  "(?i)^Basic Og==$"   "phase:1,t:none,tag:Auth,tag:security,tag:Equal,~{skipAfter}:AfterBasicAuthUser"
SecRule &ENV:WAF_USER "@gt 0"                               "phase:1,t:none,tag:Auth,tag:security,~{skipAfter}:AfterBasicAuthUser"
 SecRule REQUEST_HEADERS:Authorization "(?i)^Basic"         "phase:1,t:none,tag:Auth,~{status}:401,~{increaseAuthCounter},msg:'Invalid Basic Authentication (userid cannot be extracted)'"
SecMarker AfterBasicAuthUser,tag:security,tag:Auth

# Invalid IP ranges
Use SecRuleIp "^2(?:2[4-9]|[3-9][0-9])[.]"  "phase:1,t:none,~{drop},msg:'Invalid address (range D/E)'"

Use SecRuleHeader Connection "!(?i)^[a-z0-9-]+(?:\s*+,\s*+[a-z0-9-]+)*$"     "phase:1,t:none,tag:Protocol,tag:Comma,~{status}:400,msg:'Connection Header: invalid syntax',id:2002940"
Use SecRuleHeader HTTPS "!^1$"                                             "phase:1,t:none,tag:Protocol,~{status}:400,msg:'Invalid header <HTTPS>',id:2002953"
# Normally also \x80-\xff
DefineStr EtagValue "(?:\x22[!\x23-\x7e]*\x22(?:-br|-gzip)?)"
Use SecRuleHeader If-None-Match "!^(?:[*]|(?:W/)?~{EtagValue}(?: *, *~{EtagValue})*)$" "phase:1,t:none,tag:Protocol,~{status}:400,msg:'Invalid header <If-None-Match>',~{caseSensitive}"
Use SecRuleHeader Max-Forwards  "!^[0-9]*$"                                            "phase:1,t:none,tag:Protocol,~{status}:400,msg:'Invalid header <Max-Forwards>'"
Use SecRuleHeader Timeout "!^(i?:Infinite|Second-[0-9]{1,10})$"                        "phase:1,t:none,tag:Protocol,~{status}:400,msg:'Invalid header <Timeout>'"
Use SecRuleHeader Upgrade-Insecure-Requests  "!^1$"                                    "phase:1,t:none,tag:Protocol,~{status}:400,msg:'Invalid header <Upgrade-Insecure-Requests>'"

Use SecRuleDeny REQUEST_HEADERS_NAMES|!REQUEST_HEADERS_NAMES:/^~+$/ "!^[~{CharMin}]+$" "t:none,~{status}:400,id:2002924,msg:'Invalid character in header name'"

# Broken/Malicous clients often have duplicate or conflicting headers
Use SecRule REQUEST_HEADERS:Connection "!(?i)close"       "phase:2,t:none,id:2002941,tag:Protocol,tag:security,~{skipAfter}:AfterCloseTE"
 Use SecRuleHeader Connection "!(?i)^(?:[ ,]|close|TE)+$" "t:none,id:2002941,tag:Protocol,~{status}:400,msg:'Connection Header: {close} must be alone (HTTP standard)'"
SecMarker AfterCloseTE,tag:security,tag:Protocol

# Allow only "normal" characters in URI
Use SecUrlAllowChars        ""
# '+' is decoded as a space => dedicated rule
SecRule TX:url "[+]"  "phase:2,t:none,~{status404},~{increaseBlockCounter},id:2002921,msg:'character + in URL (Use SecUrlAllowPlus/SecAllowPlusInUpDownDocs and allow space in URL)',tag:Protocol"

# No query string in POST
SecRule &ARGS_GET_NAMES "@eq 0"    "phase:2,t:none,id:2002923,tag:security,~{skipAfter}:AfterQueryInPost"
 SecRule REQUEST_METHOD  "^POST$"  "phase:2,t:none,id:2002923,~{deny},~{increaseBlockCounter},msg:'Query parameter in a POST (enable with SecAllowQueryInPost)',tag:Protocol"
SecMarker AfterQueryInPost,tag:security

SecRule REQUEST_HEADERS:Keep-Alive  "!^[~{CharNormal}]*$"  "phase:1,~{log},tag:security,t:none,msg:'Possible invalid character in header <Keep-Alive>',tag:HEUR,tag:Protocol"
Use CheckHeaderIp "/^(?i:X-(?:Forwarded-For|Real-IP)|~{IPAddressHeader})$/"

Use SecRule REQUEST_HEADERS:Origin "^chrome-extension:" "phase:2,t:none,tag:Ignore,~{status404},msg:'Invalid syntax in Origin header (chrome extension)'"

Use ValidateReferer ""

# Check Referer same as Origin
# When loading a CSS from another site and this one loads a resource from this site, they are different
SecRule &REQUEST_HEADERS:Referer "@eq 0"  "phase:2,id:2002954,t:none,tag:security,tag:protocol,~{skipAfter}:AfterRefOrig"
SecRule &REQUEST_HEADERS:Origin  "@eq 0"  "phase:2,id:2002954,t:none,tag:security,tag:protocol,~{skipAfter}:AfterRefOrig"
SecRule  REQUEST_HEADERS:Referer "^$"     "phase:2,id:2002954,t:none,tag:security,tag:protocol,~{skipAfter}:AfterRefOrig"
SecRule  REQUEST_HEADERS:Origin  "^null$" "phase:2,id:2002954,t:none,tag:security,tag:protocol,~{skipAfter}:AfterRefOrig"
 Use SecRuleDeny REQUEST_HEADERS:Referer "!^%{REQUEST_HEADERS.Origin}(?:/|$)" "phase:2,id:2002954,t:none,tag:protocol,msg:'Header Origin & Referer not consistent'"
 SecAction                                "phase:2,id:2002954,tag:security,tag:protocol,~{skipAfter}:AfterOrigin"
SecMarker AfterRefOrig,tag:security,tag:protocol

Use SecRuleDeny REQUEST_HEADERS:Origin "!^(?:null|(?:android-app|https?)://~{syntax_URL_host})?$" "phase:2,t:none,tag:Protocol,~{status}:400,~{testRule},rev:20230620,msg:'Invalid syntax in Origin header'"
SecMarker AfterOrigin,tag:security,tag:protocol

# Warning: some browsers (IE6) add "; length=xxx"
Use SecRuleDeny "~{ReqHeaders}|!REQUEST_HEADERS:/^(?i)Sec-CH-/" "!^[~{CharNormal}]*$"     "phase:2,t:none,~{status}:400,id:2002930,msg:'Invalid character in (raw) header <%{MATCHED_VAR_NAME}>',tag:SecRuleHeaders"
Use SecRuleDeny "REQUEST_HEADERS:/^(?i)Sec-CH-/"                "!^[~{CharNormal}\x5c]*$" "phase:2,t:none,~{status}:400,id:2002939,msg:'Invalid character in (raw) header <%{MATCHED_VAR_NAME}>'"

Use SecRuleHeader /^If-(?:Un)?modified-Since$/  "!^[ ,:;=~{CharMin}]*$"  "phase:1,t:none,tag:Protocol,msg:'Invalid header <%{MATCHED_VAR_NAME}>'"

# Content-Type -----------------------------------------------------------------
# Only known Content-Type is allowed but with wildcards. This also checks parameters
# Phase 2 because disabled in Sharepoint
Use SecRuleHeader Content-Type "!^[~{CharNormal}@]*$" "phase:2,t:none,tag:Protocol,tag:ProtoCT,msg:'Invalid character in header <Content-Type>'"
Use SecRule REQUEST_HEADERS:Content-Type "^[ ;]*$"    "phase:2,t:none,tag:Protocol,tag:ProtoCT,tag:security,~{skip}:1,setenv:CTempty"
Use SecRuleHeader Content-Type "!~{CT_Full}"          "phase:2,t:none,tag:Protocol,tag:ProtoCT,msg:'Invalid syntax in header <Content-Type>'"
# Parameter "action" only allowed for SOAP
# Parameter "profile" only allowed for JSON
# Parameter "codecs[*]?" & "profiles[*]?" only allowed for multimedia
Use SecRule REQUEST_HEADERS:Content-Type "~{MimeMultiMedia}" "phase:2,t:none,tag:security,~{skip}:1"
 Use SecRuleHeader Content-Type "(codecs|profiles)[*]?=" "phase:2,t:none,tag:Protocol,tag:ProtoCT,msg:'Parameter <%{TX.1}> in Content-Type is only allowed for multimedia',capture"
Use SecRule ENV:req_json @unconditionalMatch "phase:2,t:none,tag:security,~{skip}:1"
 Use SecRuleHeader Content-Type "action="    "phase:2,t:none,tag:Protocol,tag:ProtoCT,msg:'Parameter <action> in Content-Type is only allowed in SOAP'"
Use SecRule ENV:req_xml  @unconditionalMatch "phase:2,t:none,tag:security,~{skip}:1"
 Use SecRuleHeader Content-Type "profile="   "phase:2,t:none,tag:Protocol,tag:ProtoCT,msg:'Parameter <profile> in Content-Type is only allowed in JSON'"

Use HeaderLimitedChars 2002927,tag:SecRuleHeaders "~{ReqHeaders}|!REQUEST_HEADERS:Location|!REQUEST_HEADERS:Destination|!REQUEST_HEADERS:Keep-Alive|!REQUEST_HEADERS:Cookie|!REQUEST_HEADERS:Referer"
Use HeaderLimitedChars 2002928                    REQUEST_HEADERS:Location
Use HeaderLimitedChars 2002929                    REQUEST_HEADERS:Destination

Use SecRuleHeader Depth "!^(?:0|1|infinity)?$"  "phase:1,t:none,~{increaseBlockCounterMax},tag:Protocol,msg:'Invalid Depth header'"
Use SecRuleHeader DNT   "!^(?:0|1)?$"           "phase:1,t:none,~{increaseBlockCounterMax},tag:Protocol,msg:'Invalid DNT header'"

# Only usual characters in cookie name & content
Use SecCookieNameAllowCharacter ""
Use SecCookiesAllowCharset ""
#Use SecRuleDeny ~{ReqHeaders} "!^[~{CharNormal}]+$"  phase:1,t:none,tag:SecRuleHeaders

# Only usual characters in argument name
Use SecArgNameAllowCharacter ""

# Disallow empty argument name, unless content is also empty
# Sometimes, PUT contains a JSON array with only values
SecRule "ARGS:''" "^$"        "phase:2,id:2002904,t:none,tag:Protocol,tag:security,~{skipAfter}:AfterEmptyArgName"
SecRule env:req_json "@gt 0"  "phase:2,id:2002904,t:none,tag:Protocol,tag:security,~{skipAfter}:AfterEmptyArgName"
 SecRule ARGS_NAMES "^$"      "phase:2,id:2002904,t:none,tag:Protocol,~{deny},~{increaseBlockCounter},msg:'Argument name empty'"
SecMarker AfterEmptyArgName,tag:security

# PHP ignores spaces before arg name
Use SecRuleDeny ARGS_NAMES "^ "    "id:2002905,tag:Protocol,t:none,msg:'Space before arg name (possible PHP hack)'"

# Check From: header syntax (e-mail address)
# This is set to non-email values by some robots and by some proxies
#Use SecRuleHeader From  "!^[\w-.]+(?:[(]at[)]|@)[\w-.]+$" "phase:1,t:none,msg:'Incorrect e-mail address syntax in HTTP header <From:>',tag:Protocol"


# Request containing Content, but Missing Content-Type header
SecRule TX:req_size    "@eq 0"     "phase:2,id:2002922,t:none,tag:security,~{skipAfter}:AfterCheckCT,setvar:TX.allow_ContentType"
SecRule REQUEST_METHOD "^PATCH" "phase:2,id:2002922,t:none,tag:security,~{skipAfter}:AfterCheckCT,setvar:TX.allow_ContentType"
 Use SecRuleDeny &REQUEST_HEADERS:Content-Type   "@eq 0" "phase:2,id:2002922,t:none,~{status}:400,msg:'Request Containing Content, but Missing Content-Type header',ctl:auditLogParts=-CG"
 Use SecRuleDeny REQUEST_HEADERS:Content-Type   "^\s*+$"  "phase:2,id:2002922,t:none,~{status}:400,msg:'Request Containing Content, but Missing Content-Type header',ctl:auditLogParts=-CG"
SecMarker AfterCheckCT,tag:security

DefineStr TE_Values "(?:~{ContentNeg_CompressedResponse}|trailers)"
Use SecRuleHeader TE "!^(?:~{TE_Values}(?: *, *~{TE_Values})*~{ContentNeg_Q})?$"                                      "phase:1,id:2002942,t:none,~{drop},tag:Protocol,msg:'TE header incorrect'"
Use SecRuleHeader "/(?i)(?:grpc-)?Accept-Encoding/"  "!^(?:~{ContentNeg_CompressAccepted}~{ContentNeg_Q}(?: *, *~{ContentNeg_CompressAccepted}~{ContentNeg_Q})*)?$" "phase:1,id:2002950,t:none,~{drop},tag:Protocol,msg:'Accept-Encoding header incorrect'"
Use SecRule &REQUEST_HEADERS:Content-Encoding "@eq 0" "phase:1,t:none,tag:security,tag:Protocol,~{skipAfter}:AfterContentEncoding"
 Use SecRuleHeader Content-Encoding "!^(?:~{ContentNeg_CompressSupported}(?: *, *~{ContentNeg_CompressSupported})*)?$" "phase:1,id:2002925,t:none,~{drop},tag:Protocol,msg:'Content-Encoding header: invalid syntax'"

 # Do not allow compressed content (can be disabled with Use AllowCompressedRequest)
 Use SecRuleHeader Content-Encoding "~{ContentNeg_CompressAll_}" "phase:1,t:none,id:2002920,tag:Protocol,~{status}:406,msg:'Compressed request is not accepted (allow with Use AllowCompressedRequest)'"
 Use SecRuleHeader Content-Encoding "^."                         "phase:1,t:none,id:2002918,tag:Protocol,~{status}:406,msg:'Content-Encoding header provided',~{testRule},rev:20240402"
Use SecMarker AfterContentEncoding,tag:security,tag:Protocol

Use SecRuleDeny MULTIPART_BOUNDARY_WHITESPACE    "!@eq 0" "t:none,id:2002908,~{status}:400,msg:'Multipart request error: boundary white space',ctl:auditLogParts=+I,setvar:TX.logReqBodyBegin"
Use SecRuleDeny MULTIPART_DATA_BEFORE            "!@eq 0" "t:none,id:2002909,~{status}:400,msg:'Multipart request error: data before',ctl:auditLogParts=+I,setvar:TX.logReqBodyBegin"
Use SecRuleDeny MULTIPART_DATA_AFTER             "!@eq 0" "t:none,id:2002910,~{status}:400,msg:'Multipart request error: data after',ctl:auditLogParts=+I,setvar:TX.logReqBodyEnd"
Use SecRuleDeny MULTIPART_INVALID_HEADER_FOLDING "!@eq 0" "t:none,id:2002911,~{status}:400,msg:'Multipart request error: invalid header folding',ctl:auditLogParts=+I"
Use SecRuleDeny MULTIPART_HEADER_FOLDING         "!@eq 0" "t:none,id:2002907,~{status}:400,msg:'Multipart request error: header folding',ctl:auditLogParts=+I"
Use SecRuleDeny MULTIPART_CRLF_LF_LINES          "!@eq 0" "t:none,id:2002913,~{status}:400,msg:'Multipart request error: mixing CR and LF',ctl:auditLogParts=+I"
Use SecRuleDeny MULTIPART_MISSING_SEMICOLON      "!@eq 0" "t:none,id:2002914,~{status}:400,msg:'Multipart request error: semicolon missing',ctl:auditLogParts=+I,setvar:TX.logReqBodyBegin"
Use SecRuleDeny MULTIPART_FILE_LIMIT_EXCEEDED    "!@eq 0" "t:none,id:2002915,~{status}:413,msg:'Multipart request error: too many files',ctl:auditLogParts=+I"
Use SecRuleDeny MULTIPART_INVALID_PART           "!@eq 0" "t:none,id:2002933,~{status}:400,msg:'Multipart request error: invalid part',ctl:auditLogParts=+I,setvar:TX.logReqBodyBegin"
<IfDefine MULTIPART_STRICT>
 # MULTIPART_UNMATCHED_BOUNDARY may equal 2 in strict mode => too restrictive
 SecRule MULTIPART_UNMATCHED_BOUNDARY "@eq 1"  "phase:2,t:none,~{log},~{denyUnSetEnv},msg:'Multipart request error: possible unmatched boundary',setvar:TX.logReqBodyBegin,setvar:TX.logReqBodyEnd"
 # MULTIPART_INVALID_QUOTING: single quote in filename
 SecRule MULTIPART_INVALID_QUOTING    "!@eq 0" "phase:2,t:none,~{log},~{denyUnSetEnv},msg:'Multipart request error: possible unmatched quoting',setvar:TX.logReqBodyBegin"
 # Quoted boundary is allowed according to rfc 2616 but not accepted by many implementations
 SecRule MULTIPART_BOUNDARY_QUOTED    "!@eq 0" "phase:2,t:none,~{log},~{denyUnSetEnv},msg:'Multipart request error: quoted boundary',setvar:TX.logReqBodyBegin"
 # Some clients use LF instead of CRLF, etc. -> do not use MULTIPART_STRICT_ERROR
 SecRule MULTIPART_STRICT_ERROR       "!@eq 0" "phase:2,t:none,~{log},~{denyUnSetEnv},msg:'Request parsing error strict (%{REQBODY_PROCESSOR}): %{REQBODY_ERROR_MSG}'"
</IfDefine>

Use SecRuleDeny REQBODY_ERROR  "!@eq 0" "phase:2,t:none,id:2002906,~{status}:400,msg:'Request parsing error (phase 2), %{REQBODY_ERROR_MSG}',setvar:TX.logReqBodyBegin"
# For requests that are blocked immediately
Use SecRule &TX:allowed2       "@eq 0"  "phase:5,t:none,id:2002906,tag:security,~{skipAfter}:AfterReqBodyErr5"
 Use SecRuleDeny REQBODY_ERROR "!@eq 0" "phase:5,t:none,id:2002906,~{log},msg:'Request parsing error (phase 5), %{REQBODY_ERROR_MSG}',setvar:TX.logReqBodyBegin"
Use SecMarker AfterReqBodyErr5,tag:security

# Multipart Content-Disposition headers: name=...;name=...
<IfDefine MODSEC_AnalyseMultipartHeaders>
 Use SecRuleDeny MULTIPART_PART_HEADERS "(?i)Content-Disposition:.*\bname\s*+=.*;\s*+name\s*+="           "t:none,~{status}:400,tag:Protocol,msg:'Multiple Content-Disposition names in %{MATCHED_VAR_NAME}',~{testRule},rev:20230412"
 Use SecRuleDeny MULTIPART_PART_HEADERS "(?i)Content-Transfer-Encoding:(?! (?:[0-9]{1,2}bit|binary)$)" "t:none,~{status}:400,tag:Protocol,msg:'Invalid Content-Transfer-Encoding in %{MATCHED_VAR_NAME}',~{testRule},rev:20230412"
</IfDefine>

<IfModule http2_module>
 Use SecRule REQUEST_PROTOCOL "!^HTTP/2$" "phase:1,t:none,tag:security,~{skipAfter}:AfterHTTP2"
  # Only lowercase in binary headers, but remapped to uppercase during conversion to HTTP/1.x
  #Use SecRuleDeny REQUEST_HEADERS_NAMES "[A-Z]"      "phase:1,t:none,~{status}:400,msg:'Headers names must be lowercase',tag:Protocol"
  Use SecRuleHeader Transfer-Encoding "chunked"  "phase:1,t:none,~{drop},tag:Protocol,msg:'Chunked Encoding forbidden in HTTP2'"
  Use SecRuleHeader TE "!^trailers(?:;|$)"       "phase:1,t:none,~{drop},tag:Protocol,msg:'TE header may only contain <trailers> in HTTP2'"
 Use SecMarker AfterHTTP2,tag:security
</IfModule>

# Pragma Header requires a Cache-Control Header
# Exception for some proxies which are non-standard
#SecRule &REQUEST_HEADERS:/.*via/ "@eq 1" "phase:1,id:2002951,tag:security,t:none,~{skipAfter}:AfterPragmaCache-Control"
# SecRule &REQUEST_HEADERS:Pragma "@eq 1" "phase:1,id:2002951,tag:security,t:none,chain,msg:'Pragma Header requires Cache-Control Header for HTTP/1.1 requests',status:505"
 # SecRule &REQUEST_HEADERS:Cache-Control "@eq 0" "chain,t:none"
  # SecRule REQUEST_PROTOCOL "^HTTP/1.1$" "t:none,~{increaseBlockCounter}"
#Use SecMarker AfterPragmaCache-Control,tag:security
