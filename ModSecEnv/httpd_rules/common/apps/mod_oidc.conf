# Macros and rules defined for mod_auth_openidc
# https://github.com/zmartzone/mod_auth_openidc/blob/master/auth_openidc.conf
# Range: 4005100-4005199

<Macro OIDCRedirectURI @frontPath>
 <IfModule auth_openidc_module>
  OIDCRedirectURI      @frontPath
 </IfModule>
</Macro>

<Macro OIDCSessionType $params>
 <IfModule auth_openidc_module>
  OIDCSessionType      $params
 </IfModule>
</Macro>

<Macro mod_oidc_default_url @url>
 <IfModule auth_openidc_module>
  # Page to redirect to after an authentication error (time-out, ...)
  OIDCDefaultURL          @url
  # Page to redirect to after a logout
  OIDCDefaultLoggedOutURL @url
 </IfModule>
</Macro>

DefineStr OIDCRedirectURI "/oidc_redirect_uri"
DefineStr OIDCCookiePrefix  AAG_
DefineStr OIDCSessionCookie ~{OIDCCookiePrefix}session
DefineStr ModOIDCDir /tmp

<Macro AdditionalOidcHeaders_>
 <IfModule auth_openidc_module>
  Use SetHeaderEnvSecure X-OIDC-Subject        oidc_claim_sub
  Use SetHeaderEnvSecure X-OIDC-Name           oidc_claim_name
  Use SetHeaderEnvSecure X-OIDC-FamilyName     oidc_claim_family_name
  Use SetHeaderEnvSecure X-OIDC-GivenName      oidc_claim_given_name
  Use SetHeaderEnvSecure X-OIDC-Department     oidc_claim_department
  Use SetHeaderEnvSecure X-OIDC-Email          oidc_claim_email
  Use SetHeaderEnvSecure X-OIDC-Token          oidc_access_token
 </IfModule>
</Macro>

<Macro NoAdditionalOidcHeaders>
 <IfModule auth_openidc_module>
  RequestHeader unset X-OIDC-Subject
  RequestHeader unset X-OIDC-Name
  RequestHeader unset X-OIDC-FamilyName
  RequestHeader unset X-OIDC-GivenName
  RequestHeader unset X-OIDC-Department
  RequestHeader unset X-OIDC-Email
  RequestHeader unset X-OIDC-Token
 </IfModule>
</Macro>

<Macro OIDCPassAccessToken $onoff>
 <IfDirective OIDCPassAccessToken>
  OIDCPassAccessToken $onoff
 </IfDirective>
</Macro>

<Macro NoOidcHeaders>
 <IfModule auth_openidc_module>
  Use NoAdditionalOidcHeaders
  Use OIDCPassAccessToken off
  OIDCPassClaimsAs environment
 </IfModule>
</Macro>

<Macro mod_oidc_lastuser $h_lastuser $h_oidc>
 <IfModule auth_openidc_module>
  Use SecRule REQUEST_COOKIES:/~{OIDCSessionCookie}.*/ @unconditionalMatch "phase:2,t:none,~{nosecaction},setvar:tx.oidcsess=%{tx.oidcsess}%{MATCHED_VAR}"
  Use SecRule tx:oidcsess @unconditionalMatch                              "phase:2,t:none,~{hash},~{nosecaction},setvar:tx.oidcsess=AAG_%{MATCHED_VAR}"
  # Store userid for later
  Use SecRule REQUEST_HEADERS:$h_oidc @unconditionalMatch "phase:2,t:none,~{skipAfter}:AfterOidcLastuser,initcol:RESOURCE=%{tx.oidcsess},setvar:RESOURCE.oidc_lastuser=%{MATCHED_VAR}"
  # In case RESOURCE was initialized to something else
  Use SecRule RESOURCE:KEY            @unconditionalMatch "phase:2,t:none,~{skipAfter}:AfterOidcLastuser"
  # Retrieve userid when not provided
  Use SecAction "phase:2,t:none,chain,~{nosecaction},initcol:RESOURCE=%{tx.oidcsess}"
   Use SecRule RESOURCE:oidc_lastuser . "t:none,setenv:oidc_lastuser=%{RESOURCE.oidc_lastuser},expirevar:RESOURCE.oidc_lastuser=~{block_timeout}"
  Use SecMarker AfterOidcLastuser
  Use SetHeaderEnvSecure $h_lastuser oidc_lastuser
 </IfModule>
 Error To complete (replace RESOURCE by USERID)
</Macro>

<Macro mod_oidc_redirect   $frontPath>
 <IfModule auth_openidc_module>
  # Last path wins => redirect to last one
  Use OIDCRedirectURI      "$frontPath~{OIDCRedirectURI}"
  Use SetenvSec oidcredir_ "$frontPath~{OIDCRedirectURI}"
 </IfModule>
</Macro>

<Macro mod_oidc_regex $regex @frontPath>
 <IfModule auth_openidc_module>
  # Returns 401 instead of 302 for some requests
  Use mod_oidc401    "$regex"
  # Protects the location
  <LocationMatch ^(?i)$regex(?:/|$)>
   AuthType openid-connect
   Require valid-user
  </LocationMatch>
   Use mod_oidc_redirect @frontPath
   Use OIDCPassAccessToken off
 </IfModule>
</Macro>

<Macro mod_oidc @frontPath>
 Use mod_oidc_regex @frontPath @frontPath
</Macro>

# Callback is a Universal Link
DefineStr aag_pattern  "(?:REQUEST_COOKIES:([^;]+;))" 
DefineStr aag_pattern2 "^~{aag_pattern}~{aag_pattern}?~{aag_pattern}?~{aag_pattern}?~{aag_pattern}?~{aag_pattern}?~{aag_pattern}?~{aag_pattern}?~{aag_pattern}?$" 
<Macro mod_oidc_mobile_ $path $os $callback>
 <IfModule auth_openidc_module>
  Use SecRule TX:url "!^$path/oidc_mobile_$os$"                           "phase:1,t:none,~{skip}:1
  Use SecRule REQUEST_COOKIES:/^~{OIDCSessionCookie}/ @unconditionalMatch "phase:1,t:none,~{nosecaction},setenv:'aag_cookies=%{MATCHED_VAR_NAME}=%{MATCHED_VAR};%{env.aag_cookies}'"
  <Location $path/oidc_mobile_$os>
   # When not authenticated, we don't enter here
   RewriteCond %{ENV:aag_cookies} "~{aag_pattern2}" 
    RewriteRule ^ - [E=aag_cookies:%1%2%3%4%5%6%7%8%9]
   # Remove trailing ; (not very useful)
   #RewriteCond %{ENV:aag_cookies} "^(.*);$" 
   # RewriteRule ^ - [E=aag_cookies:%1]
   RewriteRule ^ "$callback?cookie=%{ENV:aag_cookies}" [L,R,DPI]
  </Location>
 </IfModule>
</Macro>
<Macro mod_oidc_ios @path @callback>
 Use mod_oidc_mobile_ @path ios @callback
</Macro>
<Macro mod_oidc_android @path @callback>
 Use mod_oidc_mobile_ @path android @callback
</Macro>
<Macro mod_oidc_mobile @path @callback>
 Use mod_oidc_ios      @path @callback
 Use mod_oidc_android  @path @callback
 # After mobile URLs, so they have precedence for RewriteRule
 Use mod_oidc          @path
</Macro>

DefineStr Oidc302Action  "phase:1,t:none,~{nosecaction},nolog,setenv:!moidc401"
DefineStr Oidc401Action  "phase:1,t:none,nolog,setenv:moidc401"
DefineStr Oidc401Action_  "~{Oidc401Action},~{skipAfter}:AfterOidc401"
<Macro mod_oidc401 $frontPath>
 <IfModule auth_openidc_module>
  # mod_auth_openidc returns 401 (thus no state cookies) instead of a 302 with state cookies when
  #  - header X-Requested-With is present
  #  - header Accept doesn't contain "application/html", "application/xhtml+xml" or "*/*"
  Use NotInsideLocation
  Use SecRule TX:url "!^$frontPath(?:/|$)" "phase:1,t:none,~{skipAfter}:AfterOidc401"
   Use SecRule REQUEST_HEADERS:Sec-WebSocket-Version @unconditionalMatch           "~{Oidc401Action_},setenv:moidc401=Sec-WebSocket-Version"
   Use SecRule REQUEST_HEADERS:Upgrade  "^WebSocket"                               "~{Oidc401Action_},setenv:moidc401=Upgrade"
   Use SecRule ENV:req_ajax @unconditionalMatch                                    "~{Oidc401Action_},setenv:moidc401=ajax"
   Use SecRule ENV:mso_client @unconditionalMatch                                  "~{Oidc401Action_},setenv:moidc401=WebDAV-client"
   #Use SecRule TX:knownRobot "@eq 1"                                               "~{Oidc401Action_},setenv:moidc401=robot"
   #Use SecRule TX:url "/rest/"                                           "~{Oidc401Action_},setenv:moidc401=rest"
   #Use SecRule ENV:PathToIgnore @unconditionalMatch                                "~{Oidc401Action_},setenv:moidc401=PathToIgnore"
   Use SecRule TX:BASENAME "[.](?i:~{UsualResFileExt}|axd|xml)$"              "~{Oidc401Action_},setenv:moidc401=extension"
   <IfDefine ----------->
   Use SecRule TX:BASENAME "[.](?i)css$"                             "phase:1,~{nosecaction},setenv:'moidc401=test/css'"
   Use SecRule TX:BASENAME "[.](?i)js(?:on)?$"                       "phase:1,~{nosecaction},setenv:'moidc401=application/javascript'"
   Use SecRule TX:BASENAME "[.](?i)xml$"                             "phase:1,~{nosecaction},setenv:'moidc401=text/xml'"
   Use SecRule TX:BASENAME "[.](?i)~{FontFileExt}$"                  "phase:1,~{nosecaction},setenv:'moidc401=font/*'"
   Use SecRule TX:BASENAME "[.](?i)~{ImagesFileExt}$"                "phase:1,~{nosecaction},setenv:'moidc401=image/*'"
   Use SecRule TX:BASENAME "[.](?i)~{ArchiveFileExt}$"               "phase:1,~{nosecaction},setenv:'moidc401=application/octet-stream'"
   Use SecRule TX:BASENAME "[.](?i)~{MultiMediaFileExt}$"            "phase:1,~{nosecaction},setenv:'moidc401=audio/*,video/*'"
   Use SecRule TX:BASENAME "[.](?i)~{PublishingFileExt}$"            "phase:1,~{nosecaction},setenv:'moidc401=application/octet-stream'"
   Use SecRule TX:BASENAME "[.](?i)~{UnsupportedCompressedFileExt}$" "phase:1,~{nosecaction},setenv:'moidc401=application/octet-stream'"
   Use SecRule TX:BASENAME "[.](?i)~{DocFileExt}$"                   "phase:1,~{nosecaction},setenv:'moidc401=application/octet-stream'"
   Use SecRule REQUEST_HEADERS:Accept "webp"                              "phase:1,~{nosecaction},setenv:'moidc401=image/webp,%{ENV.moidc401}'"
   </IfDefine>
  Use SecMarker AfterOidc401

  OIDCUnAuthAction 401 "-n reqenv('moidc401')"

  # Always log 302 if blocked by mod_oidc (TX.allowed2 not set)
  Use SecRule RESPONSE_STATUS "^302" "phase:3,t:none,chain,~{nosecaction}"
   Use SecRule &TX:allowed2 "@eq 0" "setenv:!no-log"
 </IfModule>
</Macro>

# To send the OAuth2 token to the back-end as a bearer token
<Macro mod_oidc_BackTokenBearer>
 RequestHeader set Authorization "Bearer %{OIDC_access_token}e" env=OIDC_access_token
</Macro>

<IfModule auth_openidc_module>
 #OIDCHTMLErrorTemplate "~{DocumentRoot}/SecError/oidc.html"

 # Don't remap URL in parameter
 Use NoRemapURLInQueryExt "(?i)~{OIDCRedirectURI}$"

 # Last path wins => redirect to last one
 RewriteCond "%{ENV:oidcredir_}:%{REQUEST_URI}" "^([^:]+):\1$"
  RewriteRule ^ - [Skip=1]
 RewriteCond %{ENV:oidcredir_} "(.+)"
  RewriteRule "~{OIDCRedirectURI}$" "%1" [L,R]

 # Global security rules (loaded once) ------------------------------------------
  <IfDirective OIDCStateCookiePrefix>
   OIDCStateCookiePrefix ~{OIDCCookiePrefix}st_
  </IfDirective>
  OIDCCookie            "~{OIDCSessionCookie}"
  Use SanitizeCookie    "~{OIDCSessionCookie}([^=]*)"
  #Use AcceptCookieRegex "~{OIDCCookiePrefix}[~{CharMin}]+"

  # Pass info as headers and environment variables
  # (default headers with underscore cannot be read by all servers)
  OIDCPassClaimsAs both
  Use AdditionalOidcHeaders_

 # Keep only 6 state cookies and delete oldest ones
 OIDCStateMaxNumberOfCookies 7 true

 #OIDCCookieSameSite On

 # 2 minutes allowed for authentication (default 5 minutes)
 OIDCStateTimeout 120
 # Session invalid after 1 h without interaction
 OIDCSessionInactivityTimeout 3600
 # Maximum duration of the application session: 8 hours (8 * 3600 seconds)
 OIDCSessionMaxDuration 28800
 # Clean up expired sessions every 10 minutes (default = 1 min)
 #OIDCCacheFileCleanInterval 600

 # Remember Me with infinite number concurrent users: cookies or file ----------

 # Cookies: :store_id_token is better but not yet supported everywhere
 OIDCSessionType client-cookie:persistent

 # Use file for cache to allow big numbers of sessions to be stored
 # /chroot/apache/tmp
 #  - ACL correct & cleaned up
 #  - /tmp is checked for existence by root process
 #  - cleared on reboot
 # ~{AppRun}
 #  - ACL manually set & cleaned up by mod_oidc
 #  - not cleared on reboot => keep long-running sessions
 #  - ~{AppRun} is on a small filesystem, but not the chrooted version => OK
 #OIDCSessionType server-cache:persistent
 OIDCCacheType file
 OIDCCacheDir "~{ModOIDCDir}"
 #OIDCCacheDir "~{TmpDir}"

 # Invalid scope, Require, ... => 403
 OIDCUnAutzAction 403
 <Location />
  AuthzSendForbiddenOnFailure on
 </Location>

 Use SanitizeCookie    "~{OIDCCookiePrefix}[~{CharMin}]+"
 # Don't send them to back-end: Use AcceptCookieRegex "~{OIDCCookiePrefix}[~{CharMin}]+"
  
 # mod_auth_openidc cookies not sent to back-end => no risk of leak to another application
 OIDCCookiePath /

 # Phase 2 runs after authn modules => phase 1

 # UUIDs are formatted as: 00112233-4455-6677-8899-AABBCCDDEEFF
 Use SecRuleDeny REQUEST_COOKIES:~{OIDCSessionCookie}           "!^(?:~{syntax_uuid}|~{syntax_base64}|~{AuthToken_})$" "phase:1,t:none,msg:'Cookie ~{OIDCSessionCookie}: Invalid format',logdata:%{MATCHED_VAR}"
 Use SecRuleDeny REQUEST_COOKIES:~{OIDCSessionCookie}_chunks    "!^[0-9]+$"                                            "phase:1,t:none,msg:'Cookie ~{OIDCSessionCookie}_chunks: Invalid format',logdata:%{MATCHED_VAR}"
 Use SecRuleDeny REQUEST_COOKIES:/^~{OIDCSessionCookie}_[0-9]+/ "!^(?:[-_a-zA-Z0-9+/.]*={0,2})$"                       "phase:1,t:none,msg:'Cookie %{MATCHED_VAR_NAME}: Invalid format',logdata:%{MATCHED_VAR}"

 # code=0.AQwAPmp93ewOq06x5PqA7ON78pg5qbOKe-VFvZC8nWA0XfYMAN8.AQABAAIAAAAm-06blBE1TpVMil8KPQ41ZXt12KtkuDyXChb6v1DS1MohXU_s5yc8r7VM0A-Ro8pIaFyroQ3m85h9Q56aItdNNaCCbmbDOtJML9-I9VNCZZ8Hbli3Strjd4iynTP6PPX_hAMfy1oZxEbAtgg1DWrfEQPqac5KS1FxDo3uAGOwKXpjLVAzFORsbmxReueFBA2EBIX3EVeWmWRzyxgVunX1stfRQ4r2Sb_741TbAc1USmYmhoXqGqesL8vrqxwBe0yHN7AHsZH7_rucOPsI7qZj4L4oMNj24k8f1MOyDCh27GgmUS3TcgP4PMHcMH1Gq9rYOwkrbzhhr97ZDd8RqjzuHUNe_ZE-WzZMs1uwoznCIziUk605qaq2c8d_UqrBbcNTaLVJ-MrGMcll0FvNJNn5WK3282MkUzG6ot0PLRhMrugvJCTFTosO9GqmkqonV6OUM6vWmTKG15TrteJRySGydxnUQ0dQARdcOylaakBke_zLIEEJk4V6NvdkTk2_fBgZN7hB8AIVFJyspdLRxZh1to3YmLBuPi_iPgxZFozdKnCx4YVn0i28hEimK49isiO73yJM6h6sL_qmgyhO6LCLTNBNOQJusNa3txyTCKqNDmzdfJEclUNAhPlivwz2lsFQD-BPC-OJ6kcndyfii86coOa8eMspuGJF2upKBEgkzSAA
 # state=M6B9tI3mOqipeiQjNAuy7XZJwYA
 # session_state=e8303239-d0b1-40ad-a924-44b7f973c13f
 Use SecRule TX:url "!~{OIDCRedirectURI}$"                     "phase:1,t:none,~{skipAfter}:AfterModOidcEndPoints,tag:security"
  Use SecRuleDeny ARGS_GET:target_link_uri @unconditionalMatch "phase:1,t:none,t:none,tag:specific,msg:'Parameter target_link_uri not used by mod_auth_openidc'"
  # Authentication OK
  Use ArgGetWhiteListP1 code           "~{AuthToken_}"
  Use ArgGetWhiteListP1 iss            "^~{syntax_URL_https}$"
  Use ArgGetWhiteListP1 session_state  "~{AuthInternalRef_}"
  Use ArgGetWhiteListP1 state          "~{AuthInternalRef_}"
  # Logout
  Use ArgGetWhiteListP1 logout         "^(?:~{syntax_URL_https_Query}|~{syntax_URL_path})?$"
  # Authentication error
  Use ArgGetWhiteListP1  error              "^[-a-zA-Z0-9 :._]{0,100}$"
  Use ArgGetWhiteListP1  error_description  "^[~{CharFreeText}]{0,1000}$"
  Use ArgGetWhiteListP1  error_uri          "^~{syntax_URL_https_Query}$"
  Use ArgGetWhiteListP1  error_subcode      "^[-a-zA-Z0-9 :._]{0,100}$"
  Use CheckWhiteListArgsP1
  Use SecAction "phase:1,~{noResponseBodyAccess},setvar:TX.allowed2"
 Use SecMarker AfterModOidcEndPoints,tag:security

 # Block internal headers
 Use SecRule REQUEST_HEADERS:'/(?i)^OIDC_(?:access|CLAIM)_/' @unconditionalMatch  "phase:1,t:none,id:4005101,~{status}:500,~{increaseBlockCounter},tag:Specific,msg:'mod_oidc header injection'"

 # Register userid
 Use SecRule ENV:OIDC_CLAIM_sub @unconditionalMatch "phase:2,~{nosecaction},t:none,setuid:%{MATCHED_VAR},setenv:WAF_USER=%{ENV.OIDC_CLAIM_sub}"

 # SecAuditLog often overwritten by specific config => same in final5.conf
 <LocationMatch ~{OIDCRedirectURI}$>
  Use SecAuditLog "~{SecLog}/../mod_oidc_audit.log"
  Use SecNoCheckResponse
  # Module returns 404 when state has expired
  Use SecIgnorePageNotFound
  Use DoNotTrapError 500
  Use SecAllowBase64
 </LocationMatch>

 Use SanitizeHeader OIDC_access_token
 Use SanitizeHeader X-OIDC-token

 #Use SecRule TX:url "~{OIDCRedirectURI}$" "phase:3,~{nosecaction},allow"
</IfModule>
