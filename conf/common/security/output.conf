# ModSecurity rules for response filtering
# ---------------------------------------------------------------
# Range: 4002200-4002299


# Remove unneeded information
# Use Substitute  "s`<meta name=.?(?:generator|code_language)[^>]{0,500}>``i"

# Disable response checking when containing Base64 encoded data
#Use SecRule &TX:allowed3 "@eq 0"                        "phase:4,tag:security,t:none,~{skipAfter}:AfterRespB64"
#Use SecRule TX:noResponseBodyAccess @unconditionalMatch "phase:4,tag:security,t:none,~{skipAfter}:AfterRespB64"
# Use SecRule RESPONSE_BODY "(?i)data:[^\s]{0,10000};base64,"  "phase:4,tag:security,t:none,~{nosecaction},allow"
#Use SecMarker AfterRespB64,tag:security

# Web applications
Use SecRuleResponse "run-time error"                              "4002260,tag:Output/Exception"
Use SecRuleResponse "stack trace"                                 "4002261,tag:Output/Exception"
Use SecRuleResponse "internal (?:server )?error"                  "4002264,tag:Output/Exception"
Use SecRuleResponse "implementation specific"                     "4002265,tag:Output/Exception"
Use SecRuleResponse "compile error"                               "4002266,tag:Output/Exception"
Use SecRuleResponse "an unhandled exception (?:has )?occurred"    "4002268,tag:Output/Exception"
Use SecRuleResponse "division by zero|null pointer"               "4002283,tag:Output/Exception"
Use SecRuleResponse "#include\s*+[<\x22']"                          "4002294,tag:Output/Exception"
#Use SecRule RESPONSE_HEADERS:Content-Type "xhtml" "phase:4,tag:security,~{skipAfter}:EndBlockXML"
# Use SecRuleResponse "^(?>\s*+<[?]xml [^>]++>)\s*+<!DOCTYPE html"   "4002296,tag:Output/Leak,msg:'XHTML document'"
# Use SecRuleResponse "^<[?]xml "                                  "4002296,tag:Output/Leak,msg:'XML document'"
#Use SecMarker EndBlockXML,tag:security
Use SecRuleResponse "<[?]xml"                                     "4002208,tag:Output/Leak,msg:'XML in response'"
Use SecRuleResponse "Response[.]Write"                            "4002297,tag:Output/Leak"
Use SecRuleResponse "<[*~%]"                                      "4002206,tag:Output/Leak"

# DB
Use SecRuleResponse "Database error"             "4002201,msg:'SQL error',tag:SQL"
Use SecRuleResponse "SQL Dump"                   "4002244,msg:'SQL error',tag:SQL,tag:Output/Leak"

# SOAP errors
Use SecRuleResponse "soapenv\s*+:|SoapException|<\s*+fault(?:code|string).*<\s*+/(?:code|string)\s*+>"  4002285,tag:Output/Exception

# Misc
<IfDefine !EXTENDEDSTATUS>
 Use SecRuleResponse "-----BEGIN"         "4002243,msg:'Base64-encoded ASN.1 entity',tag:Output/Leak,tag:Develop"
</IfDefine>
#Use SecRuleResponse "[|]\s*+password\s*+[|]"  "4002246,msg:'SQL error',tag:Output/Leak,tag:SQL"

# Hidden frame -> hacked (XSS)
DefineStr beginFrame_ "<\W*(?:i|vml)?frame[^>]+"
Use SecRuleResponse "(?i)(~{beginFrame_}style\s*+=\s*+(?:[\x22'][^>\x22']*)?(?:hidden|display\W*:\W*none))\b"  4002280
Use SecRuleResponse "(?i)(~{beginFrame_}(?:width|height)\W*:\W*0)"                                           4002281

#  Use SecRuleResponseWarning "(?i)<meta\s+http-equiv=['\x22]?Set-Cookie['\x22]? " this is maybe a successful Session Fixation attack
#  Use SecRuleResponseWarning "(?i)<meta\s+http-equiv=['\x22]?Refresh['\x22]? " this is maybe a successful POST-redirect attack

# JavaScript minification error
#Use SecRuleResponseWarning "minification failed" 4002203

# Classified documents
#  Use SecRuleResponse "(?i:top secret)"     40022xx
#  Use SecRuleResponse "(?i:classified)"     40022xx
#  Use SecRuleResponse "(?i:restricted)"     40022xx

# Page too long on redirect (page displayed)
Use SecRule RESPONSE_STATUS "!^302"               "phase:3,id:4002299,tag:OutputLength,t:none,tag:security,~{skipAfter}:After302Length"
 Use SecRuleIntComp_ RESPONSE_CONTENT_LENGTH 200 ",phase:3,id:4002299,tag:OutputLength" ",t:none"
 SecRule TX:intcmp "@eq 1"                        "phase:3,id:4002299,tag:OutputLength,t:none,~{warn},msg:'Content too long on redirect (page displayed?)',setenv:noIncreaseBlockCounter"
Use SecMarker After302Length,tag:security

# Unknown hostname in redirect
Use CheckUriVarPhase_ 4 RESPONSE_HEADERS:Location "https?:" "4002205,tag:Colon" "~{status}:500,~{decreaseBlockCounter},msg:'Unknown host <%{RESPONSE_HEADERS.Location}> in Location header, allow with [DefineStr TrustedDomains] [DefineStr TrustedHosts] or [Use SecAllowURL...]',setenv:'errorMsg=Internal error',setenv:noIncreaseBlockCounter"

# ------------------------------------------------------------------------------

# Get application charset
#DefineStr skipCharset_ "phase:5,t:none,~{skipAfter}:EndOfCharset"
#DefineStr skipCharset  "~{skipCharset_},setvar:TX.charset=NotHTML,setvar:TX.headercharset=NotHTML,setvar:TX.pagecharset=NotHTML"
#SecRule RESPONSE_STATUS "!^2"           "~{skipCharset}"
#SecRule RESPONSE_HEADERS:Content-Length "^0" "~{skipCharset}"
#SecRule RESPONSE_CONTENT_TYPE "!(?i)^text/html(?:;|$)" "~{skipCharset}"
#SecRule RESPONSE_CONTENT_TYPE "(?i:charset=([a-z0-9-]{0,10}))" "~{skipCharset_},capture,setvar:TX.charset=%{TX.1},setvar:TX.headercharset=%{TX.1}"
#Use SecRule &ENV:allowed4 "@eq 0"                        "~{skipCharset}"
#Use SecRule TX:noResponseBodyAccess @unconditionalMatch "~{skipCharset}"
#SecRule RESPONSE_BODY "(?i)<meta\s+http-equiv=(?:\x22|')?content-type(?:\x22|')? +content=(?:\x22|')?text/html; +charset=([a-z0-9-]*)" "phase:5,~{nosecaction},capture,setvar:TX.charset=%{TX.1},setvar:TX.pagecharset=%{TX.1}"
#SecAction "phase:5,~{log},tag:security,msg:'header:<%{TX.headercharset}> page:<%{TX.pagecharset}> charset:<%{TX.charset}>'"
#Use SecMarker EndOfCharset

# Check that attachment is forced in case browser is sniffing
#SecRule RESPONSE_HEADERS:Content-disposition "^attachment" "phase:~{Phase5Warn},t:none,~{skipAfter}:EndOfForceAttachment,tag:security,tag:output"
#Use RuleLogOnce ENV:resp_json|ENV:resp_xml "@gt 0" "tag:security" "API should set 'Content-disposition: attachment'"  ??????? "tag:output"
#SecMarker EndOfForceAttachment,tag:security,tag:output


# Check that filename is always provided for attachments
SecRule &RESPONSE_HEADERS:Content-Disposition "@eq 0"        "phase:3,t:none,~{skipAfter}:EndOfAttachmentFilename"
SecRule  RESPONSE_HEADERS:Content-Disposition "!^attachment" "phase:3,t:none,~{skipAfter}:EndOfAttachmentFilename"
 # Log in case no filename is provided
 Use RuleLogOnceExt__ 3 RESPONSE_HEADERS:Content-Disposition "!(?i)\bfilename[*_]?=."  "t:none" "setenv:attachFN=file.txt" "Missing filename for attachment"  4002202 "tag:security" RESOURCE "%{WEBAPPID}"
 # Capture file name
 SecRule RESPONSE_HEADERS:Content-Disposition "(?i)\bfilename[*_]?=(?:UTF-8'')?\x22?([^;\x22]*)" "phase:3,t:none,~{nosecaction},capture,setvar:'TX.downfn=%{TX.1}'"
 SecRule TX:downfn "(.*)[ ]$" "phase:3,t:none,~{nosecaction},capture,setvar:'TX.downfn=%{TX.1}'"
 # No extension => allowed
 SecRule TX:downfn "![.]" "phase:3,t:none,~{skipAfter}:EndOfAttachmentFilename"
 # Specifically added extension => allowed
 SecRule TX:downfn "[.]([^.]+)$" "phase:3,t:none,t:lowercase,~{nosecaction},capture,setvar:'TX.downfileext=%{TX.1}',setvar:'TX.fnwithin=,%{TX.1},'"
 SecRule TX:downfileext "^(?i:css|ico|js|htc|html?|~{UsualFileExt})" "phase:3,t:none,~{skipAfter}:EndOfAttachmentFilename"
 # Usual extension => allowed
 SecRule TX:fnwithin "!@within ,%{TX.allowed_downfileext}," "phase:3,t:none,id:4002204,~{statusResp}:404,~{increaseBlockCounter},msg:'Download file extension not allowed <%{TX.downfileext}>',tag:Download"
SecMarker EndOfAttachmentFilename
# Fixes filename (in case it is user-driven)
# Remove "false" extension (ex: x.doc.exe)
#Header edit Content-Disposition "(?i)\b(filename[*]?=[^.;]+)[.]([^;.]+)[.]" "$1_$2."
# Remove bad characters (but allow Unicode)
Header edit* Content-Disposition "[\x00-\x0f&+,/:<>?\x5c^\x60|~\x7f]" "_"
# Remove =...*
Header edit* Content-Disposition "(=[^=]*)[*]" "$1_"
# Add filename if missing for attachments
Header edit Content-Disposition "$" "; filename=%{attachFN}e" env=attachFN

# Notify about "Access-Control-Allow-Credentials: true" & invalid Access-Control-Allow-Origin
# Not in phase 5 because header was removed
<IfDefine !noCORSheader>
 Use SecRule &RESPONSE_HEADERS:Access-Control-Allow-Origin "@eq 0" "phase:~{Phase5Warn},t:none,tag:security,tag:output,~{skipAfter}:AfterCheckAuthCORS"
 Use SecRule &ENV:allowCORS "@eq 0"                                "phase:~{Phase5Warn},t:none,tag:security,tag:output,~{skipAfter}:AfterCheckAuthCORS"
  Use SecRule ENV:allowCORS "^[*]|none$"                           "phase:~{Phase5Warn},t:none,tag:security,tag:output,~{skipAfter}:AfterCheckOrigin"
   Use RuleLogOnceExt REQUEST_HEADERS:Origin                       "!^%{ENV.allowCORSProtocol}://(?:%{ENV.allowCORS})$|^null$" "t:none" "logdata:'Allowed: %{ENV.allowCORSProtocol}://(?:%{ENV.allowCORS})'"                                                                                        "Warning: Untrusted Origin"                       4002209 "tag:output,tag:security" %{WEBAPPID}
   Use RuleLogOnceExt RESPONSE_HEADERS:Access-Control-Allow-Origin "!^%{ENV.allowCORSProtocol}://(?:%{ENV.allowCORS})$" "t:none"        "logdata:'Allowed: %{ENV.allowCORSProtocol}://(?:%{ENV.allowCORS})',logdata:'Access-Control-Allow-Origin: %{RESPONSE_HEADERS.Access-Control-Allow-Origin}'" "Warning: Untrusted Access-Control-Allow-Origin"  4002211 "tag:output,tag:security" %{WEBAPPID}
  Use SecMarker AfterCheckOrigin,tag:security,tag:output

 # Check authenticated CORS 
 Use SecRule ENV:allowAuthCORS @unconditionalMatch "phase:~{Phase5Warn},t:none,id:4002210,~{skipAfter}:AfterCheckAuthCORS,tag:security,tag:output"
  Use RuleLogOnceExt RESPONSE_HEADERS:Access-Control-Allow-Credentials "true" "t:none" "logdata:%{RESPONSE_HEADERS.Access-Control-Allow-Credentials}" "Untrusted Access-Control-Allow-Credentials in response" 4002210 "tag:output,tag:security" %{WEBAPPID}
 Use SecMarker AfterCheckAuthCORS,tag:security,tag:output
</IfDefine>

# Detect charset mismatch
#Use SecRule RESOURCE:CHARSETDISCREPANCY "@gt 0"          "phase:5,tag:security,id:4002222,~{skipAfter}:EndOfCHARSETDISCREPANCY"
#Use SecRule &TX:HEADERCHARSET           "@eq 0"          "phase:5,tag:security,id:4002222,~{skipAfter}:EndOfCHARSETDISCREPANCY"
#Use SecRule &TX:PAGECHARSET             "@eq 0"          "phase:5,tag:security,id:4002222,~{skipAfter}:EndOfCHARSETDISCREPANCY"
#Use SecRule TX:HEADERCHARSET "!@streq %{TX.PAGECHARSET}" "phase:5,tag:security,id:4002222,~{log},initcol:RESOURCE=url_%{TX.hash_url},setvar:RESOURCE.charsetDiscrepancy,msg:'Charset discrepancy between page and header'"
#Use SecMarker EndOfCHARSETDISCREPANCY,tag:security
