# ModSecurity security rules: final, included (duplicated) in each vhost
# ----------------------------------------------------------------------
# Range: 2002400-2002499

<IfDefine !noSecurityRules>
 # Allow no extension in request file name
 Use SecAllowBasenameExt_ "^[^.]*$"

 # Disallow all unregistered extensions in URL (to overwrite in locations)
 # PROPFIND/OPTIONS not considered as an attack
 Use SecRule REQUEST_METHOD "^(?:PROPFIND|OPTIONS)"  "phase:2,~{status404},~{noIncreaseBlockCounter},t:none,id:2002400,msg:'filename extension not allowed (PROPFIND -> ignore)',tag:Ignore"
 Use SecAction "phase:2,t:none,id:2002400,~{increaseBlockCounter},~{status404},msg:'filename extension not allowed (Use SecAllowExt)',tag:URL"
 
 # Disallow basenames in URL
 Use SecRuleDeny &TX:allow_basename "@eq 0" "phase:2,~{status404},t:none,id:2002411,msg:'Invalid character in URL basename (Use SecAllowCharsInBasename/SecAllowCharsInUpDownDocs)',tag:URL"
 
 Use SecRule TX:url "!;jsessionid" "phase:2,t:none,tag:security,~{skipAfter}:AfterFilename"
  Use SecRule &TX:JSessionIdAllowed "@eq 0"  "phase:2,t:none,~{status404},~{increaseBlockCounter},msg:'JSessionId not allowed in URL',tag:specific"
 Use SecMarker AfterFilename,tag:security,tag:specific
 # Restrict content-types
 # NOTE: We allow any content type to be specified with GET or HEAD
 #      because some tools incorrectly supply content type information
 #      even when the body is not present.
 # NOTE: applications running on the PocketPC and AvantGo platforms use non-standard content types:
 #      M-Business iAnywhere      application/x-mal-client-data
 #      UltraLite  iAnywhere      application/octet-stream
 DefineStr StopCTCheck "phase:2,t:none,tag:security,~{skipAfter}:EndOfCTCheck"
 Use SecRule &REQUEST_HEADERS:Content-Type "@eq 0"            "~{StopCTCheck}"
 Use SecRule REQUEST_HEADERS:Content-Type  "^$"               "~{StopCTCheck}"
 Use SecRule REQUEST_METHOD "^(?:GET|HEAD|PROPFIND|OPTIONS)$" "~{StopCTCheck}"
 Use SecRule REQUEST_HEADERS:Content-Type "^(?i)multipart/form-data; ?boundary=\x22?[^\x22]+\x22?$" "~{StopCTCheck}"
 Use SecRule TX:allow_ContentType          "@eq 1"            "~{StopCTCheck}"
 Use SecRuleHeader Content-Type "@unconditionalMatch" "t:none,id:2002407,msg:'Request content type is not allowed by policy (enable with SecAllowContentType)',tag:Protocol,logdata:%{REQUEST_HEADERS:Content-Type}"
 Use SecMarker EndOfCTCheck,tag:security
 
<IfDefine MODSEC_AnalyseMultipartHeaders>
 Use SecRule TX:allow_all_ContentType @unconditionalMatch                                 "phase:2,t:none,id:2002403,tag:security,~{skip}:1"
 Use SecRuleDeny MULTIPART_PART_HEADERS "^(?i)Content-Type: (?!%{TX.allowedCT} *(?:;|$))" "phase:2,t:none,id:2002403,~{status}:400,msg:'Request content type (multipart) is not allowed by policy (enable with SecAllowContentType)',logdata:%{MATCHED_VAR},tag:Protocol,~{testRule},rev:20230412"
</IfDefine>

 # Disable auto-detected JSON & XML
 Use SecRule REQUEST_HEADERS:Content-Type "^(?i:~{MimeJSONSeq}) *(?:;|$)" "phase:2,tag:security,t:none,id:2002401,~{skip}:1"
 Use SecRuleDeny TX:json_detected @unconditionalMatch "id:2002401,msg:'JSON detected in body but not declared with Content-Type. Fix Content-Type.',tag:Protocol,tag:autodetect"
 Use SecRuleDeny TX:xml_detected  @unconditionalMatch "id:2002402,msg:'XML detected in body but not declared with Content-Type. Fix Content-Type.',tag:Protocol,tag:autodetect"
 
 # Disable Destination header except for WebDAV
 Use SecRule TX:allow_WebDAV "^1"  "phase:2,t:none,tag:security,~{skipAfter}:AfterDestination"
  Use InvalidRequestHeader Destination
 Use SecMarker AfterDestination,tag:security
 
 # Accept TRACE method in local mode
 <IfDefine EXTENDEDSTATUS>
  Use SecRule REQUEST_METHOD "^TRACE$"  "phase:2,~{nosecaction},t:none,setvar:TX.allowed_method=1"
 </IfDefine>
 
 # We don't accept OPTIONS (except if WebDAV is enabled) but don't log this
 #  because some valid clients use this a lot to check WebDAV features
 Use SecRule REQUEST_METHOD "!^OPTIONS$" "phase:2,t:none,tag:security,tag:Ignore,~{skipAfter}:AfterOptions"
  Use SecRule TX:allowed_method "!^1"    "phase:2,t:none,~{stopStatus}:403,setvar:TX.noblock=1,tag:Ignore"
 Use SecMarker AfterOptions,tag:security,tag:Ignore
 
 Use SecRuleDeny TX:allowed_method "!^1" "phase:2,~{status}:400,t:none,id:2002408,msg:'HTTP method not allowed'"
 
 # Ignore WebDAV requests from MS Office & OpenOffice
 Use SecRule TX:allow_WebDAV "^1"  "phase:2,t:none,tag:security,~{skipAfter}:EndOfWebDAVDoc"
 # Ignore WebDAV requests for MS Office files
 Use SecRule TX:EXT "^(?i)(?:do[ct]|xl[st]|pp[st])[mx]?$"  "phase:2,t:none,tag:security,~{skipAfter}:EndOfWebDAVDoc"
  # Block WebDAV header to get source of scripts
  Use SecRuleHeader translate "!(?i)^t$"  "t:none,~{drop},id:2002405,msg:'HTTP WebDAV header disallowed',tag:Protocol"
  Use SecRuleHeader overwrite "!(?i)^f$"  "t:none,~{drop},id:2002406,msg:'HTTP WebDAV header disallowed',tag:Protocol"
 Use SecMarker EndOfWebDAVDoc,tag:security
 
 Use CheckUpFilesExt_
 
 # Check number of sessionid cookies
 Use SecRuleDeny TX:sessionnb  "@gt 8"  "phase:2,~{status}:500,t:none,msg:'Too many session id cookies (score=%{MATCHED_VAR})'"
 
 # Disable CSP for static pages
 #Use SecRule ENV:StaticPages "@eq 1" "phase:2,~{nosecaction},setenv:noCSP"
 SetenvIf StaticPages 1 noCSP
 
 # :: -------------------------------------------------------------------
 
 # Check global regex for headers
 <IfDefine OptimGlobalRegex>
  Use SecRuleDeny "~{ReqHeaders}" "%{TX.GlRegexH}" "phase:2,t:~{encodedParam},multiMatch,tag:SecRuleHeaders,msg:'Invalid content in header <%{MATCHED_VAR_NAME}>'"
 </IfDefine>

 # Check whitelist access
 Use SecRule TX:WL_Access_control   "@unconditionalMatch" "phase:2,~{status}:403,~{noIncreaseBlockCounter},msg:'Warning: missing <Use CheckWhiteListArgs> directive',tag:WhiteList"
 
 Use SetCookieUserid
 
 # All these locations should not be redirected (blocked by ModSecurity)
 #   (other locations not allowed)
 Use SecRuleDeny &ENV:locationOK  "@eq 0"  "phase:2,~{status404},t:none,msg:'Non existing location',ctl:ruleRemoveById=1000103-1000106"
 
 # Block if too many convictions
 Use SecRuleDeny TX:heuristic  "@ge ~{maxHeuristic}"  "phase:2,t:none,msg:'Heuristic attack detection (score=%{MATCHED_VAR})'"
 
 # Check that all returned cookies are allowed
 Use CheckCookiesAreAllowed

 Use SecRule RESPONSE_HEADERS:Content-Type "!text/html"  "phase:3,t:none,~{nosecaction},setvar:tx.noResponseBodyAccess,tag:security,tag:Output"

 # For compression (save TX.noResponseBodyAccess because modified in later phases)
 Use SecAction "phase:2,t:none,~{nosecaction},setvar:TX.noRespBodyAccess2=%{TX.noResponseBodyAccess}"
 Use SecRule &TX:noResponseBodyAccess "@eq 0" "phase:2,t:none,~{nosecaction},setenv:be_cannot_compress"
 Use SecRule &TX:resp_subst           "@eq 1" "phase:2,t:none,~{nosecaction},setenv:be_cannot_compress"
 # For debugging only
 Use CompressDebug_ 2
 Use CompressDebug_ 3
 Use CompressDebug_ 5
</IfDefine>

 # Final compression settings
 Use SecRule ENV:loopback   @unconditionalMatch "phase:4,t:none,~{skipAfter}:AfterCompress,setenv:no-gzip,setenv:dont-vary,setenv:!force-gzip,setenv:!force-gzip-https"
 Use SecRule ENV:force-gzip @unconditionalMatch "phase:4,t:none,~{skipAfter}:AfterCompress,setenv:!no-gzip,setenv:!no-brotli,setenv:dont-vary"

 # Don't compress if reverse proxy
 Use SecRule REMOTE_ADDR "~{RP_IP_Check}" "phase:4,t:none,chain,~{skipAfter}:AfterCompress"
  Use SecRule ENV:no-gzip-proxy @unconditionalMatch "t:none,setenv:no-gzip,setenv:!force-gzip,setenv:!force-gzip,setenv:!force-gzip-https,setenv:dont-vary"

  Use SecRule ENV:no-gzip    @unconditionalMatch "phase:4,t:none,~{nosecaction},setenv:dont-vary,setenv:no-brotli"
 Use SecMarker AfterCompress
 
 Use HeaderUnsetCond Vary env=dont-vary
 Header edit  Vary  "^[^*]*[*].*$"  "*"

# Disable caching if needed
#Use AdaptCachingHeaders

# For detection mode -> corrects some behaviours ------------------------------
# allow => stop processing rules in blocking mode
Use SecAction  "phase:2,~{allow}:phase,tag:framework,setvar:TX.allowed2"
Use SecAction  "phase:3,~{allow}:phase,tag:framework,setvar:TX.allowed3"
Use SecAction  "phase:4,~{allow}:phase,tag:framework,setenv:allowed4"

# The following rules are only executed in detection mode
Use SecAction  "phase:2,tag:security,~{nosecaction},setenv:detection"
# Restore original value of attack counter (in case it was modified during detection)
Use SecAction  "phase:4,tag:security,~{nosecaction},setvar:IP.blocked=%{TX.oldblocked},setvar:IP.BadAuth=%{TX.oldBadAuth}"
