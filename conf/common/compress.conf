DefineStr NoCompressLocations "(?:~{PathToIgnore}|[.](?:~{AllCompressedExt})$)"

DefineStr _MimeMultimedia "3gpp|audio|compress|h224|image|mp[2-4]|mpeg|\bogg\b|shockwave|silverlight|video|voice|xpinstall|zip"
DefineStr _MimeContainer  "archive|compress|package|xpinstall|zip"
# MS Office compressed: application/vnd.ms-....12 - ex: vnd.ms-word.document.macroEnabled.12
DefineStr _MimeOpenDoc    "^application/vnd[.](?:ms-.*[.]12$|openxmlformats|openofficeorg)"
DefineStr _MimeCompressed "(?:~{_MimeMultimedia}|~{_MimeContainer}|~{_MimeOpenDoc})"

# Compress files received by / sent to clients
# Initialisation
<IfModule mod_brotli.c>
 # Compress response to clients
 FilterProvider BROTLI_ALWAYS BROTLI_COMPRESS  "true"
 FilterProtocol BROTLI_ALWAYS BROTLI_COMPRESS  change=yes
 # We manage it ourself (buggy anyway?)
 BrotliAlterETag NoChange
 BrotliCompressionWindow 18
 BrotliCompressionQuality 4
 <IfDefine Debug>
  FilterTrace BROTLI_ALWAYS 1
 </IfDefine>

 # Allow to log compression ratio
 BrotliFilterNote Ratio compressionRatio

 Use SecRule REQUEST_HEADERS:Accept-Encoding  "(?:\bbr)(?! *; *q=0(?:[ ,]|$))" "phase:1,t:none,~{nosecaction},setenv:brotli_supported"
</IfModule>
<IfModule mod_deflate.c>
 # Limits for decompression
 DeflateInflateLimitRequestBody 500000
 DeflateInflateRatioLimit          500
 DeflateInflateRatioBurst            1

 # trade-off between compression and resource usage
 DeflateCompressionLevel  6
 DeflateMemLevel          9
 DeflateWindowSize       15
 # default is 8 KB, higher is chunked-encoded (impact on caching?)
 #DeflateBufferSize 50000

 # Compress response to clients
 FilterProvider COMPRESS_ALWAYS DEFLATE "true"
 FilterProtocol COMPRESS_ALWAYS DEFLATE change=yes
 <IfDefine Debug>
  FilterTrace COMPRESS_ALWAYS 1
 </IfDefine>

 # INFLATE is buggy: it decompresses GZIP files! Don't use it
 # Accept compressed content from clients
 #SetInputFilter DEFLATE


 # Allow to log compression ratio
 DeflateFilterNote compressionRatio

 Use SecRule &ENV:brotli_supported "@eq 0"  "phase:1,chain,t:none,~{nosecaction}"
 Use SecRule REQUEST_HEADERS:Accept-Encoding "(?:compress|deflate|gzip)(?! *; *q=0(?:[ ,]|$))" "t:none,setenv:gzip_supported"
</IfModule>

# Filter loading
<If "-n %{ENV:brotli_supported}">
 <IfModule brotli_module>
  FilterChain +BROTLI_ALWAYS
 </IfModule>
</If>
# In case Brotli is supported, ENV:gzip_supported is not set
<If "-n %{ENV:gzip_supported}">
 <IfModule deflate_module>
  FilterChain +COMPRESS_ALWAYS
 </IfModule>
</If>

# ------------- Decide which output has to be compressed -----------------------
  
# We need to force compression since we will modify the request header
# (Content-Encoding) which mod_deflate looks for
<Macro setCompressVars_ $header $pattern>
 Use SecRule REQUEST_HEADERS:$header "(?:$pattern)~{ContentNeg_Q1}" "phase:2,~{nosecaction},setenv:!no-gzip,setenv:force-gzip"
</Macro>
<Macro setCompressVars @pattern>
 Use setCompressVars_ Accept-Encoding @pattern
 Use setCompressVars_ TE              @pattern
</Macro>

<If "-z reqenv('be_shouldnt_compress')">
 # Disable compression if header does not exist
 Use SetEnvSec no-gzip 1
 Use setCompressVars "~{ContentNeg_CompressBasic_}|[*]"
 # MSIE 6 and below do not support JS & CSS compression => always disable (cf. other extension)
 Use SecRule REQUEST_HEADERS:User-Agent "\bMSIE [456]" "phase:2,~{nosecaction},setenv:no-gzip"
 # Don't compress images, multi-media, compressed files, etc. (based on MIME-Type)
 Use NoCompressionType "~{_MimeCompressed}"

 # Don't compress when in HTTPS (Breach attack) ------------------------------
 # Compress if referer is from same site (in HTTPS)
 Use SecRule ENV:referer_host "@streq %{REQUEST_HEADERS.HOST}"                                    "phase:4,t:none,~{skipAfter}:AfterBreach"
 # Compress static files
 Use SecRule TX:BASENAME "[.](?i:css|js|html|~{UncompressedFileExt}|~{TechnicalUpFileExt})$" "phase:4,t:none,~{skipAfter}:AfterBreach"
 # Compress if forced
 Use SecRule ENV:force-gzip-https "@eq 1"                                                         "phase:4,t:none,~{skipAfter}:AfterBreach"
  # Don't compress under HTTPS
  Use DoNotCompressPhase 4 ENV:HTTPS_ "."
 Use SecMarker AfterBreach

 # Don't compress loopback connections
 Use DoNotCompressPhase 2 ENV:loopback @unconditionalMatch

 # Don't compress if already compressed
 Use DoNotCompress ENV:resp_compressed "^"
</If>

# Don't compress too small files & too big files (not inside a location to allow to be overwritten in vhost)
Use NoCompressionSizeMin ~{CompressSizeMin}
Use NoCompressionSizeMax ~{CompressSizeMax}
