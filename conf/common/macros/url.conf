# :: Macros: Rules related to URL

# :: Allow some file extensions
#    Syntax: regex of extensions, like "ext1|ext2|ext(3|4)"
<Macro SecAllowExt $ext>
 # Phase 1 will only work in vhost context, not location
 Use SecRule TX:EXT "^(?i:$ext)$" "phase:2,~{nosecaction},tag:security,t:none,ctl:ruleRemoveById=2002400,setvar:tx.restricted_extensions=''"
</Macro>

# :: Allow all file extensions (also for downloads)
<Macro SecAllowAllExt>
 Use SecAction  "phase:2,~{nosecaction},tag:security,ctl:ruleRemoveById=2002400"
 Use SecAllowAllDownFileExt
</Macro>

# Allow upload of archive files
<Macro SecAllowArchiveDownLoad>
 Use SecAllowExt "~{ArchiveFileExt}"
</Macro>

# :: Allow some (specific) file extensions
#    Syntax: regex of extensions, like "ext1|ext2|ext(3|4)"
<Macro SecAllowBasenameExt_ @cond>
 Use SecRule TX:BASENAME @cond  "phase:2,tag:security,~{nosecaction},t:none,ctl:ruleRemoveById=2002400"
</Macro>

# :: Allow all characters set in basename (file) part of URL
<Macro SecAllowBasename__ $pattern $dotext>
 Use SecRule TX:BASENAME "$pattern(?i:$dotext)$"  "phase:2,t:none,~{nosecaction},setvar:TX.allow_basename"
</Macro>
<Macro SecAllowBasenameExt @pattern $ext>
 Use SecAllowBasename__  @pattern "[.](?:$ext)" 
</Macro>
<Macro SecAllowAllCharsInBasename_ @dotext>
 Use SecAllowBasename__ ""  @dotext
</Macro>
<Macro SecAllowAllCharsInBasenameExt $ext>
 Use SecAllowAllCharsInBasename_ "[.](?:$ext)"
</Macro>
<Macro SecAllowAllCharsInBasename>
 Use SecAction  "phase:2,~{nosecaction},setvar:TX.allow_basename"
</Macro>
<Macro SecAllowCharsInBasenameExt $chars @ext>
 # + allowed because of dedicated rule
 Use SecAllowBasenameExt "^[$chars+~{CharMin}]*" @ext
</Macro>
<Macro SecAllowCharsInBasename $chars>
 # + allowed because of dedicated rule
 Use SecAllowBasename__ "^[$chars+~{CharMin}]*" ""
</Macro>


<Macro ValidateFullUrl_ @target $chars $actions $query>
 Use SecRuleDeny @target "!^(?:~{syntax_URL_scheme}(?:/[+~{CharMin}<>/@%, $chars]*)?$query)?$" "t:none,~{status}:400,msg:'Invalid URL',logdata:'%{MATCHED_VAR}',$actions"
</Macro>
<Macro ValidateFullUrl @target @chars @actions>
 Use ValidateFullUrl_  @target @chars @actions "~{syntax_QueryStr}"
</Macro>
<Macro ValidateFullUrlAnyQuery @target @chars @actions>
 Use ValidateFullUrl_  @target @chars @actions "(?:[?].*|)"
</Macro>

<Macro ValidateReferer @chars>
 Use SecRuleRemoveByFullTag ValidReferer
 Use ValidateFullUrlAnyQuery REQUEST_HEADERS:Referer @chars "tag:Protocol,tag:ValidReferer,t:none,t:urlDecode,multiMatch"
</Macro>

# :: Allow character set in path of URL
#    Syntax: list or range of characters number
<Macro SecUrlPathAllowAllChars>
 Use SecRuleRemoveByID 3000002
</Macro>
# Allow only some characters in URL filename
# Warning: '+' is decoded as a space
<Macro SecUrlPathAllowOnlyChars_ $chars>
 Use SecUrlPathAllowAllChars
 Use SecRuleDeny TX:PATHNAME "[^$chars]"  "phase:2,t:none,~{status404},id:3000002,msg:'Invalid character in URL (Use SecUrlAllowChars)'"
</Macro>
# Allow only some characters in URL filename
<Macro SecUrlPathAllowChars $chars>
 # + allowed because of dedicated rules
 Use SecUrlPathAllowOnlyChars_ "$chars+~{CharMin}/"
 # Same rule for Referer
 Use ValidateReferer "$chars"
</Macro>

# :: Allow character set in URL
#    Syntax: list or range of characters number
<Macro SecRefererUrlAllowAllChars>
 # Allow all chars in Referer
 Use ValidateReferer "\x20-\x7e"
</Macro>
<Macro SecUrlAllowAllChars>
 Use SecUrlPathAllowAllChars
 Use SecAllowDotInUrl
 Use SecAllowAllCharsInBasename
 Use SecRefererUrlAllowAllChars
</Macro>
# Allow only some characters in URL filename
<Macro SecUrlAllowChars      @expr>
 Use SecUrlPathAllowChars    @expr
 Use SecAllowCharsInBasename @expr
</Macro>

# Allow '+' character in URL filename
<Macro SecUrlAllowPlus>
 Use SecRuleRemoveByID 2002921
</Macro>

# Allow double URL encoding
<Macro SecAllowDoubleUrlEncoding>
 Use SecRuleRemoveByID 2002102
</Macro>

<Macro SecAllowMultipleExtInUrl>
 Use SecRuleRemoveByID 2000107
 #Use SecAllowDotInUrl
</Macro>

<Macro SecAllowDotInUrl>
 Use SecRuleRemoveByID 2000112
</Macro>

# Allow technical keywords in URL (like /etc/, multiple extensions, ...) -> high risk ***"
<Macro SecAllowTechnicalInURL>
 Use SecAllowAllExt
 Use SecAllowPathInUrl
 Use SecRuleRemoveByFullTag URL
</Macro>

# Set TX.PATHNAME & TX.BASENAME
<Macro SetBasename_>
 Use NotInsideLocation
 Use SecRule TX:url "^(.*)/([^/]*)$"    "phase:1,~{nosecaction},t:none,capture,setvar:TX.PATHNAME=%{TX.1},setvar:TX.BASENAME=%{TX.2},setvar:TX.EXT="
 Use SecRule TX:BASENAME "[.]([^./]*)$" "phase:1,~{nosecaction},t:none,capture,setvar:TX.EXT=%{TX.1}"
</Macro>

# Remove part from url and assign pseudo-arg
<Macro ParseURL_ @pattern $var>
 # Capture parts
 Use NotInsideLocation
 Use SecRule TX:url @pattern "phase:1,~{nosecaction},t:none,capture,setvar:TX.url=%{TX.1}%{TX.3},setvar:TX.$var=%{TX.2}"
 Use SetBasename_
</Macro>

# Remove ARG from url
<Macro ParseArgInURL @pattern>
 Use ParseURL_ @pattern url_arg
</Macro>

<Macro TrustHostPhase $host $phase>
 Use SecRule TX:TrustedHosts "![|]$host(?:[|]|$)" "phase:$phase,t:none,~{nosecaction},setvar:'TX.TrustedHosts=%{TX.TrustedHosts}|$host'"
</Macro>
<Macro TrustHost    @host>
 Use NotInsideLocation
 Use TrustHostPhase @host 1
</Macro>

<Macro TrustDomain $domain>
 Use NotInsideLocation
 Use SecAction  "phase:1,~{nosecaction},setvar:'TX.TrustedHosts=%{TX.TrustedHosts}|(?:~{HostChars}+[.])?$domain'"
</Macro>

DefineStr UrlBeforePattern_ "(?<![a-zA-Z0-9])"
DefineStr UrlPattern_ "(?:~{UrlBeforePattern_}//(?=[a-zA-Z0-9])(?!~{TrustedLocations})~{HostChars}*)"
# Macro only valid for a single var, not a collection
<Macro CheckUriVarPhase_ $phase @var $proto $id $action>
 # $id may contain env settings => no inclusion when not needed
 Use SecRuleDeny @var "($proto~{UrlPattern_})" "phase:$phase,t:~{jsDecode},tag:URLINC,tag:Slash,~{errorPage}url_inc,msg:'Remote File Inclusion (URL) (allow with <DefineStr TrustedDomains/TrustedHosts> or <Use SecAllowURL>)',logdata:'%{TX.URLINC_VAR} contains <%{TX.URLINC}>',setenv:'errorMsg=URL forbidden in request',id:$id,$action,capture,setvar:TX.URLINC_VAR=%{MATCHED_VAR_NAME},setvar:TX.URLINC=%{TX.1}"
</Macro>
<Macro CheckUriPhase__ $phase @coll $proto $id $tfn $block_action>
 # $id may contain env settings => no inclusion when not needed
 # Full rule is very slow, so let's pre-analyse it
 Use SecRule @coll "~{UrlBeforePattern_}//[a-zA-Z0-9]" "phase:$phase,chain,t:~{jsDecode},$tfn,~{errorPage_}url_inc,tag:security,tag:URLINC,tag:Slash,id:$id,msg:'Remote File Inclusion (URL) (allow with <DefineStr TrustedDomains>, <DefineStr TrustedHosts> or <Use SecAllowURL>)',logdata:'%{TX.URLINC_VAR} contains <%{TX.URLINC}>'"
  Use SecRule MATCHED_VARS "($proto~{UrlPattern_})"   "t:none,capture,setvar:TX.URLINC_VAR=%{MATCHED_VAR_NAME},setvar:TX.URLINC=%{TX.1},~{increaseBlockCounter},setenv:'errorMsg=URL forbidden in request',setenv:errorPage=url_inc,$block_action"
</Macro>
<Macro CheckUriPhase_ $phase @coll @proto @id>
 Use CheckUriPhase__  $phase @coll @proto @id "" ""
</Macro>
<Macro CheckUri_      @coll @proto @id>
 Use CheckUriPhase_ 2 @coll @proto @id
</Macro>
<Macro CheckUri2_ @coll $id1 $id2>
 # Remote Protocol Inclusion: //...
 Use CheckUri_ @coll "(?<![-a-zA-Z0-9+_/]|%{tx.allowedUrlProtos})" "$id1,tag:XPath,tag:Base64"

 # Redundant with previous rule (when previous not disabled)
 Use SkipAfterOnSuccess  "$id1,tag:security,tag:URLINC,tag:Slash,tag:XPath,tag:Base64" AfterCheckProto
  # Remote File Inclusion: protocol:// (in case previous check is disabled)
  Use CheckUri_ @coll "\bhttps?:" "$id2,tag:Colon"
 Use SecMarker AfterCheckProto,tag:security,tag:URLINC,tag:Slash,tag:XPath,tag:Base64
</Macro>
<Macro CheckUriInArgs_ $id1 $id2>
 Use CheckUri2_ "~{args}" "$id1,tag:ARGS,tag:SecRuleArgs" "$id2,tag:ARGS,tag:SecRuleArgs"
</Macro>
<Macro CheckUriInHeaders_ $id1 $id2>
 Use CheckUri2_ "~{ReqHeaders}|!REQUEST_HEADERS:Authorization" "$id1,tag:Header,tag:SecRuleHeaders" "$id2,tag:Header,tag:SecRuleHeaders"
</Macro>
<Macro CheckUriInCookies_  $id1 $id2>
 Use CheckUri2_ ~{cookies} $id1,tag:COOKIE,tag:SecRuleCookies $id2,tag:COOKIE,tag:SecRuleCookies
</Macro>
<Macro CheckUriInBody_ $id1 $id2>
 Use CheckUri2_ STREAM_INPUT_BODY "$id1,tag:ARGS" "$id2,tag:ARGS"
</Macro>
<Macro CheckUriInXMLBody_ $id1 $id2>
 <IfDefine !noXML>
  Use SecRule &ENV:req_xml "@eq 0"       "phase:2,t:none,~{skipAfter}:AfterCheckUriInBody_,tag:security,tag:URLINC,tag:Slash"
   Use CheckUriInBody_ "$id1,msg:'Remote File Inclusion (URL) in XML body'" "$id2,msg:'Remote File Inclusion (URL) in XML body'"
  Use SecMarker AfterCheckUriInBody_,tag:security,tag:URLINC,tag:Slash
 </IfDefine>
</Macro>

# Block URL inside <tags> only
<Macro CheckUriInXMLEntities_ $id1 $id2>
 <IfDefine !noXML>
  # $id may contain env settings => no inclusion when not needed
  Use SecRule &ENV:req_xml "@eq 0"       "phase:2,t:none,~{skipAfter}:AfterCheckUriInXMLEntities_,tag:security,tag:URLINC,tag:Slash"
   Use SecRuleDeny STREAM_INPUT_BODY "<[^>]*[^-.a-z0-9+_](~{UrlPattern_})" "phase:2,tag:URLINC,tag:Slash,t:~{jsDecode},capture,setenv:'errorMsg=URL forbidden in XML entity',logdata:'%{TX.1}',~{errorPage}url_inc,id:$id1,msg:'URL forbidden in XML entity, allow with [DefineStr TrustedDomains] [DefineStr TrustedHosts]',tag:XPath"
   Use SkipAfterOnSuccess  $id1,tag:security,tag:URLINC,tag:Slash AfterCheckUriInXMLEntities_
    Use SecRuleDeny STREAM_INPUT_BODY "<[^>]+:/?(~{UrlPattern_})"          "phase:2,tag:URLINC,tag:Slash,t:~{jsDecode},capture,setenv:'errorMsg=URL forbidden in XML entity',logdata:'%{TX.1}',~{errorPage}url_inc,id:$id2,msg:'URL forbidden in XML entity, allow with [DefineStr TrustedDomains] [DefineStr TrustedHosts]'"
  Use SecMarker AfterCheckUriInXMLEntities_,tag:security,tag:URLINC,tag:Slash
 </IfDefine>
</Macro>
