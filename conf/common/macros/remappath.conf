# :: Macros: Rewrite path

# Remap a file extension to another one
<Macro SecRemapExt $ext1 $ext2>
 RewriteOptions InheritBefore
 RewriteRule  "^(.*)[.]$ext2$"  "$1.$ext1"  [NC,PT,NE,DPI]
</Macro>

# Fix missing trailing slash
<Macro NoTrailingSlash>
 Use SetEnvEarly NoTrailingSlash on
</Macro>
<Macro FixTrailingSlash $path>
 RewriteOptions InheritBefore
 RewriteCond %{REMOTE_ADDR} "!~{IpLocalHostRegex}"
  RewriteCond %{ENV:NoTrailingSlash} "!^on$"
   RewriteRule  "^(?i:$path)$"   "$path/"  [NC,NE,L,R=~{redirect308},NS,DPI]
</Macro>
  
<Macro CheckSSL_ $env  $pattern  $var>
 # We can use RewriteRule to set env var because this macro is always used
 # before the real URL rewriting rules
 RewriteOptions InheritBefore
 RewriteCond %{$env} "$pattern" [NC]
 #RewriteCond %{ENV:PathToIgnore}" ""
   RewriteRule ^ - [E=$var]
</Macro>

# Check if front-end in HTTPS
# HTTPS is set to "off" in case of HTTP => not usable for "Header ... env=HTTPS"
<Macro CheckSSL>
 Use CheckSSL_  HTTPS                  "^on$"           HTTPS_:on,Skip=5
 Use CheckSSL_  ENV:notProxyFE         .               !HTTPS_,Skip=4
 Use CheckSSL_  HTTP:Front-End-Https   "^on$"           HTTPS_:on,Skip=3
 Use CheckSSL_  HTTP:X-SSL             "decrypted=true" HTTPS_:on,Skip=2
 Use CheckSSL_  HTTP:X-Forwarded-Proto "^https$"        HTTPS_:on,Skip=1
 Use CheckSSL_  HTTP:X-Forwarded_Proto "^https$"        HTTPS_:on
</Macro>

# Treat this location as SSL 
<Macro NotifySSLtoBackend>
  # ::Notify back-end server that we use HTTPS on the front-end server
  # For Outlook Web Access
  RequestHeader set Front-End-Https On
  RequestHeader set X-Forwarded-Proto https
  # For Ruby on Rail applications
  RequestHeader set X-Forwarded_Proto https
  # For some frameworks
  RequestHeader set X-SSL decrypted=true

  # Enforce SSL for all included resources
  Use SecurityHeaderSSLOnly "X-Frame-Options"   "ALLOW-FROM"
  Use CSPEdit $ ";upgrade-insecure-requests;block-all-mixed-content"
  Use CSPEdit "(?=;upgrade-insecure-requests;block-all-mixed-content;.*);upgrade-insecure-requests;block-all-mixed-content" ""
</Macro>

# Force a location to SSL 
<Macro EnforceSSL $host $path>
 # Refuse HTTP connections
 #SSLRequireSSL
 # Redirect to SSL (just for user friendlyness, is also protected with SSLRequireSSL)
 Use CheckSSL
 RewriteOptions InheritBefore
 # For GET
 RewriteCond %{ENV:PathToIgnore} ""
  RewriteCond %{ENV:HTTPS_} "!." [NC]
   RewriteCond %{THE_REQUEST}  "^(GET|HEAD|OPTIONS) "
    RewriteRule "^(?:$path(?:/.*)?)$" "https://$host%{REQUEST_URI}" [NE,L,R=301,NS,DPI]

 # For POST
 RewriteCond %{ENV:PathToIgnore} ""
  RewriteCond %{ENV:HTTPS_} "!." [NC]
    RewriteRule "^(?:$path(?:/.*)?)$" "https://$host%{REQUEST_URI}" [NE,L,R=308,NS,DPI]

 <Location $path/>
  Use NotifySSLtoBackend
 </Location>

 # %{HOST}e not supported in pattern, just for future compatibility
 Use RemapURLAbsolute "~{encodedHttp}($host|%{HOST}e)(?::80)?(?=$path)"  "https$1$2"
</Macro>

# :: Fixes path case (check on InvalidProxyCase avoids loops)
<Macro FixPathCase $path>
 RewriteOptions InheritBefore

 RewriteCond %{REQUEST_URI}   "^$path(?:/|$)"  [NC]
  RewriteCond %{REQUEST_URI}   "!^$path(?:/|$)"
   RewriteRule ^ - [E=InvalidProxyCase:1,DPI]

 RewriteCond %{ENV:InvalidProxyCase}  1
  RewriteCond %{THE_REQUEST}  "^(GET|HEAD|OPTIONS) "
   RewriteRule "^$path(/.*)?$"   "$path$1"  [NC,NE,L,R=302,NS,DPI]

 RewriteCond %{ENV:InvalidProxyCase}  1
   RewriteRule "^$path(/.*)?$"   "$path$1"  [NC,NE,L,R=307,NS,DPI]
</Macro>

<Macro ProxyPreserveHost $switch>
 ProxyPreserveHost $switch
 Use SetEnvRew ProxyPreserveHost $switch
</Macro>

# :: Remap URL in query string by default
<Macro NoRemapURLInQuery>
 Use SetEnvRew noRemapURLInQuery 1
 # Not effective in URL, but used in vhost,also inside NoRemapURL
 #Use NotInsideLocation
</Macro>
<Macro NoRemapURLInQueryExt @url>
 RewriteCond %{REQUEST_URI} @url
  Use NoRemapURLInQuery
</Macro>

<Macro FixRequestQueryPath $frontServer $frontPath $http $backServer $backPort $backPath>
 RewriteOptions InheritBefore
 # set targetBackend following ProxyPreserveHost value
 RewriteRule ^  - [E=targetBackend:$frontServer$backPath,NE,DPI]
 RewriteCond %{ENV:ProxyPreserveHost}  "off"  [NC]
  Use SetEnvRew targetBackend $backServer:$backPort$backPath

 # set targetBackend to load-balancer worker if needed
 RewriteCond %{ENV:ProxyPreserveHost}  "off"  [NC]
  RewriteCond %{ENV:WORKER_NAME}  "!^\x5e"
   Use SetEnvRew targetBackend %{ENV:WORKER_NAME}

 # remove port 80/443 from targetBackend
 RewriteCond %{ENV:targetBackend}  "^(.*):(?:80|443)$"
  Use SetEnvRew targetBackend %1

 # remap in query if needed
 Use SecRule ENV:noRemapURLInQuery "@eq 1"          "phase:2,t:none,~{skipAfter}:AfterQueryRemapUrl"
 Use SecRule REQUEST_URI "!^$frontPath~{AbsUrlEnd}" "phase:2,t:none,~{skipAfter}:AfterQueryRemapUrl"
  Use SecRule QUERY_STRING "^(?i)(.*)~{encodedHttpx}(?:$frontServer|%{REQUEST_HEADERS:Host})$frontPath(~{AbsUrlEnd}.*)?$" "phase:2,t:none,capture,~{nosecaction},setenv:QUERY_DECODED=%{TX.1}$http%{TX.2}$frontServer$backPath%{TX.3},t:urldecode,setvar:tx.querydecode"
  Use SecRule ENV:QUERY_DECODED @unconditionalMatch "phase:2,t:none,t:urlencode,~{nosecaction},setenv:QUERY_DECODED=%{MATCHED_VAR}"
 Use SecMarker AfterQueryRemapUrl 
 RewriteCond %{ENV:QUERY_DECODED} .
  RewriteRule "^([^?]*).*$"  "$1?%{ENV:QUERY_DECODED}"  [B,DPI,E=backend_fullpath:$1?%{ENV:QUERY_DECODED}]
 RewriteCond %{ENV:QUERY_DECODED} ^$
  RewriteCond %{THE_REQUEST} "^[a-zA-Z]+ ([^ ]+)"
   RewriteRule ^ - [E=backend_fullpath:%1?%{QUERY_STRING}]
</Macro>

# Subst host in query string
#<Macro SubstRequestQueryPathHost $frontServer $backServer>
# RewriteCond %{QUERY_STRING}   "^(.*~{encodedHttpx})$frontServer(.*)?$"  [NC]
#  RewriteRule "^(.*)$"   "$1?%1$backServer%2"  [DPI,NEXT=3]
#</Macro>

# :: Remap URL in args
<Macro FixArgsPath $frontServer $frontPath $http $backServer $backPort $backPath>
 Use FixRequestQueryPath "$frontServer" "$frontPath" $http "$backServer" $backPort "$backPath"
 #todo: replace in args
</Macro>

