# :: Macros: Proxy

# Slower but safer connection to client
<Macro SafeSlowClientConnection>
 # Suppress pooling
 SetEnv proxy-initial-not-pooled
</Macro>

# Safer connection to back-end
<Macro BackConnectionHttp1.0>
 # Always send Content-Length instead of chunked (safer)
 Setenv proxy-sendcl
 # Add extra CR/LF to end of request (solve problems with some back-end servers)
 Setenv proxy-sendextracrlf

 # To avoid problems with chunked encoding from back-end that is misinterpreted
 # Both settings must always be set together
 Setenv force-proxy-request-1.0
 RequestHeader unset Expect early
</Macro>

# Slower but safer connection to back-end
<Macro BackConnectionHttp1.0-Slow>
 Use BackConnectionHttp1.0
 SetEnv proxy-nokeepalive
</Macro>

# Send various info to back-end ------------------------------------------------
# Create environment variable from a collection
<Macro Col2Env_ $phase $res $counter>
 Use SecAction "phase:$phase,~{nosecaction},setenv:waf-$res-$counter=%{$res.$counter}"
</Macro>
<Macro Col2Env @res @counter>
 Use Col2Env_ 2 @res @counter
 <IfDefine ClientStatus>
  Use Col2Env_ 1 @res @counter
  Use Col2Env_ 3 @res @counter
  Use Col2Env_ 4 @res @counter
 </IfDefine>
</Macro>

# Send an environment variable in a header
<Macro SendWafInfoVar_ $header $var>
 Use SetSSLHeaderEnv X-WAF-$header $var
 RequestHeader unset X-WAF-$header env=unsetWafheaders

 <IfDefine EXTENDEDSTATUS>
  # Remove headers for internal requests
  #Use HeaderUnsetIfInternal_ X-WAF-$header
 </IfDefine>
</Macro>
<Macro SendWafInfoVar @var>
 Use SendWafInfoVar_ @var @var
</Macro>
<Macro SendWafInfo_ $res $counter $header>
 Use SendWafInfoVar_ $header "waf-$res-$counter"
</Macro>

# Send an environment variable in a header
<Macro SendClientInfoVar_ $h $var>
 <IfDefine ClientStatus>
  # For ErrorDocument, headers not processed => processed in sub-phase where VAR becomes REDIRECT_VAR
  Header        set X-WAF-$h "%{REDIRECT_$var}e" "expr=-z resp('X-WAF-$h') && -n reqenv('REDIRECT_$var')"
  Header always set X-WAF-$h "%{$var}e"          "expr=-z resp('X-WAF-$h') && -z reqenv('REDIRECT_$var') && -n reqenv('$var')"
  # Cleanup
  Use SendWafInfoVar_ $h $
 </IfDefine>
</Macro>

<Macro SendWafInfoColExt $res $counter $header>
 Use Col2Env             $res $counter
 Use SendWafInfo_        $res $counter $header
</Macro>
<Macro SendWafInfoCol  $res $counter>
 Use SendWafInfoColExt $res $counter $res-$counter
</Macro>

<Macro SendWafInfo>
 <Location />
  # For loopback requests
  SecRule REMOTE_ADDR "@ipMatch ~{IpLocalhost}" "phase:5,t:none,~{nosecaction},setenv:geo_country_name=%{REQUEST_HEADERS.X-country_name},setenv:geo_city=%{REQUEST_HEADERS.X-city},setenv:WAF_USER=%{REQUEST_HEADERS.X-city},setvar:IP.blocked=%{REQUEST_HEADERS.X-waf-IP-blocked},setvar:IP.BadAuth=%{REQUEST_HEADERS.X-waf-IP-BadAuth},setvar:IP.dos=%{REQUEST_HEADERS.X-waf-IP-dos}"

  Use  SecRule ENV:loopback @unconditionalMatch "phase:2,t:none,~{skipAfter}:AfterSendWafInfoCols,tag:security"
  <IfDefine ClientStatus>
   Use SecRule ENV:loopback @unconditionalMatch "phase:3,t:none,~{skipAfter}:AfterSendWafInfoCols,tag:security"
   Use SecRule ENV:loopback @unconditionalMatch "phase:4,t:none,~{skipAfter}:AfterSendWafInfoCols,tag:security"
   Use SecRule  IP:blocked "^$"    "phase:2,t:none,~{nosecaction},setvar:IP.blocked=0,tag:security"
   Use SecRule &IP:blocked "@eq 0" "phase:2,t:none,~{nosecaction},setvar:IP.blocked=0,tag:security"
  </IfDefine>
   Use SendWafInfoCol    IP      blocked
   Use SendWafInfoCol    IP      BadAuth
   Use SendWafInfoCol    IP      dos
   Use SendWafInfoColExt IP      UPDATE_COUNTER IP-UPDATE-COUNTER
   Use SendWafInfoColExt IP      UPDATE_RATE    IP-UPDATE-RATE
   Use SendWafInfoCol    IP      ReqNb
   Use SendWafInfoCol    SESSION blocked
   #Use SendWafInfoCol    SESSION BadAuth
   Use SendWafInfoCol    TX      heuristic
   #Use SendWafInfoCol    TX      ua-hash
   Use SendWafInfoColExt TX      resp_size resp-size

   #Use SendClientInfoVar_  WarnIds    WarnRuleId
   Use SendClientInfoVar_  BlockIds   BlockRuleId
   Use SendClientInfoVar_  LastSecMsg LastSecMsg
   RequestHeader unset X-WAF-EXTENDEDSTATUS
   <IfDefine EXTENDEDSTATUS>
    Setenv WAF_EXTENDEDSTATUS 1
    RequestHeader set X-WAF-EXTENDEDSTATUS 1
    Use SecAction "phase:2,~{nosecaction},setenv:AuthHeader=%{REQUEST_HEADERS.Authorization}"
    Use SecRule FILES          @unconditionalMatch "phase:2,~{nosecaction},setenv:'upload-files=%{MATCHED_VAR},%{ENV.upload-files}'"
    Use SecRule TX:uploadfname @unconditionalMatch "phase:2,~{nosecaction},setenv:'upload-files=%{MATCHED_VAR},%{ENV.upload-files}'"
    Use SendWafInfoCol    IP      TIMEOUT
    Use SendWafInfoColExt IP      LAST_UPDATE_TIME IP-LAST-UPDATE-TIME
    Use SendWafInfoVar_   IP-Addr CLIENT-IP
    # May be too long: Use SendWafInfoVar    LastSecData
    Use SendWafInfoVar    max-nb-ARGS
    Use SendWafInfoVar    max-nb-FILES
    Use SendWafInfoVar    max-nb-REQUEST-COOKIES
    Use SendWafInfoVar    max-len-ARGS
    Use SendWafInfoVar    max-FILES-SIZES
    Use SendWafInfoVar    max-len-REQUEST-COOKIES
    Use SendWafInfoVar    max-len-ARGS-NAMES
    Use SendWafInfoVar    max-len-FILES-NAMES
    Use SendWafInfoVar    max-len-REQUEST-COOKIES-NAMES
    Use SendWafInfoVar    max-FILES-COMBINED-SIZE
    Use SendWafInfoVar    max-FULL-REQUEST-LENGTH
    Use SendWafInfoVar    max-REQUEST-BODY-LENGTH
    Use SendWafInfoVar    max-RESPONSE-CONTENT-LENGTH
    Use SendWafInfoVar    max-ARGS-COMBINED-SIZE
    Use SendWafInfoVar    args-total-size
    Use SendWafInfoVar    noIncreaseBlockCounter
    Use SendWafInfoVar_   Upload-filename upload-files
    Use SendWafInfoVar    unknownCookies
    Use SendWafInfoVar    allowedCookies
    Use SendWafInfoVar    X509_USER_ALLOWED
    Use SendWafInfoVar    X509_USER_NOT_ALLOWED
    Header always set X-WAF-RespBodyCompressedWarning 1 env=respBodyCompressedWarning

    Header always edit* X-WAF-allowedCookies "REQUEST_COOKIES:" ""
    Header always edit* X-WAF-allowedCookies "Client-IP=[^;]*;" ""
    Header always edit* X-WAF-allowedCookies "[*]waf_user=[^;]*;" ""
    RequestHeader set AuthHeader "%{AuthHeader}e"  env=AuthHeader
    Use SendResponseHeaders_
   </IfDefine>
   Use SecMarker AfterSendWafInfoCols,tag:security
 </Location>
</Macro>

<Macro AddBackendIP $besec> 
 Use SecAction "phase:1,~{nosecaction},setvar:'TX.be=$besec'"
 Use SecRule TX:be "^https?://([0-9.]+)" "phase:1,t:none,~{nosecaction},capture,setvar:'TX.backend=%{TX.backend},%{TX.1},'"
 Use SecRuleRemoveByFullTag tx_backend
 Use SecRule TX:backend ",%{REMOTE_ADDR}," "phase:1,t:none,tag:tx_backend,~{stopSecurity}"
</Macro>

# :: Create a proxy forwarding, with URL rewriting in body
#   $frontServer = server name, as seen on reverse proxy (cannot contain environment variables)
#   $frontPath   = path as seen on reverse proxy, without trailing slash
#   $backHttp    = protocol to connect to back-end server: "http", "https" or "balancer"
#   $backend     = back-end server + port + path (compatible with load-balancer), mod_headers syntax %{...}e
#   $besec       = same as $backend, but with a ModSecurity syntax
<Macro ProxySetInfo1___ $frontServer $frontPath $backend $besec>
 # Some requests may come from the back-end (loopback) => accept them (if IP was used, not FQDN)
 # Phase 1 => possibly several ones in the same vhost
 Use AddBackendIP $besec

 Use FixTrailingSlash "$frontPath"
 Use FixPathCase      "$frontPath"

 RewriteOptions InheritBefore
 RewriteCond %{ENV:backend} "^$"
  RewriteCond %{HTTP_HOST} "^$frontServer$"
   RewriteCond %{REQUEST_URI} "^($frontPath)(?:[/?]|$)"
    RewriteRule ^ - [E=frontPath:%1,E=backend:$backend] 

 # Allow this path
 Use SecRule REQUEST_URI_RAW "^(?i)(?:%{ENV.frontPath})(?:[/?]|$)"   "phase:1,t:none,~{nosecaction},setenv:locationOK"
</Macro>
# :: Create a proxy forwarding, with URL rewriting in headers & body
<Macro ProxySetInfo1__ $frontHttp $frontServer  $frontPath  $backend $besec>
 Use ProxySetInfo1___             $frontServer "$frontPath" $backend $besec
 
 <Location $frontPath/>
  # / cannot be used in a namespace
  # Use SecWebAppId "$frontServer%{ENV.frontPath}/"

  # Info on proxying for back-end to adapt links path
  RequestHeader set  X-Proxy-RequestRoot "$frontHttp://$frontServer$frontPath/"
  RequestHeader set  X-Proxy-RequestPath "$frontPath/"
  RequestHeader set  X-Proxy-BackendRoot "%{backend}e/"
 </Location>
</Macro>
<Macro ProxySetInfo1_ @frontHttp @frontServer @frontPath @backend>
 Use ProxySetInfo1__  @frontHttp @frontServer @frontPath @backend @backend
</Macro>
<Macro ProxyExt__   $frontHttp $frontServer  $frontPath   $backend $proxyParams>
 Use ProxySetInfo1_ $frontHttp $frontServer "$frontPath" "$backend"

 # Proxy request in case of missing slash is allowed (proxying of a page, not a dir)
 RewriteRule "^$frontPath$"   "$backend"  [P,NE,DPI]

 <Location $frontPath/>
  # Proxy request inside location because ProxyPass is executed before RewriteRule (in same context)
  # Rem: RewriteRule does not work correctly inside a location
  # Limitation: cannot use ProxySet (ProxyPass should be set at the global level)
  #   => 2.4.24 setenv no-proxy
  <IfDefine !ForceMockApi>
   ProxyPass "$backend/" $proxyParams
  </IfDefine>
  <IfDefine ForceMockApi>
   ProxyPass "http://~{MockServer}:~{MockPort}~{MockPath}/" $proxyParams
   # We manage Origin ourself
   RequestHeader unset Origin
  </IfDefine>
 </Location>
</Macro>

# :: Create a balancer proxy forwarding, with URL rewriting in headers & body
#   @frontHttp  = protocol to connect to WAF: "http" or "https"
#   @frontServer = external FQDN (reverse proxy)
#   @frontPath  = path as seen on reverse proxy, without trailing slash
#   @backend    = balancer://back-end:port/path
<Macro ProxyExtBalancer @frontHttp @frontServer @frontPath @backend>
 Use ProxyExt__         @frontHttp @frontServer @frontPath @backend ""
</Macro>
<Macro BalancerMember @backend                                            $params>
 BalancerMember       @backend ~{ProxyPassParams} ~{BalancerMemberParams} $params
 ProxySet ~{BalancerParams}
</Macro>
# For compatibility with Mediahub365 (obsolete)
<Macro BalancerMemberWS @backend  $params>
 Use   BalancerMember   @backend "$params ~{ProxyPassParamWS}"
</Macro>

# :: Create a proxy forwarding, with URL rewriting in headers
#   $frontHttp   = protocol to connect to WAF: "http" or "https"
#   $frontServer = external FQDN (cannot contain environment variables)
#   $frontPort   = port on reverse proxy
#   $frontPath   = path as seen on reverse proxy, without trailing slash (cannot contain environment variables)
#   $backHttp    = protocol to connect to back-end server: "http", "https" or "balancer"
#   $backServer  = real Web server (full DNS name or IP address), mod_headers syntax
#   $backPort    = port of real Web server
#   $backPath    = path of real Web server, without trailing slash
#   $besec       = same as $backServer, but with a ModSecurity syntax
<Macro ProxySetInfo2___ $besec>
 # Phase 1 for most cases, phase 3 to resolve back-end in balancer (only for phases 4+)
 Use TrustHostPhase "$besec" 1
 Use TrustHostPhase "$besec" 3
</Macro>
# :: Create a proxy forwarding, with URL rewriting in headers
<Macro ProxySetInfo2__ $frontHttp $frontServer $frontPort  $frontPath  $backHttp $backServer $backPort  $backPath  $besec>
 <If "'$backHttp:$backPort' =~ /^(?:http:443|https:80(?:80)?)$/">
  Use LogOncePerApp "$backHttp on port $backPort: ProxyExt__ $frontPath $backHttp $besec $backPort $backPath" 1 "tag:proxy,tag:config"
 </If>
 Use ProxySetInfo2___  $besec
 # :: Change path in headers (used in redirections, etc.) sent back
 Use FixHeadersPath $frontHttp $frontServer $frontPort "$frontPath" $backHttp $backServer $backPort "$backPath"
 <Location $frontPath/>
  ProxyPassReverseCookieDomain $backServer $frontServer

  # Fix Set-Cookie path
  Use FixServerCookieDomain
  Use FixServerCookiePath "$backPath"  "$frontPath"

  # Info on proxying for back-end to adapt links path
  RequestHeader set  X-Proxy-BackendRoot "$backHttp://$backServer:$backPort$backPath/"
  RequestHeader set  X-Proxy-BackendPath "$backPath/"
 </Location>
</Macro>
<Macro ProxySetInfo2_ @frontHttp @frontServer @frontPort @frontPath @backHttp @backServer @backPort @backPath>
 Use ProxySetInfo2__  @frontHttp @frontServer @frontPort @frontPath @backHttp @backServer @backPort @backPath @backServer
</Macro>
# :: Create a proxy forwarding, with URL rewriting in headers, query & body
# parameters: see ProxySetInfo2_
<Macro ProxySetInfo3_ $frontHttp $frontServer $frontPort  $frontPath  $backHttp $backServer $backPort @backPath>
 Use   ProxySetInfo2_ $frontHttp $frontServer $frontPort "$frontPath" $backHttp $backServer $backPort @backPath
 # :: Change path in pages sent back
 Use FixBodyPath $frontHttp $frontServer $frontPort "$frontPath" $backServer $backPort @backPath
 # :: Change path in URL query
 <Location $frontPath/>
  Use FixArgsPath $frontServer "$frontPath" $backHttp $backServer $backPort @backPath
 </Location>
</Macro>

<Macro ProxyExt_    $frontHttp $frontServer $frontPort @frontPath $backHttp $backServer $backPort $backPath>
 Use ProxyExt__     $frontHttp $frontServer            @frontPath "$backHttp://$backServer:$backPort$backPath" "~{ProxyPassParams} ~{ProxyPassParamWS}"
 Use ProxySetInfo3_ $frontHttp $frontServer $frontPort @frontPath  $backHttp   $backServer $backPort "$backPath"
</Macro>

# :: Create a proxy forwarding
#   @frontServer = external FQDN (reverse proxy)
#   @frontPath   = path as seen on reverse proxy, without trailing slash
#   @http         = protocol to connect to back-end server: "http" or "https"
#   @backServer = real Web server (full DNS name or IP address)
#   @backPort   = port of real Web server
#   @backPath   = path of real Web server, without trailing slash
<Macro ProxyExt      @frontServer    @frontPath @http @backServer @backPort @backPath>
 Use ProxyExt_  http @frontServer 80 @frontPath @http @backServer @backPort @backPath
</Macro>

# :: Create a proxy forwarding
#   @frontServer = external FQDN (reverse proxy)
#   @frontPath   = path as seen on reverse proxy, without trailing slash
#   @backServer = real web server (full DNS name or IP address)
<Macro Proxy $frontServer $frontPath $backServer>
 ######################Use RemapURLAbsoluteDefaultPort http $frontServer "$frontPath"      $backServer    @backPath
 Use ProxyExt                         $frontServer "$frontPath" http $backServer 80 "$frontPath"
 # To stop remapping
 <Location $frontPath/>
  Use RemapURLAbsoluteDefaultPort http $frontServer "$frontPath"      $backServer    "$frontPath"
 </Location>
</Macro>

# :: Create a proxy forwarding
#   @unused      = unused parameter for compatibility with ProxyExt_ syntax
#   @frontServer = external FQDN (reverse proxy)
#   @frontPort   = port on reverse proxy
#   @frontPath   = path as seen on reverse proxy, without trailing slash
#   @http        = protocol to connect to back-end server: "http" or "https"
#   @backServer  = real Web server (full DNS name or IP address)
#   @backPort    = port of real Web server
#   @backPath    = path of real Web server, without trailing slash
<Macro ProxySSLExt_ @unused @frontServer @frontPort @frontPath @http @backServer @backPort @backPath>
 Use UnusedParam @unused
 Use EnforceSSL @frontServer @frontPath
 Use ProxyExt_ https @frontServer @frontPort @frontPath @http @backServer @backPort @backPath
</Macro>
<Macro ProxySSLExt @frontServer @frontPath @http @backServer @backPort @backPath>
 Use ProxySSLExt_ https @frontServer 443 @frontPath @http @backServer @backPort @backPath
</Macro>

# :: Create a proxy forwarding
#   @frontPath   = path as seen on reverse proxy, without trailing slash
#   @backServer = real web server (full DNS name or IP address)
<Macro ProxySSL  $frontServer  $frontPath       $backServer>
 ######################Use RemapURLAbsoluteDefaultPort https $frontServer "$frontPath" $backServer @backPath
 Use ProxySSLExt $frontServer "$frontPath" http $backServer 80 "$frontPath"
 # To stop remapping
 ######################<Location $frontPath/>
 ###################### Use RemapURLAbsoluteDefaultPort https $frontServer "$frontPath" $backServer "$frontPath"
 ######################</Location>
</Macro>

<Macro AllowLocalPages>
 Use Setenv locationOK 1
</Macro>
<Macro EnforceLocalPages>
 RewriteOptions InheritBefore
 Use AllowLocalPages
 RewriteRule ^ -  [L,NE,DPI]
</Macro>

# Caching ----------------------------------------------------------------------
# "post-check=0, pre-check=0" should not be used => https://blogs.msdn.microsoft.com/ieinternals/2009/07/20/internet-explorers-cache-control-extensions/
# "must-revalidate, max-age=0" is equivalent to "no-cache"
# "no-cache" forbids file download in IE
# "no-store" not supported by some old browsers => add "must-revalidate, max-age=0"
# "immutable": only FF & Safari (2021-03)
# "stale-while-revalidate": only FF, Chrome & Edge 12+ (2021-03)
# benchmark: http://stackoverflow.com/questions/49547/making-sure-a-web-page-is-not-cached-across-all-browsers

# Disable page caching
<Macro NoCache__ $always @expr>
 <IfDefine !noCacheChange>
  Header $always set   Cache-Control "must-revalidate, max-age=0, no-cache, no-store"  @expr
  # For IE
  Header $always set   Vary          "*"           @expr
  # For HTTP 1.0
  Header $always set   Pragma        "no-cache"    @expr
  Header $always set   Expires       "0"           @expr
 </IfDefine>
</Macro>
<Macro NoCacheCondAlways_ @expr>
 <IfDefine !noCacheChange>
  Use NoCache__ always @expr
  Use HeaderAlwaysUnset Cache-Control
  Use HeaderAlwaysUnset Vary
  Use HeaderAlwaysUnset Pragma
  Use HeaderAlwaysUnset Expires
  Use NoCache__ ""     @expr
 </IfDefine>
</Macro>
<Macro NoCacheCond_ @expr>
 Use NoCache__ "" @expr
</Macro>
<Macro NoCache_>
 Use NoCache__ "" "env=no-cache"
</Macro>

DefineStr NoCacheValue "(?i)(?:no-(?:cache|store)|max-age=0)"
<Macro AdaptCachingHeaders>
 <IfDefine !noHeaderChange>
 <IfDefine !noCacheChange>
  # Is no-cache enforced by the request?
  Use SecRule  REQUEST_HEADERS:Cache-Control  "~{NoCacheValue}"  "phase:3,t:none,~{nosecaction},setenv:no-cache"
   
  # Is no-cache enforced by the response?
  Use SecRule RESPONSE_HEADERS:Cache-Control  "~{NoCacheValue}"  "phase:3,t:none,~{nosecaction},setenv:no-cache"
   
  Use NoCache_
 </IfDefine>
 </IfDefine>
</Macro>

<Macro NoCache>
 Use SetEnvSec no-cache 1
 Use NoCache_
</Macro>

<Macro SecNoCache>
 Use NoCache
 Use Warning "SecNoCache is obsolete, use NoCache"
</Macro>

# Enable page caching
<Macro AllowCache>
 Use UnsetEnvSec no-cache
</Macro>

# Enforce page caching
<Macro EnforceCache_ $scope $maxage @expr>
 <IfDefine !noCacheChange>
  Use AllowCache
  #Header edit* Cache-Control "(?i)(?:private|max-age=0|must-revalidate|no-cache|no-store)\s*+(?:,\s*+|$)" ""
  Header set Cache-Control "$scope, must-revalidate, max-age=$maxage, stale-while-revalidate=60" @expr
  Use HeaderUnsetCond Pragma        @expr
  Header edit Expires  "^0" ""      @expr
 </IfDefine>
</Macro>
<Macro EnforceCachePrivate $maxage>
 Use EnforceCache_ "private" "$maxage"            "env=!-"
</Macro>
<Macro EnforceCachePublic $maxage>
 Use EnforceCache_ "public"  "$maxage, immutable" "env=!-"
</Macro>

# For robots : create, in "htdocs", a file "robots.txt" containing
#             User-agent: *
#             Disallow: /
# 
# For Web site icon : create, in "htdocs", a file "favicon.ico" containing site logo

# Enforce local files in case root is proxied
<Macro NoProxy>
 ProxyPass !
 # From 2.4.26 (but not sufficient?)
 Use SetEnvEarly no-proxy 1
 Use AllowLocalPages
</Macro>
<Macro RootFilesLocal_ @url>
 <LocationMatch @url>
  Use NoProxy
 </LocationMatch>
</Macro>
<Macro RootFilesLocal>
 Use RootFilesLocal_ "~{PathToIgnoreRoot}"
</Macro>

# Enforce proxied files in case root is not proxied
<Macro RootFilesProxied>
 RewriteOptions InheritBefore
 <LocationMatch "~{PathToIgnoreRoot}">
  UnSetEnv no-proxy
  # Unless we get a 404 (doesn't work as we allowed the request completely)
  #Use SecRule RESPONSE_STATUS  "^404" "phase:3,t:none,~{skip}:1"
  #Use SecRule TX:url "^.*(/[^/]+)"    "phase:3,t:none,capture,~{localFile}=%{TX.1},~{nolog},~{noErrorHeader},tag:specific"
 </LocationMatch>
</Macro>
<Macro RootFilesProxy @url>
 Use UnusedParam @url
 Use RootFilesProxied
</Macro>

# Don't remap /path/favicon.ico to /favicon.ico (and others)
<Macro IconsNoRemap>
 Use SetEnvEarly IgnoreLocalPath 1
 # Unless we get a 404 (doesn't work as we allowed the request completely)
 #Use SecRule RESPONSE_STATUS "^404"                         "phase:3,t:none,~{skip}:2"
 #Use SecRule ENV:PathToIgnoreIcons|ENV:PathToIgnoreRobots . "phase:3,t:none,~{skip}:1"
 #Use SecRule TX:url "^.*(/[^/]+)"                           "phase:3,t:none,capture,~{localFile}=%{TX.1},~{nolog},~{noErrorHeader},tag:specific"
</Macro>

# Enforce maintenance page
<Macro UnderMaintenanceExt @path @IpToIgnore $page>
 Use NotInsideLocation
 Use SecRule TX:remote_addr @IpToIgnore "phase:1,t:none,tag:security,~{skip}:1"
 Use SecRule TX:url @path               "phase:1,t:none,~{localFile}=/SecError/$page,~{nolog},~{noErrorHeader},tag:specific,msg:'Under maintenance'"
</Macro>
<Macro UnderMaintenance  @path @IpToIgnore>
 Use UnderMaintenanceExt @path @IpToIgnore "unavailable.html"
</Macro>

#
<Macro WebSocketUpgrade $fpath $backssl $backend>
 # Add ws(s):// if missing (and fixes it also)
 RewriteEngine On
 Use SetEnvRew ws_back "$backend"
 # Fix ws(s)
 RewriteCond %{ENV:ws_back} "^(?:wss?://)(.*)"
  Use SetEnvRew ws_back "ws$backssl://%1"
 # Add ws(s) in case it's missing
 RewriteCond %{ENV:ws_back} "^(?![a-z]+://)(.*)"
  Use SetEnvRew ws_back "ws$backssl://%1"
 
 # Upgrade requests must be forwarded as WS to correctly set headers
 # => handles HTTP upgrade request + websocket connection
 RewriteOptions InheritBefore
 RewriteCond %{HTTP:Connection}  "\bUpgrade\b"   [NC]
  RewriteCond %{HTTP:Upgrade}    "\bWebSocket\b" [NC]
   RewriteCond %{REQUEST_METHOD} "=GET"
    RewriteRule "^(?i)$fpath(/.*)?$" "%{ENV:ws_back}$1$2$3$4$5$6$7$8$9" [E=backpath:%{ENV:ws_back}$1$2$3$4$5$6$7$8$9,P,NE,QSA,DPI]
</Macro>

# $ssl contains "s" or ""
<Macro ProxyWebSocketExt $ssl $fpath $backssl $backend>
 <IfModule proxy_wstunnel_module>
  Use WebSocketUpgrade "$fpath" "$backssl" "$backend"
  # Allow path
  Use SecRule REQUEST_URI_RAW "^(?i)(?:$fpath)(?:[/?]|$)" "phase:1,t:none,~{nosecaction},setenv:locationOK"
 </IfModule>
 <IfModule http2_module>
  <IfDirective !H2WebSockets>
   #Use WebSocketUpgrade "$fpath" "$backssl" "$backend"
   Warning Web sockets incompatible with HTTP/2 before httpd 2.4.58 (Define noHTTP2)
   <Location $fpath/>
    Protocols "http/1.1"
   </Location>
  </IfDirective>
 </IfModule>
 Use UnusedParam "$backend $backssl"

 # Negative look-ahead doesn't work because we cannot use %{HOST}e in pattern, but it's cleaned afterward
 Use CSPEdit "connect-src " "connect-src ws$ssl://%{HOST}e wss://%{HOST}e "

 <LocationMatch "^(?:$fpath)(?:/|$)">
  Use SecRuleDeny REQUEST_HEADERS:Origin "!@streq http$ssl://%{REQUEST_HEADERS.Host}"  "phase:2,t:none,~{status}:400,msg:'Request from another site to Web Sockets not allowed'"
  Use SecRuleHeader Sec-WebSocket-Version "!^[1-9][0-9]{0,2}$"      "t:none,msg:'Must be an integer',tag:Protocol"
  Use SecRuleHeader Sec-WebSocket-Key     "!^~{syntax_base64}$"     "t:none,msg:'Must be base64',tag:Protocol"
  # Status 426 means it cannot upgrade => not counted as an attack
  Use SecRule RESPONSE_STATUS "^426"  "phase:3,t:none,tag:logging,tag:Status,~{status}:426,~{noIncreaseBlockCounter},msg:'Back-end cannot upgrade to WSS'"
  # Allow "Connection: upgrade, close"
  Use SecRuleRemoveById 2002941

  # Disable logging of 502 status codes in case of long-polling
  Use NoLog502
 </LocationMatch>
</Macro>

# $ssl contains "s" or ""
<Macro ProxyWebSocket  @ssl @fpath      @backend>
 Use ProxyWebSocketExt @ssl @fpath @ssl @backend
</Macro>

<Macro ProxyWSSocketIO @ssl  $fpath  @backend>
 <IfModule !proxy_wstunnel_module>
  Use UnusedParam @backend
 </IfModule>
 Use ProxyWebSocket    @ssl "$fpath" @backend
 # /socket.io/[?<query string>]
 # The query string is optional:
 #   EIO: current version of the Engine.IO protocol (integer)
 #   transport: transport name ("polling" or "websocket")
 #   j: if the transport is polling but a JSONP response is required,
 #      j must be set with the JSONP response index (integer)
 #   b64=1: all binary data should be sent base64 encoded
 #   sid: if the client has been given a session id, it must be included in the querystring.
 #   t: hashed timestamp for cache-busting (ex: ML4jUwU&b64=1)
 <LocationMatch ^$fpath/>
  Use SecRuleArg EIO "!^[1-9][0-9]{0,3}$"              "t:none,msg:'Must be an integer'" 
  Use SecRuleArg j   "!^[1-9][0-9]{0,3}$"              "t:none,msg:'Must be an integer'" 
  Use SecRuleArg b64 "!^1"                       "t:none,msg:'Must be 1'" 
  Use SecRuleArg transport "!^(?:polling|websocket)$"  "t:none,msg:'Must be polling or websocket'"
  # Allow "polling"? It's supposed to be fallback
 </LocationMatch>
</Macro>

<Macro ProxyWSgRPC  @ssl  $fpath  @backend>
 <IfModule !proxy_wstunnel_module>
  Use UnusedParam @backend
 </IfModule>
 Use ProxyWebSocket @ssl "$fpath" @backend
 <LocationMatch ^$fpath/>
 Use SecAllowContentType "application/grpc"
 # Use Protobuf3
 </LocationMatch>
</Macro>

# Deny web sockets => long polling
<Macro WebSocketDeny>
 RewriteOptions InheritBefore
 RewriteCond %{HTTP:Upgrade}   "^WebSocket\b"  [NC]
  RewriteRule ^ - [F=426,DPI]
</Macro>

# For Mediahub compatibility
<Macro SignalRLongPolling $fpath>
 Use SanitizeCookie tokenSignalR
 # Library generates GET + "Transfer-Encoding: chunked" (phase 1)
 #Use SecRuleRemoveByID 2002916
 <LocationMatch ^$fpath/>
  # For the arg "connectionData"
  Use SecAllowJsonInArgs
  Use SecAllowQueryInPost
  Use SecAllowBase64
  # Content-type should be json-seq, but sometimes it's plain/text => JSON is auto-detected
  Use NoJSONAutodetect "^text/plain"
 </LocationMatch>
 <LocationMatch ^$fpath/poll(?:/|$)>
  Use SecAllowPipeInArg messageId
 </LocationMatch>
</Macro>
<Macro ProxyWSSignalR @ssl @fpath @backend>
 Use ProxyWebSocket   @ssl @fpath @backend
 Use SignalRLongPolling    @fpath
</Macro>
<Macro ProxySignalR @ssl @fpath @backend>
 Use ProxyWSSignalR @ssl @fpath @backend
</Macro>

# :: Create a dynamic proxy forwarding, with URL rewriting in headers & body
#   $frontHttp   = protocol to connect to WAF: "http" or "https"
#   $frontDomain = server name=xxx.$frontDomain, as seen on reverse proxy
#   $frontPort   = port on reverse proxy
#   $frontPath   = path as seen on reverse proxy, without trailing slash
#   $backHttp    = protocol to connect to back-end server: "http", "https" or "balancer"
#   $backDomain  = back-end name=xxx.$backDomain, as seen on back-end
#   $backPort    = port of back-end
#   $backPath    = path of back-end, without trailing slash
<Macro DynamicProxyExt_ $frontHttp $frontDomain $frontPort $frontPath $backHttp $backDomain $backPort $backPath>
 # To allow custom manipulation
 RewriteOptions InheritBefore
 RewriteCond %{ENV:DynProxyRewHost} "^$"
  RewriteCond %{HTTP_HOST} "^(.*)[.]$frontDomain$"
   RewriteRule ^ - [E=DynProxyRewHost:%1]
    
 RewriteCond %{ENV:DynProxyRewHost} .
  RewriteRule ^$frontPath(/.*)$ "$backHttp://%{ENV:DynProxyRewHost}.$backDomain:$backPort$backPath$1" [P,DPI]
   
 Use ProxySetInfo1__ $frontHttp "%{DynProxyRewHost}e.$frontDomain"            "$frontPath""$backHttp://%{DynProxyRewHost}e.$backDomain/$backPort$backPath" "$backHttp://%{ENV.DynProxyRewHost}.$backDomain/$backPort$backPath"
 Use ProxySetInfo2__ $frontHttp "%{DynProxyRewHost}e.$frontDomain" $frontPort "$frontPath" $backHttp  "%{DynProxyRewHost}e.$backDomain" $backPort "$backPath" "%{ENV.DynProxyRewHost}.$backDomain"
</Macro>
<Macro DynamicProxyExt     @frontDomain    @frontPath @backHttp @backDomain @backPort @backPath>
 Use DynamicProxyExt_ http @frontDomain 80 @frontPath @backHttp @backDomain @backPort @backPath
</Macro>
<Macro DynamicProxyExtSSL $frontDomain       @frontPath @backHttp @backDomain @backPort @backPath>
 Use EnforceSSL     ".*[.]$frontDomain"      @frontPath
 Use DynamicProxyExt_ https $frontDomain 443 @frontPath @backHttp @backDomain @backPort @backPath
</Macro>

DefineStr trustTxHost_ "setenv:'allowCORS=%{ENV.allowCORS}|%{MATCHED_VAR}',setvar:'TX.TrustedHosts=%{TX.TrustedHosts}|%{MATCHED_VAR}'"
<Macro ServerAlias $aliases>
 Use NotInsideLocation
 Use SecAction "phase:1,~{nosecaction},setvar:'tx.aliases=$aliases'"
 # "(?:\s+([^ ]+)){0,8}" only capture last one (?)
 Use SecRule TX:aliases "([^ ]+)(?:\s+([^ ]+))?(?:\s+([^ ]+))?(?:\s+([^ ]+))?(?:\s+([^ ]+))?(?:\s+([^ ]+))?(?:\s+([^ ]+))?(?:\s+([^ ]+))?(?:\s+([^ ]+))?" "phase:1,t:none,~{nosecaction},capture,chain"
  Use SecRule TX:1 @unconditionalMatch ~{trustTxHost_},chain
  Use SecRule TX:2 @unconditionalMatch ~{trustTxHost_},chain
  Use SecRule TX:3 @unconditionalMatch ~{trustTxHost_},chain
  Use SecRule TX:4 @unconditionalMatch ~{trustTxHost_},chain
  Use SecRule TX:5 @unconditionalMatch ~{trustTxHost_},chain
  Use SecRule TX:6 @unconditionalMatch ~{trustTxHost_},chain
  Use SecRule TX:7 @unconditionalMatch ~{trustTxHost_},chain
  Use SecRule TX:8 @unconditionalMatch ~{trustTxHost_},chain
  Use SecRule TX:9 @unconditionalMatch ~{trustTxHost_}
 ServerAlias $aliases
 Use SecRule TX:aliases "[^ ]+(?:\s+[^ ]+){9}" "phase:5,t:none,~{warn},msg:'More than 9 aliases defined, cannot trust additional ones'"
</Macro>

# When the application behind the WAF proxies the request to another WAF,
# we need to allow 30+ more headers (they'll be removed anyway)
<Macro WAFProxy>
 Use SecHeadersNbMax 80
</Macro>

<Macro PackageSoftware>
 Use NoOidcHeaders
 Setenv unsetWafheaders
</Macro>
